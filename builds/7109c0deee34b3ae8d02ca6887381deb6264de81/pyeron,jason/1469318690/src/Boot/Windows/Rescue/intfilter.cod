;	Static Name Aliases
;
;	$S1472_BiosMemoryMapSize	EQU	BiosMemoryMapSize
;	$S1422_OriginalInt13Handler	EQU	OriginalInt13Handler
;	$S1423_OriginalInt15Handler	EQU	OriginalInt15Handler
;	$S1424_IntRegisters	EQU	IntRegisters
;	$S1430_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA	EQU	?ReEntryCount@?1??Int13Filter@@YADXZ@4HA
;	$S1525_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA	EQU	?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA
;	$S1531_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA	EQU	?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA
;	$S1533_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA	EQU	?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA
	TITLE   ..\intfilter.cpp
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ??_C@_04PLFG@MMP?3?$AA@
EXTRN	?ReadEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z:NEAR
EXTRN	?GetLinearAddress@@YAKII@Z:NEAR
EXTRN	?RegionsIntersect@@YADABTUINT64_STRUCT@@K00@Z:NEAR
EXTRN	?WriteEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z:NEAR
EXTRN	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z:NEAR
EXTRN	?Print@@YAXK@Z:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z:NEAR
EXTRN	_memcpy:NEAR
EXTRN	?GetFirstBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z:NEAR
EXTRN	?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z:NEAR
EXTRN	?GetNextBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z:NEAR
EXTRN	?PrintEndl@@YAXXZ:NEAR
EXTRN	_ThrowFatalException:NEAR
EXTRN	?PrintErrorNoEndl@@YAXPBD@Z:NEAR
EXTRN	??O@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	??M@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	?CopyMemory@@YAXPAXIII@Z:NEAR
EXTRN	?CopyMemory@@YAXIIPAXI@Z:NEAR
EXTRN	?BootSectorFlags@@3EA:BYTE
EXTRN	?BootDrive@@3EA:BYTE
EXTRN	?BootDriveGeometryValid@@3DA:BYTE
EXTRN	?BootDriveGeometry@@3UDriveGeometry@@A:DWORD
EXTRN	?EncryptedVirtualPartition@@3UPartition@@A:BYTE
_DATA      SEGMENT
$S1430_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA	DW	0ffffH
	ORG	$-2
??_C@_04PLFG@MMP?3?$AA@	DB	'MMP:',  00H
	ORG	$-3
$S1525_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA	DW	00H
_DATA      ENDS
_BSS      SEGMENT
	ORG	$+1636
$S1472_BiosMemoryMapSize	DW 01H DUP (?)
	ORG	$-1638
$S1422_OriginalInt13Handler	DW 02H DUP (?)
$S1423_OriginalInt15Handler	DW 02H DUP (?)
$S1424_IntRegisters	DW 0eH DUP (?)
	ORG	$+1602
$S1531_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA	DW 01H DUP (?)
$S1533_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA	DW 01H DUP (?)
	ORG	$-1606
PUBLIC  ?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A
?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	DW 0320H DUP (?)
_BSS      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	?Int13Filter@@YADXZ	; Int13Filter
?Int13Filter@@YADXZ	PROC NEAR	; Int13Filter COMDAT
;|*** /*
;|***  Copyright (c) 2008 TrueCrypt Developers Association. All rights reserved.
;|*** 
;|***  Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  the file License.txt included in TrueCrypt binary and source code distribution
;|***  packages.
;|*** */
;|*** 
;|*** #include "Platform.h"
;|*** #include "BootMemory.h"
;|*** #include "BootConfig.h"
;|*** #include "BootConsoleIo.h"
;|*** #include "BootDebug.h"
;|*** #include "BootDefs.h"
;|*** #include "BootDiskIo.h"
;|*** #include "BootEncryptedIo.h"
;|*** #include "BootStrings.h"
;|*** #include "IntFilter.h"
;|*** 
;|*** static uint32 OriginalInt13Handler;
;|*** static uint32 OriginalInt15Handler;
;|*** 
;|*** static Registers IntRegisters;
;|*** 
;|*** 
;|*** bool Int13Filter ()
;|*** {
; Line 27
	*** 000000	c8 42 00 00 		enter	66,0
;	regs = -28
;	function = -30
;	passOriginalRequest = -32
;|*** 	CheckStack();
;|*** 
;|*** 	Registers regs;
;|*** 	memcpy (&regs, &IntRegisters, sizeof (regs));
; Line 31
	*** 000004	6a 1c 			push	28	;001cH
	*** 000006	68 00 00 		push	OFFSET DGROUP:$S1424_IntRegisters
	*** 000009	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;regs
	*** 00000c	50 			push	ax
	*** 00000d	e8 00 00 		call	_memcpy
	*** 000010	83 c4 06 		add	sp,6
;|*** 	__asm sti
; Line 32
	*** 000013	fb 			sti	
;|*** 
;|*** 	static int ReEntryCount = -1;
;|*** 	++ReEntryCount;
; Line 35
	*** 000014	ff 06 00 00 		inc	WORD PTR $S1430_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA
;|*** 
;|*** 	byte function = (byte) (regs.AX >> 8);
;|*** 
;|*** #ifdef TC_TRACE_INT13
;|*** 	DisableScreenOutput();
;|*** 
;|*** 	PrintHex (function);
;|*** 
;|*** 	Print (" EN:"); Print (ReEntryCount);
;|*** 	Print (" SS:"); PrintHex (regs.SS);
;|*** 
;|*** 	uint16 spdbg;
;|*** 	__asm mov spdbg, sp
;|*** 	PrintChar (' ');
;|*** 	PrintHex (spdbg);
;|*** 	PrintChar ('<'); PrintHex (TC_BOOT_LOADER_STACK_TOP);
;|*** 
;|*** #endif
;|*** 
;|*** 	bool passOriginalRequest = true;
; Line 55
	*** 000018	c6 46 e0 01 		mov	BYTE PTR [bp-32],1	;passOriginalRequest
;|*** 
;|*** 	switch (function)
; Line 57
	*** 00001c	8a 46 e7 		mov	al,BYTE PTR [bp-25]
	*** 00001f	88 46 e2 		mov	BYTE PTR [bp-30],al	;function
	*** 000022	2a e4 			sub	ah,ah
	*** 000024	48 			dec	ax
	*** 000025	48 			dec	ax
	*** 000026	7c 02 			jl	SHORT $L1560
	*** 000028	71 03 			jno	SHORT $L1559
					$L1560:
	*** 00002a	e9 7f 01 		jmp	$SD1470
					$L1559:
	*** 00002d	48 			dec	ax
	*** 00002e	7e 0f 			jle	SHORT $SC1438
	*** 000030	2d 3f 00 		sub	ax,63	;003fH
	*** 000033	0f 8c 75 01 		jl	$SD1470
	*** 000037	48 			dec	ax
	*** 000038	0f 8e db 00 		jle	$SC1454
	*** 00003c	e9 6d 01 		jmp	$SD1470
;|*** 	{
;|*** 	case 0x2: // Read sectors
; Line 59
					$SC1438:
;|*** 	case 0x3: // Write sectors
;|*** 		{
; Line 61
;	drive = -34
;	chs = -38
;	sectorCount = -40
;	sector = -48
;|*** 			byte drive = (byte) regs.DX;
; Line 62
	*** 00003f	8a 46 f2 		mov	al,BYTE PTR [bp-14]
	*** 000042	88 46 de 		mov	BYTE PTR [bp-34],al	;drive
;|*** 
;|*** 			ChsAddress chs;
;|*** 			chs.Cylinder = ((regs.CX << 2) & 0x300) | (regs.CX >> 8);
; Line 65
	*** 000045	8a 4e ee 		mov	cl,BYTE PTR [bp-18]
	*** 000048	81 e1 c0 00 		and	cx,192	;00c0H
	*** 00004c	c1 e1 02 		shl	cx,2
	*** 00004f	8a 56 ef 		mov	dl,BYTE PTR [bp-17]
	*** 000052	2a f6 			sub	dh,dh
	*** 000054	0b ca 			or	cx,dx
	*** 000056	89 4e da 		mov	WORD PTR [bp-38],cx	;chs
;|*** 			chs.Head = regs.DX >> 8;
; Line 66
	*** 000059	8a 4e f3 		mov	cl,BYTE PTR [bp-13]
	*** 00005c	88 4e dc 		mov	BYTE PTR [bp-36],cl
;|*** 			chs.Sector = regs.CX & 0x3f;
; Line 67
	*** 00005f	8a 4e ee 		mov	cl,BYTE PTR [bp-18]
	*** 000062	80 e1 3f 		and	cl,63	;003fH
	*** 000065	88 4e dd 		mov	BYTE PTR [bp-35],cl
;|*** 
;|*** 			byte sectorCount = (byte) regs.AX;
; Line 69
	*** 000068	8a 4e e6 		mov	cl,BYTE PTR [bp-26]
	*** 00006b	88 4e d8 		mov	BYTE PTR [bp-40],cl	;sectorCount
;|*** 
;|*** #ifdef TC_TRACE_INT13
;|*** 			PrintVal (": Drive", drive - TC_FIRST_BIOS_DRIVE, false);
;|*** 			Print (" Chs: "); Print (chs);
;|*** #endif
;|*** 
;|*** 			uint64 sector;
;|*** 			if (drive == BootDrive)
; Line 77
	*** 00006e	3a 06 00 00 		cmp	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000072	75 1d 			jne	SHORT $I1445
;|*** 			{
;|*** 				if (!BootDriveGeometryValid)
; Line 79
	*** 000074	38 36 00 00 		cmp	BYTE PTR ?BootDriveGeometryValid@@3DA,dh	;BootDriveGeometryValid
	*** 000078	75 06 			jne	SHORT $I1446
;|*** 					TC_THROW_FATAL_EXCEPTION;
; Line 80
	*** 00007a	6a 50 			push	80	;0050H
	*** 00007c	e8 00 00 		call	_ThrowFatalException
	*** 00007f	5b 			pop	bx
;|*** 
;|*** 				ChsToLba (BootDriveGeometry, chs, sector);
; Line 82
					$I1446:
	*** 000080	8d 46 d0 		lea	ax,WORD PTR [bp-48]	;sector
	*** 000083	50 			push	ax
	*** 000084	8d 46 da 		lea	ax,WORD PTR [bp-38]	;chs
	*** 000087	50 			push	ax
	*** 000088	68 00 00 		push	OFFSET ?BootDriveGeometry@@3UDriveGeometry@@A	;BootDriveGeometry
	*** 00008b	e8 00 00 		call	?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z	; ChsToLba
	*** 00008e	83 c4 06 		add	sp,6
;|*** #ifdef TC_TRACE_INT13
;|*** 				PrintVal (" Sec", sector.LowPart, false);
;|*** #endif
;|*** 			}
;|*** 
;|*** #ifdef TC_TRACE_INT13
;|*** 			PrintVal (" Count", sectorCount, false);
;|*** 			Print (" Buf: "); PrintHex (regs.ES); PrintChar (':'); PrintHex (regs.BX);
;|*** 			PrintEndl();
;|*** #endif
;|*** 
;|*** 			if (ReEntryCount == 0 && drive == EncryptedVirtualPartition.Drive)
; Line 94
					$I1445:
	*** 000091	83 3e 00 00 00 		cmp	WORD PTR $S1430_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA,0
	*** 000096	75 08 			jne	SHORT $L1562
	*** 000098	a0 01 00 		mov	al,BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1	;EncryptedVirtualPartition
	*** 00009b	38 46 de 		cmp	BYTE PTR [bp-34],al	;drive
	*** 00009e	74 03 			je	SHORT $L1561
;|*** 			{
; Line 95
;	result = -50
;|*** 				BiosResult result;
;|*** 				
;|*** 				if (function == 0x3)
; Line 98
					$L1562:
	*** 0000a0	e9 09 01 		jmp	$SD1470
					$L1561:
	*** 0000a3	80 7e e2 03 		cmp	BYTE PTR [bp-30],3	;function
	*** 0000a7	75 1d 			jne	SHORT $I1449
;|*** 					result = WriteEncryptedSectors (regs.ES, regs.BX, drive, sector, sectorCount);
; Line 99
	*** 0000a9	8a 46 d8 		mov	al,BYTE PTR [bp-40]	;sectorCount
	*** 0000ac	2a e4 			sub	ah,ah
	*** 0000ae	50 			push	ax
	*** 0000af	66 ff 76 d4 		push	DWORD PTR [bp-44]
	*** 0000b3	66 ff 76 d0 		push	DWORD PTR [bp-48]	;sector
	*** 0000b7	8a 46 de 		mov	al,BYTE PTR [bp-34]	;drive
	*** 0000ba	50 			push	ax
	*** 0000bb	ff 76 ea 		push	WORD PTR [bp-22]
	*** 0000be	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0000c1	e8 00 00 		call	?WriteEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; WriteEncryptedSectors
	*** 0000c4	eb 1b 			jmp	SHORT $L1554
					$I1449:
;|*** 				else
;|*** 					result = ReadEncryptedSectors (regs.ES, regs.BX, drive, sector, sectorCount);
; Line 101
	*** 0000c6	8a 46 d8 		mov	al,BYTE PTR [bp-40]	;sectorCount
	*** 0000c9	2a e4 			sub	ah,ah
	*** 0000cb	50 			push	ax
	*** 0000cc	66 ff 76 d4 		push	DWORD PTR [bp-44]
	*** 0000d0	66 ff 76 d0 		push	DWORD PTR [bp-48]	;sector
	*** 0000d4	8a 46 de 		mov	al,BYTE PTR [bp-34]	;drive
	*** 0000d7	50 			push	ax
	*** 0000d8	ff 76 ea 		push	WORD PTR [bp-22]
	*** 0000db	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0000de	e8 00 00 		call	?ReadEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; ReadEncryptedSectors
					$L1554:
	*** 0000e1	83 c4 10 		add	sp,16	;0010H
	*** 0000e4	88 46 ce 		mov	BYTE PTR [bp-50],al	;result
;|*** 
;|*** 				__asm cli
; Line 103
	*** 0000e7	fa 			cli	
;|*** 
;|*** 				memcpy (&IntRegisters, &regs, sizeof (regs));
; Line 105
	*** 0000e8	6a 1c 			push	28	;001cH
	*** 0000ea	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;regs
	*** 0000ed	50 			push	ax
	*** 0000ee	68 00 00 		push	OFFSET DGROUP:$S1424_IntRegisters
	*** 0000f1	e8 00 00 		call	_memcpy
	*** 0000f4	83 c4 06 		add	sp,6
;|*** 				IntRegisters.AX = (uint16) result << 8;
; Line 106
	*** 0000f7	8a 66 ce 		mov	ah,BYTE PTR [bp-50]	;result
	*** 0000fa	2a c0 			sub	al,al
	*** 0000fc	a3 02 00 		mov	WORD PTR $S1424_IntRegisters+2,ax
;|*** 
;|*** 				if (result == BiosResultSuccess)
; Line 108
	*** 0000ff	0a e4 			or	ah,ah
	*** 000101	0f 85 9e 00 		jne	$I1452
;|*** 				{
;|*** 					IntRegisters.AX |= sectorCount;
; Line 110
	*** 000105	8a 4e d8 		mov	cl,BYTE PTR [bp-40]	;sectorCount
	*** 000108	2a ed 			sub	ch,ch
	*** 00010a	0b c1 			or	ax,cx
	*** 00010c	a3 02 00 		mov	WORD PTR $S1424_IntRegisters+2,ax
;|*** 					IntRegisters.Flags &= ~TC_X86_CARRY_FLAG;
; Line 111
					$L1557:
	*** 00010f	80 26 00 00 fe 		and	BYTE PTR $S1424_IntRegisters,254	;00feH
;|*** 				}
;|*** 				else
; Line 113
	*** 000114	e9 91 00 		jmp	$I1453
;|*** 					IntRegisters.Flags |= TC_X86_CARRY_FLAG;
;|*** 
;|*** 				passOriginalRequest = false;
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	case 0x42: // Read sectors LBA
; Line 121
					$SC1454:
;|*** 	case 0x43: // Write sectors LBA
;|*** 		{
; Line 123
;	drive = -50
;	lba = -66
;|*** 			byte drive = (byte) regs.DX;
; Line 124
	*** 000117	8a 46 f2 		mov	al,BYTE PTR [bp-14]
	*** 00011a	88 46 ce 		mov	BYTE PTR [bp-50],al	;result
;|*** 			
;|*** 			BiosLbaPacket lba;
;|*** 			CopyMemory (regs.DS, regs.SI, (byte *) &lba, sizeof (lba));
; Line 127
	*** 00011d	6a 10 			push	16	;0010H
	*** 00011f	8d 46 be 		lea	ax,WORD PTR [bp-66]	;lba
	*** 000122	50 			push	ax
	*** 000123	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000126	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000129	e8 00 00 		call	?CopyMemory@@YAXIIPAXI@Z	; CopyMemory
	*** 00012c	83 c4 08 		add	sp,8
;|*** 
;|*** #ifdef TC_TRACE_INT13
;|*** 			PrintVal (": Drive", drive - TC_FIRST_BIOS_DRIVE, false);
;|*** 			PrintVal (" Sec", lba.Sector.LowPart, false);
;|*** 			PrintVal (" Count", lba.SectorCount, false);
;|*** 			PrintVal (" Buf", lba.Buffer, false, true);
;|*** 			PrintEndl();
;|*** #endif
;|*** 
;|*** 			if (ReEntryCount == 0 && drive == EncryptedVirtualPartition.Drive)
; Line 137
	*** 00012f	83 3e 00 00 00 		cmp	WORD PTR $S1430_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA,0
	*** 000134	75 76 			jne	SHORT $SD1470
	*** 000136	a0 01 00 		mov	al,BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1	;EncryptedVirtualPartition
	*** 000139	38 46 ce 		cmp	BYTE PTR [bp-50],al	;result
	*** 00013c	75 6e 			jne	SHORT $SD1470
;|*** 			{
; Line 138
;	result = -48
;	segment = -40
;	offset = -38
;|*** 				BiosResult result;
;|*** 				
;|*** 				uint16 segment = (uint16) (lba.Buffer >> 16);
; Line 141
	*** 00013e	8b 46 c4 		mov	ax,WORD PTR [bp-60]
	*** 000141	89 46 d8 		mov	WORD PTR [bp-40],ax	;sectorCount
;|*** 				uint16 offset = (uint16) lba.Buffer;
; Line 142
	*** 000144	8b 46 c2 		mov	ax,WORD PTR [bp-62]
	*** 000147	89 46 da 		mov	WORD PTR [bp-38],ax	;chs
;|*** 
;|*** 				if (function == 0x43)
; Line 144
	*** 00014a	80 7e e2 43 		cmp	BYTE PTR [bp-30],67	;0043H	;function
	*** 00014e	75 18 			jne	SHORT $I1465
;|*** 					result = WriteEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
; Line 145
	*** 000150	ff 76 c0 		push	WORD PTR [bp-64]
	*** 000153	66 ff 76 ca 		push	DWORD PTR [bp-54]
	*** 000157	66 ff 76 c6 		push	DWORD PTR [bp-58]
	*** 00015b	8a 46 ce 		mov	al,BYTE PTR [bp-50]	;result
	*** 00015e	50 			push	ax
	*** 00015f	66 ff 76 d8 		push	DWORD PTR [bp-40]	;sectorCount
	*** 000163	e8 00 00 		call	?WriteEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; WriteEncryptedSectors
	*** 000166	eb 16 			jmp	SHORT $L1555
					$I1465:
;|*** 				else
;|*** 					result = ReadEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
; Line 147
	*** 000168	ff 76 c0 		push	WORD PTR [bp-64]
	*** 00016b	66 ff 76 ca 		push	DWORD PTR [bp-54]
	*** 00016f	66 ff 76 c6 		push	DWORD PTR [bp-58]
	*** 000173	8a 46 ce 		mov	al,BYTE PTR [bp-50]	;result
	*** 000176	50 			push	ax
	*** 000177	66 ff 76 d8 		push	DWORD PTR [bp-40]	;sectorCount
	*** 00017b	e8 00 00 		call	?ReadEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; ReadEncryptedSectors
					$L1555:
	*** 00017e	83 c4 10 		add	sp,16	;0010H
	*** 000181	88 46 d0 		mov	BYTE PTR [bp-48],al	;sector
;|*** 
;|*** 				__asm cli
; Line 149
	*** 000184	fa 			cli	
;|*** 
;|*** 				memcpy (&IntRegisters, &regs, sizeof (regs));
; Line 151
	*** 000185	6a 1c 			push	28	;001cH
	*** 000187	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;regs
	*** 00018a	50 			push	ax
	*** 00018b	68 00 00 		push	OFFSET DGROUP:$S1424_IntRegisters
	*** 00018e	e8 00 00 		call	_memcpy
	*** 000191	83 c4 06 		add	sp,6
;|*** 				IntRegisters.AX = (IntRegisters.AX & 0xff) | ((uint16) result << 8);
; Line 152
	*** 000194	a0 02 00 		mov	al,BYTE PTR $S1424_IntRegisters+2
	*** 000197	8a 66 d0 		mov	ah,BYTE PTR [bp-48]	;sector
	*** 00019a	a3 02 00 		mov	WORD PTR $S1424_IntRegisters+2,ax
;|*** 
;|*** 				if (result == BiosResultSuccess)
; Line 154
	*** 00019d	0a e4 			or	ah,ah
	*** 00019f	0f 84 6c ff 		je	$L1557
					$I1452:
;|*** 					IntRegisters.Flags |= TC_X86_CARRY_FLAG;
; Line 114
	*** 0001a3	80 0e 00 00 01 		or	BYTE PTR $S1424_IntRegisters,1
					$I1453:
;|*** 
;|*** 				passOriginalRequest = false;
; Line 116
	*** 0001a8	c6 46 e0 00 		mov	BYTE PTR [bp-32],0	;passOriginalRequest
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	case 0x42: // Read sectors LBA
;|*** 	case 0x43: // Write sectors LBA
;|*** 		{
;|*** 			byte drive = (byte) regs.DX;
;|*** 			
;|*** 			BiosLbaPacket lba;
;|*** 			CopyMemory (regs.DS, regs.SI, (byte *) &lba, sizeof (lba));
;|*** 
;|*** #ifdef TC_TRACE_INT13
;|*** 			PrintVal (": Drive", drive - TC_FIRST_BIOS_DRIVE, false);
;|*** 			PrintVal (" Sec", lba.Sector.LowPart, false);
;|*** 			PrintVal (" Count", lba.SectorCount, false);
;|*** 			PrintVal (" Buf", lba.Buffer, false, true);
;|*** 			PrintEndl();
;|*** #endif
;|*** 
;|*** 			if (ReEntryCount == 0 && drive == EncryptedVirtualPartition.Drive)
;|*** 			{
;|*** 				BiosResult result;
;|*** 				
;|*** 				uint16 segment = (uint16) (lba.Buffer >> 16);
;|*** 				uint16 offset = (uint16) lba.Buffer;
;|*** 
;|*** 				if (function == 0x43)
;|*** 					result = WriteEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
;|*** 				else
;|*** 					result = ReadEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
;|*** 
;|*** 				__asm cli
;|*** 
;|*** 				memcpy (&IntRegisters, &regs, sizeof (regs));
;|*** 				IntRegisters.AX = (IntRegisters.AX & 0xff) | ((uint16) result << 8);
;|*** 
;|*** 				if (result == BiosResultSuccess)
;|*** 					IntRegisters.Flags &= ~TC_X86_CARRY_FLAG;
;|*** 				else
;|*** 					IntRegisters.Flags |= TC_X86_CARRY_FLAG;
;|*** 
;|*** 				passOriginalRequest = false;
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	default:
; Line 164
					$SD1470:
;|*** #ifdef TC_TRACE_INT13
;|*** 		PrintEndl();
;|*** #endif
;|*** 		break;
;|*** 	}
;|*** 
;|*** #ifdef TC_TRACE_INT13
;|*** 	EnableScreenOutput();
;|*** #endif
;|*** 	--ReEntryCount;
; Line 174
	*** 0001ac	ff 0e 00 00 		dec	WORD PTR $S1430_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA
;|*** 
;|*** 	return passOriginalRequest;
; Line 176
	*** 0001b0	8a 46 e0 		mov	al,BYTE PTR [bp-32]	;passOriginalRequest
;|*** }
; Line 177
	*** 0001b3	c9 			leave	
	*** 0001b4	c3 			ret	

?Int13Filter@@YADXZ	ENDP

?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	PROC NEAR	; CreateBootLoaderMemoryMapEntry COMDAT
;|*** 
;|*** 
;|*** #define TC_MAX_MEMORY_MAP_SIZE 80
;|*** 
;|*** BiosMemoryMapEntry BiosMemoryMap[TC_MAX_MEMORY_MAP_SIZE];
;|*** static size_t BiosMemoryMapSize;
;|*** 
;|*** 
;|*** static void CreateBootLoaderMemoryMapEntry (BiosMemoryMapEntry *newMapEntry, uint32 bootLoaderStart)
;|*** {
; Line 187
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	newMapEntry = 4
;	bootLoaderStart = 6
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;newMapEntry
;|*** 	newMapEntry->Type = 0x2;
; Line 188
	*** 000006	66 c7 47 10 02 00 00 00 mov	DWORD PTR [bx+16],2
;|*** 	newMapEntry->BaseAddress.HighPart = 0;
; Line 189
	*** 00000e	66 c7 47 04 00 00 00 00 mov	DWORD PTR [bx+4],0
;|*** 	newMapEntry->BaseAddress.LowPart = bootLoaderStart;
; Line 190
	*** 000016	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;bootLoaderStart
	*** 00001a	66 89 07 		mov	DWORD PTR [bx],eax
;|*** 	newMapEntry->Length.HighPart = 0;
; Line 191
	*** 00001d	66 2b c0 		sub	eax,eax
	*** 000020	66 89 47 0c 		mov	DWORD PTR [bx+12],eax
;|*** 	newMapEntry->Length.LowPart = TC_BOOT_MEMORY_REQUIRED * 1024UL;
; Line 192
	*** 000024	c7 47 08 00 a8 		mov	WORD PTR [bx+8],-22528	;a800H
	*** 000029	89 47 0a 		mov	WORD PTR [bx+10],ax
;|*** }
; Line 193
	*** 00002c	c9 			leave	
	*** 00002d	c3 			ret	

?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	ENDP

?CreateNewBiosMemoryMap@@YADXZ	PROC NEAR	; CreateNewBiosMemoryMap COMDAT
;|*** 
;|*** 
;|*** static bool CreateNewBiosMemoryMap ()
;|*** {
; Line 197
	*** 000000	c8 40 00 00 		enter	64,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	entry = -20
;	newMapEntry = -22
;	mapEnd = -24
;	bootLoaderStart = -32
;	codeSeg = -34
;	bootLoaderEnd = -42
;	loaderEntryInserted = -44
;	overSize = -46
;|*** 	// Create a new BIOS memory map presenting the memory area of the loader as reserved
;|*** 
;|*** 	BiosMemoryMapSize = 0;
; Line 200
	*** 000006	c7 06 00 00 00 00 	mov	WORD PTR $S1472_BiosMemoryMapSize,0
;|*** 	BiosMemoryMapEntry entry;
;|*** 	BiosMemoryMapEntry *newMapEntry = BiosMemoryMap;
; Line 202
	*** 00000c	c7 46 ea 00 00 		mov	WORD PTR [bp-22],OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	;newMapEntry	;BiosMemoryMap
;|*** 
;|*** 	const BiosMemoryMapEntry *mapEnd = BiosMemoryMap + TC_MAX_MEMORY_MAP_SIZE;
; Line 204
	*** 000011	c7 46 e8 40 06 		mov	WORD PTR [bp-24],OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A+1600	;mapEnd	;BiosMemoryMap
;|*** 
;|*** 	uint64 bootLoaderStart;
;|*** 	bootLoaderStart.HighPart = 0;
; Line 207
	*** 000016	66 2b c0 		sub	eax,eax
	*** 000019	66 89 46 e4 		mov	DWORD PTR [bp-28],eax
;|*** 
;|*** 	uint16 codeSeg;
;|*** 	__asm mov codeSeg, cs
; Line 210
	*** 00001d	8c 4e de 		mov	WORD PTR [bp-34],cs	;codeSeg
;|*** 	bootLoaderStart.LowPart = GetLinearAddress (codeSeg, 0);
; Line 211
	*** 000020	6a 00 			push	0
	*** 000022	ff 76 de 		push	WORD PTR [bp-34]	;codeSeg
	*** 000025	e8 00 00 		call	?GetLinearAddress@@YAKII@Z	; GetLinearAddress
	*** 000028	83 c4 04 		add	sp,4
	*** 00002b	89 46 e0 		mov	WORD PTR [bp-32],ax	;bootLoaderStart
	*** 00002e	89 56 e2 		mov	WORD PTR [bp-30],dx
;|*** 
;|*** 	uint64 bootLoaderEnd;
;|*** 	bootLoaderEnd.HighPart = 0;
; Line 214
	*** 000031	66 c7 46 da 00 00 00 00 mov	DWORD PTR [bp-38],0
;|*** 	bootLoaderEnd.LowPart = bootLoaderStart.LowPart + TC_BOOT_MEMORY_REQUIRED * 1024UL;
; Line 215
	*** 000039	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 00003c	80 c4 a8 		add	ah,168	;00a8H
	*** 00003f	83 d2 00 		adc	dx,0
	*** 000042	89 46 d6 		mov	WORD PTR [bp-42],ax	;bootLoaderEnd
	*** 000045	89 56 d8 		mov	WORD PTR [bp-40],dx
;|*** 
;|*** 	bool loaderEntryInserted = false;
; Line 217
	*** 000048	c6 46 d4 00 		mov	BYTE PTR [bp-44],0	;loaderEntryInserted
;|*** 
;|*** 	if (GetFirstBiosMemoryMapEntry (entry))
; Line 219
	*** 00004c	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 00004f	50 			push	ax
	*** 000050	e8 00 00 		call	?GetFirstBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z	; GetFirstBiosMemoryMapEntry
	*** 000053	5b 			pop	bx
	*** 000054	0a c0 			or	al,al
	*** 000056	0f 84 7a 01 		je	$I1487
;|*** 	{
;|*** 		do
; Line 221
					$D1488:
;|*** 		{
; Line 222
;	entryEnd = -54
;|*** 			uint64 entryEnd = entry.BaseAddress + entry.Length;
; Line 223
	*** 00005a	8d 46 f4 		lea	ax,WORD PTR [bp-12]
	*** 00005d	50 			push	ax
	*** 00005e	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 000061	50 			push	ax
	*** 000062	8d 4e c2 		lea	cx,WORD PTR [bp-62]
	*** 000065	51 			push	cx
	*** 000066	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator+
	*** 000069	83 c4 06 		add	sp,6
	*** 00006c	8d 7e ca 		lea	di,WORD PTR [bp-54]	;entryEnd
	*** 00006f	8b f0 			mov	si,ax
	*** 000071	16 			push	ss
	*** 000072	07 			pop	es
	*** 000073	66 a5 			movsd
	*** 000075	66 a5 			movsd
;|*** 
;|*** 			if (entry.Type == 0x1 && RegionsIntersect (bootLoaderStart, TC_BOOT_MEMORY_REQUIRED * 1024UL, entry.BaseAddress, entryEnd - 1))
; Line 225
	*** 000077	66 83 7e fc 01 		cmp	DWORD PTR [bp-4],1
	*** 00007c	0f 85 f7 00 		jne	$I1494
	*** 000080	6a 00 			push	0
	*** 000082	6a 01 			push	1
	*** 000084	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;entryEnd
	*** 000087	50 			push	ax
	*** 000088	8d 46 c2 		lea	ax,WORD PTR [bp-62]
	*** 00008b	50 			push	ax
	*** 00008c	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 00008f	83 c4 08 		add	sp,8
	*** 000092	50 			push	ax
	*** 000093	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 000096	50 			push	ax
	*** 000097	6a 00 			push	0
	*** 000099	68 00 a8 		push	-22528	;a800H
	*** 00009c	8d 4e e0 		lea	cx,WORD PTR [bp-32]	;bootLoaderStart
	*** 00009f	51 			push	cx
	*** 0000a0	e8 00 00 		call	?RegionsIntersect@@YADABTUINT64_STRUCT@@K00@Z	; RegionsIntersect
	*** 0000a3	83 c4 0a 		add	sp,10	;000aH
	*** 0000a6	0a c0 			or	al,al
	*** 0000a8	0f 84 cb 00 		je	$I1494
;|*** 			{
;|*** 				// Free map entry covers the boot loader area
;|*** 
;|*** 				if (entry.BaseAddress < bootLoaderStart)
; Line 229
	*** 0000ac	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 0000af	50 			push	ax
	*** 0000b0	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0000b3	50 			push	ax
	*** 0000b4	e8 00 00 		call	??M@YADABTUINT64_STRUCT@@0@Z	; operator<
	*** 0000b7	83 c4 04 		add	sp,4
	*** 0000ba	0a c0 			or	al,al
	*** 0000bc	74 41 			je	SHORT $I1495
;|*** 				{
;|*** 					// Create free entry below the boot loader area
;|*** 					if (newMapEntry >= mapEnd)
; Line 232
	*** 0000be	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 0000c1	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 0000c4	77 08 			ja	SHORT $I1496
;|*** 						goto mapOverflow;
; Line 233
					$mapOverflow1497:
;|*** 
;|*** 					*newMapEntry = entry;
;|*** 					newMapEntry->Length = bootLoaderStart - entry.BaseAddress;
;|*** 					++newMapEntry;
;|*** 				}
;|*** 
;|*** 				if (!loaderEntryInserted)
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					if (newMapEntry >= mapEnd)
;|*** 						goto mapOverflow;
;|*** 
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
;|*** 					++newMapEntry;
;|*** 					loaderEntryInserted = true;
;|*** 				}
;|*** 
;|*** 				if (bootLoaderEnd < entryEnd)
;|*** 				{
;|*** 					// Create free entry above the boot loader area
;|*** 					if (newMapEntry >= mapEnd)
;|*** 						goto mapOverflow;
;|*** 
;|*** 					newMapEntry->Type = 0x1;
;|*** 					newMapEntry->BaseAddress = bootLoaderEnd;
;|*** 					newMapEntry->Length = entryEnd - bootLoaderEnd;
;|*** 					++newMapEntry;
;|*** 				}
;|*** 			}
;|*** 			else
;|*** 			{
;|*** 				if (newMapEntry >= mapEnd)
;|*** 					goto mapOverflow;
;|*** 
;|*** 				if (!loaderEntryInserted && entry.BaseAddress > bootLoaderStart)
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
;|*** 					++newMapEntry;
;|*** 					loaderEntryInserted = true;
;|*** 				}
;|*** 
;|*** 				// Copy map entry
;|*** 				*newMapEntry++ = entry;
;|*** 			}
;|*** 
;|*** 		} while (GetNextBiosMemoryMapEntry (entry));
;|*** 	}
;|*** 
;|*** 	BiosMemoryMapSize = newMapEntry - BiosMemoryMap;
;|*** 	return true;
;|*** 
;|*** mapOverflow:
;|*** 	size_t overSize = 0;
; Line 287
	*** 0000c6	c7 46 d2 00 00 		mov	WORD PTR [bp-46],0	;overSize
;|*** 	while (GetNextBiosMemoryMapEntry (entry))
; Line 288
	*** 0000cb	e9 1c 01 		jmp	$L1563
					$I1496:
	*** 0000ce	8d 76 ec 		lea	si,WORD PTR [bp-20]	;entry
	*** 0000d1	1e 			push	ds
	*** 0000d2	07 			pop	es
	*** 0000d3	8b 7e ea 		mov	di,WORD PTR [bp-22]	;newMapEntry
	*** 0000d6	b9 0a 00 		mov	cx,10	;000aH
	*** 0000d9	f3 			rep
	*** 0000da	a5 			movsw
;|*** 					newMapEntry->Length = bootLoaderStart - entry.BaseAddress;
; Line 236
	*** 0000db	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0000de	50 			push	ax
	*** 0000df	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 0000e2	50 			push	ax
	*** 0000e3	8d 46 c2 		lea	ax,WORD PTR [bp-62]
	*** 0000e6	50 			push	ax
	*** 0000e7	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator-
	*** 0000ea	83 c4 06 		add	sp,6
	*** 0000ed	8b 5e ea 		mov	bx,WORD PTR [bp-22]	;newMapEntry
	*** 0000f0	8d 7f 08 		lea	di,WORD PTR [bx+8]
	*** 0000f3	8b f0 			mov	si,ax
	*** 0000f5	1e 			push	ds
	*** 0000f6	07 			pop	es
	*** 0000f7	66 a5 			movsd
	*** 0000f9	66 a5 			movsd
;|*** 					++newMapEntry;
; Line 237
	*** 0000fb	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 				}
;|*** 
;|*** 				if (!loaderEntryInserted)
; Line 240
					$I1495:
	*** 0000ff	80 7e d4 00 		cmp	BYTE PTR [bp-44],0	;loaderEntryInserted
	*** 000103	75 1b 			jne	SHORT $I1500
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					if (newMapEntry >= mapEnd)
; Line 243
	*** 000105	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 000108	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 00010b	76 b9 			jbe	SHORT $mapOverflow1497
;|*** 						goto mapOverflow;
; Line 244
	*** 00010d	66 ff 76 e0 		push	DWORD PTR [bp-32]	;bootLoaderStart
	*** 000111	50 			push	ax
	*** 000112	e8 00 00 		call	?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	; CreateBootLoaderMemoryMapEntry
	*** 000115	83 c4 06 		add	sp,6
;|*** 
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
;|*** 					++newMapEntry;
; Line 247
	*** 000118	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 					loaderEntryInserted = true;
; Line 248
	*** 00011c	c6 46 d4 01 		mov	BYTE PTR [bp-44],1	;loaderEntryInserted
;|*** 				}
;|*** 
;|*** 				if (bootLoaderEnd < entryEnd)
; Line 251
					$I1500:
	*** 000120	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;entryEnd
	*** 000123	50 			push	ax
	*** 000124	8d 46 d6 		lea	ax,WORD PTR [bp-42]	;bootLoaderEnd
	*** 000127	50 			push	ax
	*** 000128	e8 00 00 		call	??M@YADABTUINT64_STRUCT@@0@Z	; operator<
	*** 00012b	83 c4 04 		add	sp,4
	*** 00012e	0a c0 			or	al,al
	*** 000130	0f 84 92 00 		je	$I1507
;|*** 				{
;|*** 					// Create free entry above the boot loader area
;|*** 					if (newMapEntry >= mapEnd)
; Line 254
	*** 000134	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 000137	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 00013a	76 43 			jbe	SHORT $L1565
;|*** 						goto mapOverflow;
; Line 255
	*** 00013c	8b d8 			mov	bx,ax
	*** 00013e	66 c7 47 10 01 00 00 00 mov	DWORD PTR [bx+16],1
;|*** 
;|*** 					newMapEntry->Type = 0x1;
;|*** 					newMapEntry->BaseAddress = bootLoaderEnd;
; Line 258
	*** 000146	8b f8 			mov	di,ax
	*** 000148	8d 76 d6 		lea	si,WORD PTR [bp-42]	;bootLoaderEnd
	*** 00014b	1e 			push	ds
	*** 00014c	07 			pop	es
	*** 00014d	66 a5 			movsd
	*** 00014f	66 a5 			movsd
;|*** 					newMapEntry->Length = entryEnd - bootLoaderEnd;
; Line 259
	*** 000151	8d 46 d6 		lea	ax,WORD PTR [bp-42]	;bootLoaderEnd
	*** 000154	50 			push	ax
	*** 000155	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;entryEnd
	*** 000158	50 			push	ax
	*** 000159	8d 46 c2 		lea	ax,WORD PTR [bp-62]
	*** 00015c	50 			push	ax
	*** 00015d	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator-
	*** 000160	83 c4 06 		add	sp,6
	*** 000163	8b 5e ea 		mov	bx,WORD PTR [bp-22]	;newMapEntry
	*** 000166	8d 7f 08 		lea	di,WORD PTR [bx+8]
	*** 000169	8b f0 			mov	si,ax
	*** 00016b	1e 			push	ds
	*** 00016c	07 			pop	es
	*** 00016d	66 a5 			movsd
	*** 00016f	66 a5 			movsd
;|*** 					++newMapEntry;
; Line 260
	*** 000171	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 				}
;|*** 			}
;|*** 			else
; Line 263
	*** 000175	eb 4f 			jmp	SHORT $I1507
					$I1494:
;|*** 			{
;|*** 				if (newMapEntry >= mapEnd)
; Line 265
	*** 000177	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 00017a	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 00017d	77 03 			ja	SHORT $L1564
;|*** 					goto mapOverflow;
; Line 266
					$L1565:
	*** 00017f	e9 44 ff 		jmp	$mapOverflow1497
					$L1564:
	*** 000182	80 7e d4 00 		cmp	BYTE PTR [bp-44],0	;loaderEntryInserted
	*** 000186	75 27 			jne	SHORT $I1510
	*** 000188	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 00018b	50 			push	ax
	*** 00018c	8d 4e ec 		lea	cx,WORD PTR [bp-20]	;entry
	*** 00018f	51 			push	cx
	*** 000190	e8 00 00 		call	??O@YADABTUINT64_STRUCT@@0@Z	; operator>
	*** 000193	83 c4 04 		add	sp,4
	*** 000196	0a c0 			or	al,al
	*** 000198	74 15 			je	SHORT $I1510
;|*** 
;|*** 				if (!loaderEntryInserted && entry.BaseAddress > bootLoaderStart)
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
; Line 271
	*** 00019a	66 ff 76 e0 		push	DWORD PTR [bp-32]	;bootLoaderStart
	*** 00019e	ff 76 ea 		push	WORD PTR [bp-22]	;newMapEntry
	*** 0001a1	e8 00 00 		call	?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	; CreateBootLoaderMemoryMapEntry
	*** 0001a4	83 c4 06 		add	sp,6
;|*** 					++newMapEntry;
; Line 272
	*** 0001a7	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 					loaderEntryInserted = true;
; Line 273
	*** 0001ab	c6 46 d4 01 		mov	BYTE PTR [bp-44],1	;loaderEntryInserted
;|*** 				}
;|*** 
;|*** 				// Copy map entry
;|*** 				*newMapEntry++ = entry;
; Line 277
					$I1510:
	*** 0001af	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 0001b2	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
	*** 0001b6	89 46 c0 		mov	WORD PTR [bp-64],ax
	*** 0001b9	8d 76 ec 		lea	si,WORD PTR [bp-20]	;entry
	*** 0001bc	1e 			push	ds
	*** 0001bd	07 			pop	es
	*** 0001be	8b 7e c0 		mov	di,WORD PTR [bp-64]
	*** 0001c1	b9 0a 00 		mov	cx,10	;000aH
	*** 0001c4	f3 			rep
	*** 0001c5	a5 			movsw
;|*** 			}
; Line 278
					$I1507:
;|*** 
;|*** 		} while (GetNextBiosMemoryMapEntry (entry));
; Line 280
	*** 0001c6	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0001c9	50 			push	ax
	*** 0001ca	e8 00 00 		call	?GetNextBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z	; GetNextBiosMemoryMapEntry
	*** 0001cd	5b 			pop	bx
	*** 0001ce	0a c0 			or	al,al
	*** 0001d0	0f 85 86 fe 		jne	$D1488
;|*** 	}
;|*** 
;|*** 	BiosMemoryMapSize = newMapEntry - BiosMemoryMap;
; Line 283
					$I1487:
	*** 0001d4	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 0001d7	2d 00 00 		sub	ax,OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	;BiosMemoryMap
	*** 0001da	b9 14 00 		mov	cx,20	;0014H
	*** 0001dd	99 			cwd	
	*** 0001de	f7 f9 			idiv	cx
	*** 0001e0	a3 00 00 		mov	WORD PTR $S1472_BiosMemoryMapSize,ax
;|*** 	return true;
; Line 284
	*** 0001e3	b0 01 			mov	al,1
	*** 0001e5	eb 26 			jmp	SHORT $EX1479
;|*** 
;|*** mapOverflow:
; Line 286
					$FC1513:
;|*** 	size_t overSize = 0;
;|*** 	while (GetNextBiosMemoryMapEntry (entry))
;|*** 	{
;|*** 		++overSize;
; Line 290
	*** 0001e7	ff 46 d2 		inc	WORD PTR [bp-46]	;overSize
;|*** 	}
; Line 291
					$L1563:
	*** 0001ea	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0001ed	50 			push	ax
	*** 0001ee	e8 00 00 		call	?GetNextBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z	; GetNextBiosMemoryMapEntry
	*** 0001f1	5b 			pop	bx
	*** 0001f2	0a c0 			or	al,al
	*** 0001f4	75 f1 			jne	SHORT $FC1513
;|*** 
;|*** 	PrintErrorNoEndl ("MMP:");
; Line 293
	*** 0001f6	68 00 00 		push	OFFSET DGROUP:??_C@_04PLFG@MMP?3?$AA@
	*** 0001f9	e8 00 00 		call	?PrintErrorNoEndl@@YAXPBD@Z	; PrintErrorNoEndl
	*** 0001fc	5b 			pop	bx
;|*** 	Print (overSize);
; Line 294
	*** 0001fd	6a 00 			push	0
	*** 0001ff	ff 76 d2 		push	WORD PTR [bp-46]	;overSize
	*** 000202	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000205	83 c4 04 		add	sp,4
;|*** 	PrintEndl();
; Line 295
	*** 000208	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 	return false;
; Line 297
	*** 00020b	32 c0 			xor	al,al
;|*** }
; Line 298
					$EX1479:
	*** 00020d	5e 			pop	si
	*** 00020e	5f 			pop	di
	*** 00020f	c9 			leave	
	*** 000210	c3 			ret	

?CreateNewBiosMemoryMap@@YADXZ	ENDP
	PUBLIC	?Int15Filter@@YADXZ	; Int15Filter
?Int15Filter@@YADXZ	PROC NEAR	; Int15Filter COMDAT
;|*** 
;|*** 
;|*** bool Int15Filter ()
;|*** {
; Line 302
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;|*** 	CheckStack();
;|*** 
;|*** #ifdef TC_TRACE_INT15
;|*** 	DisableScreenOutput();
;|*** 
;|*** 	Print ("15-");
;|*** 	PrintHex (IntRegisters.AX);
;|*** 
;|*** 	Print (" SS:"); PrintHex (IntRegisters.SS);
;|*** 
;|*** 	uint16 spdbg;
;|*** 	__asm mov spdbg, sp
;|*** 	PrintChar (' ');
;|*** 	PrintHex (spdbg);
;|*** 	PrintChar ('<'); PrintHex (TC_BOOT_LOADER_STACK_TOP);
;|*** 
;|*** 	Print (" EAX:"); PrintHex (IntRegisters.EAX);
;|*** 	Print (" EBX:"); PrintHex (IntRegisters.EBX);
;|*** 	Print (" ECX:"); PrintHex (IntRegisters.ECX);
;|*** 	Print (" EDX:"); PrintHex (IntRegisters.EDX);
;|*** 	Print (" DI:"); PrintHex (IntRegisters.DI);
;|*** 	PrintEndl();
;|*** 
;|*** #endif
;|*** 
;|*** 	if (IntRegisters.EBX >= BiosMemoryMapSize)
; Line 328
	*** 000005	a1 00 00 		mov	ax,WORD PTR $S1472_BiosMemoryMapSize
	*** 000008	2b d2 			sub	dx,dx
	*** 00000a	3b 16 08 00 		cmp	dx,WORD PTR $S1424_IntRegisters+8
	*** 00000e	77 1c 			ja	SHORT $I1519
	*** 000010	72 06 			jb	SHORT $L1552
	*** 000012	3b 06 06 00 		cmp	ax,WORD PTR $S1424_IntRegisters+6
	*** 000016	77 14 			ja	SHORT $I1519
					$L1552:
;|*** 	{
;|*** 		IntRegisters.Flags |= TC_X86_CARRY_FLAG;
; Line 330
	*** 000018	80 0e 00 00 01 		or	BYTE PTR $S1424_IntRegisters,1
;|*** 		IntRegisters.EBX = 0;
; Line 331
	*** 00001d	66 2b c0 		sub	eax,eax
	*** 000020	66 a3 06 00 		mov	DWORD PTR $S1424_IntRegisters+6,eax
;|*** 		IntRegisters.AX = -1;
; Line 332
	*** 000024	c7 06 02 00 ff ff 	mov	WORD PTR $S1424_IntRegisters+2,-1	;ffffH
;|*** 	}
;|*** 	else
; Line 334
	*** 00002a	eb 52 			jmp	SHORT $I1520
					$I1519:
;|*** 	{
;|*** 		CopyMemory ((byte *) &BiosMemoryMap[IntRegisters.EBX], IntRegisters.ES, IntRegisters.DI, sizeof (BiosMemoryMap[0]));
; Line 336
	*** 00002c	6a 14 			push	20	;0014H
	*** 00002e	ff 36 12 00 		push	WORD PTR $S1424_IntRegisters+18
	*** 000032	ff 36 18 00 		push	WORD PTR $S1424_IntRegisters+24
	*** 000036	6b 06 06 00 14 		imul	ax,WORD PTR $S1424_IntRegisters+6,20	;0014H
	*** 00003b	05 00 00 		add	ax,OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	;BiosMemoryMap
	*** 00003e	50 			push	ax
	*** 00003f	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 000042	83 c4 08 		add	sp,8
;|*** 
;|*** 		IntRegisters.Flags &= ~TC_X86_CARRY_FLAG;
; Line 338
	*** 000045	80 26 00 00 fe 		and	BYTE PTR $S1424_IntRegisters,254	;00feH
;|*** 		IntRegisters.EAX = 0x534D4150UL;
; Line 339
	*** 00004a	66 c7 06 02 00 50 41 4d 53 mov	DWORD PTR $S1424_IntRegisters+2,1397571920	;534d4150H
;|*** 
;|*** 		++IntRegisters.EBX;
;|*** 		if (IntRegisters.EBX >= BiosMemoryMapSize)
; Line 342
	*** 000053	66 ff 06 06 00 		inc	DWORD PTR $S1424_IntRegisters+6
	*** 000058	a1 00 00 		mov	ax,WORD PTR $S1472_BiosMemoryMapSize
	*** 00005b	2b d2 			sub	dx,dx
	*** 00005d	3b 16 08 00 		cmp	dx,WORD PTR $S1424_IntRegisters+8
	*** 000061	77 11 			ja	SHORT $I1522
	*** 000063	72 06 			jb	SHORT $L1553
	*** 000065	3b 06 06 00 		cmp	ax,WORD PTR $S1424_IntRegisters+6
	*** 000069	77 09 			ja	SHORT $I1522
					$L1553:
;|*** 			IntRegisters.EBX = 0;
; Line 343
	*** 00006b	66 c7 06 06 00 00 00 00 00 mov	DWORD PTR $S1424_IntRegisters+6,0
;|*** 
;|*** 		IntRegisters.ECX = sizeof (BiosMemoryMap[0]);
; Line 345
					$I1522:
	*** 000074	c7 06 0a 00 14 00 	mov	WORD PTR $S1424_IntRegisters+10,20	;0014H
	*** 00007a	89 16 0c 00 		mov	WORD PTR $S1424_IntRegisters+12,dx
;|*** 	}
; Line 346
					$I1520:
;|*** 
;|*** 	if (IntRegisters.EBX == 0 && !(BootSectorFlags & TC_BOOT_CFG_FLAG_WINDOWS_VISTA_OR_LATER))
; Line 348
	*** 00007e	a1 08 00 		mov	ax,WORD PTR $S1424_IntRegisters+8
	*** 000081	0b 06 06 00 		or	ax,WORD PTR $S1424_IntRegisters+6
	*** 000085	75 2d 			jne	SHORT $I1526
	*** 000087	f6 06 00 00 04 		test	BYTE PTR ?BootSectorFlags@@3EA,4	;BootSectorFlags
	*** 00008c	75 26 			jne	SHORT $I1526
;|*** 	{
;|*** 		// Uninstall filter when the modified map has been issued three times to prevent
;|*** 		// problems with hardware drivers on some notebooks running Windows XP.
;|*** 
;|*** 		static int CompleteMapIssueCount = 0;
;|*** 		if (++CompleteMapIssueCount >= 3)
; Line 354
	*** 00008e	ff 06 00 00 		inc	WORD PTR $S1525_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA
	*** 000092	83 3e 00 00 03 		cmp	WORD PTR $S1525_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA,3
	*** 000097	7c 1b 			jl	SHORT $I1526
;|*** 		{
;|*** 			__asm
;|*** 			{
;|*** 				cli
; Line 358
	*** 000099	fa 			cli	
;|*** 				push es
; Line 359
	*** 00009a	06 			push	es
;|*** 
;|*** 				lea si, OriginalInt15Handler
; Line 361
	*** 00009b	8d 36 00 00 		lea	si,WORD PTR $S1423_OriginalInt15Handler
;|*** 				xor ax, ax
; Line 362
	*** 00009f	33 c0 			xor	ax,ax
;|*** 				mov es, ax
; Line 363
	*** 0000a1	8e c0 			mov	es,ax
;|*** 				mov di, 0x15 * 4
; Line 364
	*** 0000a3	bf 54 00 		mov	di,84	;0054H
;|*** 
;|*** 				mov ax, [si]
; Line 366
	*** 0000a6	8b 04 			mov	ax,WORD PTR [si]
;|*** 				mov es:[di], ax
; Line 367
	*** 0000a8	26 89 05 		mov	WORD PTR es:[di],ax
;|*** 				mov ax, [si + 2]
; Line 368
	*** 0000ab	8b 44 02 		mov	ax,WORD PTR [si+2]
;|*** 				mov es:[di + 2], ax
; Line 369
	*** 0000ae	26 89 45 02 		mov	WORD PTR es:[di+2],ax
;|*** 
;|*** 				pop es
; Line 371
	*** 0000b2	07 			pop	es
;|*** 				sti
; Line 372
	*** 0000b3	fb 			sti	
;|*** 			}
; Line 373
;|*** 		}
;|*** 	}
; Line 375
					$I1526:
;|*** 
;|*** #ifdef TC_TRACE_INT15
;|*** 	BiosMemoryMapEntry entry;
;|*** 	CopyMemory (IntRegisters.ES, IntRegisters.DI, (byte *) &entry, sizeof (entry));
;|*** 	PrintHex (entry.Type); PrintChar (' ');
;|*** 	PrintHex (entry.BaseAddress); PrintChar (' ');
;|*** 	PrintHex (entry.Length); PrintChar (' ');
;|*** 	PrintHex (entry.BaseAddress + entry.Length); PrintEndl();
;|*** 
;|*** 	Print ("EAX:"); PrintHex (IntRegisters.EAX);
;|*** 	Print (" EBX:"); PrintHex (IntRegisters.EBX);
;|*** 	Print (" ECX:"); PrintHex (IntRegisters.ECX);
;|*** 	Print (" EDX:"); PrintHex (IntRegisters.EDX);
;|*** 	Print (" DI:"); PrintHex (IntRegisters.DI);
;|*** 	Print (" FL:"); PrintHex (IntRegisters.Flags);
;|*** 	PrintEndl (2);
;|*** #endif
;|*** 
;|*** #ifdef TC_TRACE_INT15
;|*** 	EnableScreenOutput();
;|*** #endif
;|*** 	return false;
; Line 397
	*** 0000b4	32 c0 			xor	al,al
;|*** }
; Line 398
	*** 0000b6	5e 			pop	si
	*** 0000b7	5f 			pop	di
	*** 0000b8	c9 			leave	
	*** 0000b9	c3 			ret	

?Int15Filter@@YADXZ	ENDP
	PUBLIC	?IntFilterEntry@@YAXXZ	; IntFilterEntry
?IntFilterEntry@@YAXXZ	PROC NEAR	; IntFilterEntry COMDAT
;|*** 
;|*** 
;|*** void IntFilterEntry ()
;|*** {
; Line 402
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;|*** 	// No automatic variables should be used in this scope as SS may change
;|*** 	static uint16 OrigStackPointer;
;|*** 	static uint16 OrigStackSegment;
;|*** 
;|*** 	__asm
;|*** 	{
;|*** 		pushf
; Line 409
	*** 000005	9c 			pushf	
;|*** 		pushad
; Line 410
	*** 000006	66 60 			pushad
;|*** 
;|*** 		cli
; Line 412
	*** 000008	fa 			cli	
;|*** 		mov cs:IntRegisters.DI, di
; Line 413
	*** 000009	2e 89 3e 12 00 		mov	WORD PTR cs:$S1424_IntRegisters+18,di
;|*** 
;|*** 		lea di, cs:IntRegisters.EAX
; Line 415
	*** 00000e	2e 8d 3e 02 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+2
;|*** 		TC_ASM_EMIT4 (66,2E,89,05) // mov [cs:di], eax
; Line 416
	*** 000013	66 			DB	102	;0066H
	*** 000014	2e 			DB	46	;002eH
	*** 000015	89 			DB	137	;0089H
	*** 000016	05 			DB	5
;|*** 		lea di, cs:IntRegisters.EBX
; Line 417
	*** 000017	2e 8d 3e 06 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+6
;|*** 		TC_ASM_EMIT4 (66,2E,89,1D) // mov [cs:di], ebx
; Line 418
	*** 00001c	66 			DB	102	;0066H
	*** 00001d	2e 			DB	46	;002eH
	*** 00001e	89 			DB	137	;0089H
	*** 00001f	1d 			DB	29	;001dH
;|*** 		lea di, cs:IntRegisters.ECX
; Line 419
	*** 000020	2e 8d 3e 0a 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+10
;|*** 		TC_ASM_EMIT4 (66,2E,89,0D) // mov [cs:di], ecx
; Line 420
	*** 000025	66 			DB	102	;0066H
	*** 000026	2e 			DB	46	;002eH
	*** 000027	89 			DB	137	;0089H
	*** 000028	0d 			DB	13	;000dH
;|*** 		lea di, cs:IntRegisters.EDX
; Line 421
	*** 000029	2e 8d 3e 0e 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+14
;|*** 		TC_ASM_EMIT4 (66,2E,89,15) // mov [cs:di], edx
; Line 422
	*** 00002e	66 			DB	102	;0066H
	*** 00002f	2e 			DB	46	;002eH
	*** 000030	89 			DB	137	;0089H
	*** 000031	15 			DB	21	;0015H
;|*** 
;|*** 		mov ax, [bp + 8]
; Line 424
	*** 000032	8b 46 08 		mov	ax,WORD PTR [bp+8]
;|*** 		mov cs:IntRegisters.Flags, ax
; Line 425
	*** 000035	2e a3 00 00 		mov	WORD PTR cs:$S1424_IntRegisters,ax
;|*** 
;|*** 		mov cs:IntRegisters.SI, si
; Line 427
	*** 000039	2e 89 36 14 00 		mov	WORD PTR cs:$S1424_IntRegisters+20,si
;|*** 		mov si, [bp + 2] // Int number
; Line 428
	*** 00003e	8b 76 02 		mov	si,WORD PTR [bp+2]
;|*** 
;|*** 		mov cs:IntRegisters.DS, ds
; Line 430
	*** 000041	2e 8c 1e 16 00 		mov	WORD PTR cs:$S1424_IntRegisters+22,ds
;|*** 		mov cs:IntRegisters.ES, es
; Line 431
	*** 000046	2e 8c 06 18 00 		mov	WORD PTR cs:$S1424_IntRegisters+24,es
;|*** 		mov cs:IntRegisters.SS, ss
; Line 432
	*** 00004b	2e 8c 16 1a 00 		mov	WORD PTR cs:$S1424_IntRegisters+26,ss
;|*** 
;|*** 		// Compiler assumes SS == DS - use our stack if this condition is not met
;|*** 		mov ax, ss
; Line 435
	*** 000050	8c d0 			mov	ax,ss
;|*** 		mov bx, cs
; Line 436
	*** 000052	8c cb 			mov	bx,cs
;|*** 		cmp ax, bx
; Line 437
	*** 000054	3b c3 			cmp	ax,bx
;|*** 		jz stack_ok
; Line 438
	*** 000056	74 11 			je	SHORT $stack_ok1534
;|*** 
;|*** 		mov cs:OrigStackPointer, sp
; Line 440
	*** 000058	2e 89 26 00 00 		mov	WORD PTR cs:$S1531_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA,sp
;|*** 		mov cs:OrigStackSegment, ss
; Line 441
	*** 00005d	2e 8c 16 00 00 		mov	WORD PTR cs:$S1533_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA,ss
;|*** 		mov ax, cs
; Line 442
	*** 000062	8c c8 			mov	ax,cs
;|*** 		mov ss, ax
; Line 443
	*** 000064	8e d0 			mov	ss,ax
;|*** 		mov sp, TC_BOOT_LOADER_STACK_TOP
; Line 444
	*** 000066	bc fc a7 		mov	sp,-22532	;a7fcH
;|*** 
;|*** 	stack_ok:
; Line 446
					$stack_ok1534:
;|*** 		// DS = CS
;|*** 		push ds
; Line 448
	*** 000069	1e 			push	ds
;|*** 		push es
; Line 449
	*** 00006a	06 			push	es
;|*** 		mov ax, cs
; Line 450
	*** 00006b	8c c8 			mov	ax,cs
;|*** 		mov ds, ax
; Line 451
	*** 00006d	8e d8 			mov	ds,ax
;|*** 		mov es, ax
; Line 452
	*** 00006f	8e c0 			mov	es,ax
;|*** 
;|*** 		push si // Int number
; Line 454
	*** 000071	56 			push	si
;|*** 
;|*** 		// Filter request
;|*** 		cmp si, 0x15
; Line 457
	*** 000072	83 fe 15 		cmp	si,21	;0015H
;|*** 		je filter15
; Line 458
	*** 000075	74 0b 			je	SHORT $filter151535
;|*** 		cmp si, 0x13
; Line 459
	*** 000077	83 fe 13 		cmp	si,19	;0013H
;|*** 		jne $
; Line 460
	*** 00007a	75 fe 			jne	SHORT $+0
;|*** 
;|*** 		call Int13Filter
; Line 462
	*** 00007c	e8 00 00 		call	?Int13Filter@@YADXZ	;Int13Filter
;|*** 		jmp s0
; Line 463
	*** 00007f	e9 03 00 		jmp	$s01536
;|*** 
;|*** 	filter15:
; Line 465
					$filter151535:
;|*** 		call Int15Filter
; Line 466
	*** 000082	e8 00 00 		call	?Int15Filter@@YADXZ	;Int15Filter
;|*** 
;|*** 	s0:
; Line 468
					$s01536:
;|*** 		pop si // Int number
; Line 469
	*** 000085	5e 			pop	si
;|*** 		pop es
; Line 470
	*** 000086	07 			pop	es
;|*** 		pop ds
; Line 471
	*** 000087	1f 			pop	ds
;|*** 
;|*** 		// Restore original SS:SP if our stack is empty
;|*** 		cli
; Line 474
	*** 000088	fa 			cli	
;|*** 		mov bx, TC_BOOT_LOADER_STACK_TOP
; Line 475
	*** 000089	bb fc a7 		mov	bx,-22532	;a7fcH
;|*** 		cmp bx, sp
; Line 476
	*** 00008c	3b dc 			cmp	bx,sp
;|*** 		jnz stack_in_use
; Line 477
	*** 00008e	75 0a 			jne	SHORT $stack_in_use1537
;|*** 
;|*** 		mov ss, cs:OrigStackSegment
; Line 479
	*** 000090	2e 8e 16 00 00 		mov	ss,WORD PTR cs:$S1533_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA
;|*** 		mov sp, cs:OrigStackPointer
; Line 480
	*** 000095	2e 8b 26 00 00 		mov	sp,WORD PTR cs:$S1531_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA
;|*** 	stack_in_use:
; Line 481
					$stack_in_use1537:
;|*** 
;|*** 		test ax, ax // passOriginalRequest
; Line 483
	*** 00009a	85 c0 			test	ax,ax
;|*** 		jnz pass_request
; Line 484
	*** 00009c	75 48 			jne	SHORT $pass_request1538
;|*** 
;|*** 		// Return results of filtered request
;|*** 		popad
; Line 487
	*** 00009e	66 61 			popad
;|*** 		popf
; Line 488
	*** 0000a0	9d 			popf	
;|*** 		mov ax, cs:IntRegisters.Flags
; Line 489
	*** 0000a1	2e a1 00 00 		mov	ax,WORD PTR cs:$S1424_IntRegisters
;|*** 		mov [bp + 8], ax
; Line 490
	*** 0000a5	89 46 08 		mov	WORD PTR [bp+8],ax
;|*** 		leave
; Line 491
	*** 0000a8	c9 			leave	
;|*** 
;|*** 		lea di, cs:IntRegisters.EAX
; Line 493
	*** 0000a9	2e 8d 3e 02 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+2
;|*** 		TC_ASM_EMIT4 (66,2E,8B,05) // mov eax, [cs:di]
; Line 494
	*** 0000ae	66 			DB	102	;0066H
	*** 0000af	2e 			DB	46	;002eH
	*** 0000b0	8b 			DB	139	;008bH
	*** 0000b1	05 			DB	5
;|*** 		lea di, cs:IntRegisters.EBX
; Line 495
	*** 0000b2	2e 8d 3e 06 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+6
;|*** 		TC_ASM_EMIT4 (66,2E,8B,1D) // mov ebx, [cs:di]
; Line 496
	*** 0000b7	66 			DB	102	;0066H
	*** 0000b8	2e 			DB	46	;002eH
	*** 0000b9	8b 			DB	139	;008bH
	*** 0000ba	1d 			DB	29	;001dH
;|*** 		lea di, cs:IntRegisters.ECX
; Line 497
	*** 0000bb	2e 8d 3e 0a 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+10
;|*** 		TC_ASM_EMIT4 (66,2E,8B,0D) // mov ecx, [cs:di]
; Line 498
	*** 0000c0	66 			DB	102	;0066H
	*** 0000c1	2e 			DB	46	;002eH
	*** 0000c2	8b 			DB	139	;008bH
	*** 0000c3	0d 			DB	13	;000dH
;|*** 		lea di, cs:IntRegisters.EDX
; Line 499
	*** 0000c4	2e 8d 3e 0e 00 		lea	di,WORD PTR cs:$S1424_IntRegisters+14
;|*** 		TC_ASM_EMIT4 (66,2E,8B,15) // mov edx, [cs:di]
; Line 500
	*** 0000c9	66 			DB	102	;0066H
	*** 0000ca	2e 			DB	46	;002eH
	*** 0000cb	8b 			DB	139	;008bH
	*** 0000cc	15 			DB	21	;0015H
;|*** 
;|*** 		mov di, cs:IntRegisters.DI
; Line 502
	*** 0000cd	2e 8b 3e 12 00 		mov	di,WORD PTR cs:$S1424_IntRegisters+18
;|*** 		mov si, cs:IntRegisters.SI
; Line 503
	*** 0000d2	2e 8b 36 14 00 		mov	si,WORD PTR cs:$S1424_IntRegisters+20
;|*** 		mov es, cs:IntRegisters.ES
; Line 504
	*** 0000d7	2e 8e 06 18 00 		mov	es,WORD PTR cs:$S1424_IntRegisters+24
;|*** 		mov ds, cs:IntRegisters.DS
; Line 505
	*** 0000dc	2e 8e 1e 16 00 		mov	ds,WORD PTR cs:$S1424_IntRegisters+22
;|*** 
;|*** 		sti
; Line 507
	*** 0000e1	fb 			sti	
;|*** 		add sp, 2
; Line 508
	*** 0000e2	83 c4 02 		add	sp,2
;|*** 		iret
; Line 509
	*** 0000e5	cf 			iret	
;|*** 
;|*** 		// Pass original request
;|*** 	pass_request:
; Line 512
					$pass_request1538:
;|*** 		sti
; Line 513
	*** 0000e6	fb 			sti	
;|*** 		cmp si, 0x15
; Line 514
	*** 0000e7	83 fe 15 		cmp	si,21	;0015H
;|*** 		je pass15
; Line 515
	*** 0000ea	74 11 			je	SHORT $pass151539
;|*** 		cmp si, 0x13
; Line 516
	*** 0000ec	83 fe 13 		cmp	si,19	;0013H
;|*** 		jne $
; Line 517
	*** 0000ef	75 fe 			jne	SHORT $+0
;|*** 
;|*** 		popad
; Line 519
	*** 0000f1	66 61 			popad
;|*** 		popf
; Line 520
	*** 0000f3	9d 			popf	
;|*** 		leave
; Line 521
	*** 0000f4	c9 			leave	
;|*** 		add sp, 2
; Line 522
	*** 0000f5	83 c4 02 		add	sp,2
;|*** 		jmp cs:OriginalInt13Handler	
; Line 523
	*** 0000f8	2e ff 2e 00 00 		jmp	WORD PTR cs:$S1422_OriginalInt13Handler
;|*** 
;|*** 	pass15:
; Line 525
					$pass151539:
;|*** 		popad
; Line 526
	*** 0000fd	66 61 			popad
;|*** 		popf
; Line 527
	*** 0000ff	9d 			popf	
;|*** 		leave
; Line 528
	*** 000100	c9 			leave	
;|*** 		add sp, 2
; Line 529
	*** 000101	83 c4 02 		add	sp,2
;|*** 		jmp cs:OriginalInt15Handler
; Line 530
	*** 000104	2e ff 2e 00 00 		jmp	WORD PTR cs:$S1423_OriginalInt15Handler
;|*** 	}
; Line 531
;|*** }
; Line 532
	*** 000109	eb 00 			jmp	SHORT $EX1529
					$EX1529:
	*** 00010b	5e 			pop	si
	*** 00010c	5f 			pop	di
	*** 00010d	c9 			leave	
	*** 00010e	c3 			ret	

?IntFilterEntry@@YAXXZ	ENDP
	PUBLIC	?Int13FilterEntry@@YAXXZ	; Int13FilterEntry
?Int13FilterEntry@@YAXXZ	PROC NEAR	; Int13FilterEntry COMDAT
;|*** 
;|*** 
;|*** void Int13FilterEntry ()
;|*** {
; Line 536
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;|*** 	__asm
;|*** 	{
;|*** 		leave
; Line 539
	*** 000003	c9 			leave	
;|*** 		push 0x13
; Line 540
	*** 000004	6a 13 			push	19	;0013H
;|*** 		jmp IntFilterEntry
; Line 541
	*** 000006	e9 00 00 		jmp	?IntFilterEntry@@YAXXZ	;IntFilterEntry
;|*** 	}
; Line 542
;|*** }
; Line 543
	*** 000009	c9 			leave	
	*** 00000a	c3 			ret	

?Int13FilterEntry@@YAXXZ	ENDP

?Int15FilterEntry@@YAXXZ	PROC NEAR	; Int15FilterEntry COMDAT
;|*** 
;|*** 
;|*** static void Int15FilterEntry ()
;|*** {
; Line 547
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;|*** 	__asm
;|*** 	{
;|*** 		pushf
; Line 550
	*** 000003	9c 			pushf	
;|*** 		cmp ax, 0xe820 // Get system memory map
; Line 551
	*** 000004	3d 20 e8 		cmp	ax,-6112	;e820H
;|*** 		je filter
; Line 552
	*** 000007	74 07 			je	SHORT $filter1546
;|*** 		
;|*** 		popf
; Line 554
	*** 000009	9d 			popf	
;|*** 		leave
; Line 555
	*** 00000a	c9 			leave	
;|*** 		jmp cs:OriginalInt15Handler
; Line 556
	*** 00000b	2e ff 2e 00 00 		jmp	WORD PTR cs:$S1423_OriginalInt15Handler
;|*** 
;|*** 	filter:
; Line 558
					$filter1546:
;|*** 		leave
; Line 559
	*** 000010	c9 			leave	
;|*** 		push 0x15
; Line 560
	*** 000011	6a 15 			push	21	;0015H
;|*** 		jmp IntFilterEntry
; Line 561
	*** 000013	e9 00 00 		jmp	?IntFilterEntry@@YAXXZ	;IntFilterEntry
;|*** 	}
; Line 562
;|*** }
; Line 563
	*** 000016	c9 			leave	
	*** 000017	c3 			ret	

?Int15FilterEntry@@YAXXZ	ENDP
	PUBLIC	?InstallInterruptFilters@@YADXZ	; InstallInterruptFilters
?InstallInterruptFilters@@YADXZ	PROC NEAR	; InstallInterruptFilters COMDAT
;|*** 
;|*** 
;|*** bool InstallInterruptFilters ()
;|*** {
; Line 567
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;|*** 
;|*** #ifndef TC_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	// If the filters have already been installed, it usually indicates stack corruption
;|*** 	// and a consequent reentry of this routine without a system reset.
;|*** 
;|*** 	uint32 currentInt13Handler;
;|*** 	CopyMemory (0, 0x13 * 4, &currentInt13Handler, sizeof (currentInt13Handler));
;|*** 
;|*** 	if (currentInt13Handler == (uint32) Int13FilterEntry)
;|*** 	{
;|*** 		PrintError ("Memory corrupted");
;|*** 		Print (TC_BOOT_STR_UPGRADE_BIOS);
;|*** 
;|*** 		GetKeyboardChar();
;|*** 		return true;
;|*** 	}
;|*** 
;|*** #endif
;|*** 
;|*** 	if (!CreateNewBiosMemoryMap())
; Line 588
	*** 000005	e8 00 00 		call	?CreateNewBiosMemoryMap@@YADXZ	; CreateNewBiosMemoryMap
	*** 000008	0a c0 			or	al,al
	*** 00000a	74 57 			je	SHORT $EX1548
;|*** 		return false;
;|*** 
;|*** 	__asm
;|*** 	{
;|*** 		cli
; Line 593
	*** 00000c	fa 			cli	
;|*** 		push es
; Line 594
	*** 00000d	06 			push	es
;|*** 
;|*** 		// Save original INT 13 handler
;|*** 		xor ax, ax
; Line 597
	*** 00000e	33 c0 			xor	ax,ax
;|*** 		mov es, ax
; Line 598
	*** 000010	8e c0 			mov	es,ax
;|*** 		
;|*** 		mov si, 0x13 * 4
; Line 600
	*** 000012	be 4c 00 		mov	si,76	;004cH
;|*** 		lea di, OriginalInt13Handler
; Line 601
	*** 000015	8d 3e 00 00 		lea	di,WORD PTR $S1422_OriginalInt13Handler
;|*** 
;|*** 		mov ax, es:[si]
; Line 603
	*** 000019	26 8b 04 		mov	ax,WORD PTR es:[si]
;|*** 		mov [di], ax
; Line 604
	*** 00001c	89 05 			mov	WORD PTR [di],ax
;|*** 		mov ax, es:[si + 2]
; Line 605
	*** 00001e	26 8b 44 02 		mov	ax,WORD PTR es:[si+2]
;|*** 		mov [di + 2], ax
; Line 606
	*** 000022	89 45 02 		mov	WORD PTR [di+2],ax
;|*** 		
;|*** 		// Install INT 13 filter
;|*** 		lea ax, Int13FilterEntry
; Line 609
	*** 000025	8d 06 00 00 		lea	ax,WORD PTR ?Int13FilterEntry@@YAXXZ	;Int13FilterEntry
;|*** 		mov es:[si], ax
; Line 610
	*** 000029	26 89 04 		mov	WORD PTR es:[si],ax
;|*** 		mov es:[si + 2], cs
; Line 611
	*** 00002c	26 8c 4c 02 		mov	WORD PTR es:[si+2],cs
;|*** 
;|*** 		// Save original INT 15 handler
;|*** 		mov si, 0x15 * 4	
; Line 614
	*** 000030	be 54 00 		mov	si,84	;0054H
;|*** 		lea di, OriginalInt15Handler
; Line 615
	*** 000033	8d 3e 00 00 		lea	di,WORD PTR $S1423_OriginalInt15Handler
;|*** 
;|*** 		mov ax, es:[si]
; Line 617
	*** 000037	26 8b 04 		mov	ax,WORD PTR es:[si]
;|*** 		mov [di], ax
; Line 618
	*** 00003a	89 05 			mov	WORD PTR [di],ax
;|*** 		mov ax, es:[si + 2]
; Line 619
	*** 00003c	26 8b 44 02 		mov	ax,WORD PTR es:[si+2]
;|*** 		mov [di + 2], ax
; Line 620
	*** 000040	89 45 02 		mov	WORD PTR [di+2],ax
;|*** 
;|*** 		// Install INT 15 filter
;|*** 		lea ax, Int15FilterEntry
; Line 623
	*** 000043	8d 06 00 00 		lea	ax,WORD PTR ?Int15FilterEntry@@YAXXZ	;Int15FilterEntry
;|*** 		mov es:[si], ax
; Line 624
	*** 000047	26 89 04 		mov	WORD PTR es:[si],ax
;|*** 		mov es:[si + 2], cs
; Line 625
	*** 00004a	26 8c 4c 02 		mov	WORD PTR es:[si+2],cs
;|*** 
;|*** 		// If the BIOS does not support system memory map (INT15 0xe820),
;|*** 		// set amount of available memory to CS:0000 - 0:0000
;|*** 		cmp BiosMemoryMapSize, 1
; Line 629
	*** 00004e	83 3e 00 00 01 		cmp	WORD PTR $S1472_BiosMemoryMapSize,1
;|*** 		jg mem_map_ok
; Line 630
	*** 000053	7f 0a 			jg	SHORT $mem_map_ok1550
;|*** 		mov ax, cs
; Line 631
	*** 000055	8c c8 			mov	ax,cs
;|*** 		shr ax, 10 - 4		// CS * 16 / 1024
; Line 632
	*** 000057	c1 e8 06 		shr	ax,6
;|*** 		mov es:[0x413], ax	// = KBytes available
; Line 633
	*** 00005a	26 89 06 13 04 		mov	WORD PTR es:1043,ax
;|*** 	mem_map_ok:
; Line 634
					$mem_map_ok1550:
;|*** 
;|*** 		pop es
; Line 636
	*** 00005f	07 			pop	es
;|*** 		sti
; Line 637
	*** 000060	fb 			sti	
;|*** 	}
; Line 638
;|*** 
;|*** 	return true;
; Line 640
	*** 000061	b0 01 			mov	al,1
;|*** }
; Line 641
					$EX1548:
	*** 000063	5e 			pop	si
	*** 000064	5f 			pop	di
	*** 000065	c9 			leave	
	*** 000066	c3 			ret	

?InstallInterruptFilters@@YADXZ	ENDP
_TEXT	ENDS
END
