; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Random.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?hCryptProv@@3KA				; hCryptProv
PUBLIC	?critRandProt@@3U_RTL_CRITICAL_SECTION@@A	; critRandProt
PUBLIC	_bFastPollEnabled
PUBLIC	_bRandmixEnabled
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?hMouse@@3PAUHHOOK__@@A				; hMouse
PUBLIC	?hKeyboard@@3PAUHHOOK__@@A			; hKeyboard
PUBLIC	?bThreadTerminate@@3HC				; bThreadTerminate
PUBLIC	?hNetAPI32@@3PAUHINSTANCE__@@A			; hNetAPI32
PUBLIC	?CryptoAPIAvailable@@3HA			; CryptoAPIAvailable
PUBLIC	?pNetStatisticsGet@@3P6GKPA_W0KKPAPAE@ZA	; pNetStatisticsGet
PUBLIC	?pNetApiBufferSize@@3P6GKPAXPAK@ZA		; pNetApiBufferSize
PUBLIC	?pNetApiBufferFree@@3P6GKPAX@ZA			; pNetApiBufferFree
_BSS	SEGMENT
?hCryptProv@@3KA DD 01H DUP (?)				; hCryptProv
?critRandProt@@3U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?) ; critRandProt
_pRandPool DD	01H DUP (?)
_bRandDidInit DD 01H DUP (?)
_nRandIndex DD	01H DUP (?)
_randPoolReadIndex DD 01H DUP (?)
_bDidSlowPoll DD 01H DUP (?)
_RandomPoolEnrichedByUser DD 01H DUP (?)
_PeriodicFastPollThreadHandle DD 01H DUP (?)
?hMouse@@3PAUHHOOK__@@A DD 01H DUP (?)			; hMouse
?hKeyboard@@3PAUHHOOK__@@A DD 01H DUP (?)		; hKeyboard
?bThreadTerminate@@3HC DD 01H DUP (?)			; bThreadTerminate
?hNetAPI32@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; hNetAPI32
?CryptoAPIAvailable@@3HA DD 01H DUP (?)			; CryptoAPIAvailable
?pNetStatisticsGet@@3P6GKPA_W0KKPAPAE@ZA DD 01H DUP (?)	; pNetStatisticsGet
?pNetApiBufferSize@@3P6GKPAXPAK@ZA DD 01H DUP (?)	; pNetApiBufferSize
?pNetApiBufferFree@@3P6GKPAX@ZA DD 01H DUP (?)		; pNetApiBufferFree
_BSS	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_HashFunction DD 01H
_bFastPollEnabled DD 01H
_bRandmixEnabled DD 01H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@ECNDHJLG@?$AAN?$AAE?$AAT?$AAA?$AAP?$AAI?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	?LoadDLL_NETAPI32@@YAPAUHINSTANCE__@@XZ		; LoadDLL_NETAPI32
EXTRN	?LoadDLL@@YAPAUHINSTANCE__@@PA_WI@Z:PROC	; LoadDLL
;	COMDAT ??_C@_1BK@ECNDHJLG@?$AAN?$AAE?$AAT?$AAA?$AAP?$AAI?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@
; File c:\users\public\desktop\projects\ciphershed\src\common\util\dll.h
CONST	SEGMENT
??_C@_1BK@ECNDHJLG@?$AAN?$AAE?$AAT?$AAA?$AAP?$AAI?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@ DB 'N'
	DB	00H, 'E', 00H, 'T', 00H, 'A', 00H, 'P', 00H, 'I', 00H, '3', 00H
	DB	'2', 00H, '.', 00H, 'D', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?LoadDLL_NETAPI32@@YAPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?LoadDLL_NETAPI32@@YAPAUHINSTANCE__@@XZ PROC		; LoadDLL_NETAPI32, COMDAT

; 80   : 	#define dll L"NETAPI32.DLL"
; 81   : 	return LoadDLL((const LPWSTR)dll,(UINT)ARRAYSIZE(dll));

  00000	6a 0d		 push	 13			; 0000000dH
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@ECNDHJLG@?$AAN?$AAE?$AAT?$AAA?$AAP?$AAI?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@
  00007	e8 00 00 00 00	 call	 ?LoadDLL@@YAPAUHINSTANCE__@@PA_WI@Z ; LoadDLL
  0000c	83 c4 08	 add	 esp, 8

; 82   : 	#undef dll
; 83   : }

  0000f	c3		 ret	 0
?LoadDLL_NETAPI32@@YAPAUHINSTANCE__@@XZ ENDP		; LoadDLL_NETAPI32
_TEXT	ENDS
PUBLIC	_RandStop
EXTRN	_free:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__CryptReleaseContext@8:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__UnhookWindowsHookEx@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\random.cpp
;	COMDAT _RandStop
_TEXT	SEGMENT
_freePool$ = 8						; size = 4
_RandStop PROC						; COMDAT

; 123  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 124  : 	if (!bRandDidInit && freePool && pRandPool)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _freePool$[esp+4]
  00006	33 db		 xor	 ebx, ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	39 1d 00 00 00
	00		 cmp	 DWORD PTR _bRandDidInit, ebx
  00010	75 1b		 jne	 SHORT $LN27@RandStop
  00012	3b eb		 cmp	 ebp, ebx
  00014	0f 84 fd 00 00
	00		 je	 $LN6@RandStop
  0001a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _pRandPool
  00020	3b fb		 cmp	 edi, ebx
  00022	0f 85 af 00 00
	00		 jne	 $freePool$81329
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	5b		 pop	 ebx

; 174  : 		}
; 175  : 	}
; 176  : }

  0002c	c3		 ret	 0
$LN27@RandStop:

; 125  : 		goto freePool;
; 126  : 
; 127  : 	if (bRandDidInit == FALSE)
; 128  : 		return;
; 129  : 
; 130  : 	EnterCriticalSection (&critRandProt);

  0002d	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 131  : 
; 132  : 	if (hMouse != 0)

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMouse@@3PAUHHOOK__@@A ; hMouse
  0003d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnhookWindowsHookEx@4
  00043	3b c3		 cmp	 eax, ebx
  00045	74 03		 je	 SHORT $LN12@RandStop

; 133  : 		UnhookWindowsHookEx (hMouse);

  00047	50		 push	 eax
  00048	ff d6		 call	 esi
$LN12@RandStop:

; 134  : 	if (hKeyboard != 0)

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hKeyboard@@3PAUHHOOK__@@A ; hKeyboard
  0004f	3b c3		 cmp	 eax, ebx
  00051	74 03		 je	 SHORT $LN11@RandStop

; 135  : 		UnhookWindowsHookEx (hKeyboard);

  00053	50		 push	 eax
  00054	ff d6		 call	 esi
$LN11@RandStop:

; 136  : 
; 137  : 	bThreadTerminate = TRUE;
; 138  : 
; 139  : 	LeaveCriticalSection (&critRandProt);

  00056	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bThreadTerminate@@3HC, 1 ; bThreadTerminate
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 140  : 
; 141  : 	if (PeriodicFastPollThreadHandle)

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _PeriodicFastPollThreadHandle
  00070	3b c3		 cmp	 eax, ebx
  00072	74 09		 je	 SHORT $LN10@RandStop

; 142  : 		WaitForSingleObject (PeriodicFastPollThreadHandle, INFINITE);

  00074	6a ff		 push	 -1
  00076	50		 push	 eax
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN10@RandStop:

; 143  : 
; 144  : 	if (hNetAPI32 != 0)

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A ; hNetAPI32
  00082	3b c3		 cmp	 eax, ebx
  00084	74 0d		 je	 SHORT $LN9@RandStop

; 145  : 	{
; 146  : 		FreeLibrary (hNetAPI32);

  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 147  : 		hNetAPI32 = NULL;

  0008d	89 1d 00 00 00
	00		 mov	 DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A, ebx ; hNetAPI32
$LN9@RandStop:

; 148  : 	}
; 149  : 
; 150  : 	if (CryptoAPIAvailable)

  00093	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?CryptoAPIAvailable@@3HA, ebx ; CryptoAPIAvailable
  00099	74 13		 je	 SHORT $LN8@RandStop

; 151  : 	{
; 152  : 		CryptReleaseContext (hCryptProv, 0);

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCryptProv@@3KA ; hCryptProv
  000a0	53		 push	 ebx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8

; 153  : 		CryptoAPIAvailable = FALSE;

  000a8	89 1d 00 00 00
	00		 mov	 DWORD PTR ?CryptoAPIAvailable@@3HA, ebx ; CryptoAPIAvailable
$LN8@RandStop:

; 154  : 	}
; 155  : 
; 156  : 	hMouse = NULL;

  000ae	89 1d 00 00 00
	00		 mov	 DWORD PTR ?hMouse@@3PAUHHOOK__@@A, ebx ; hMouse

; 157  : 	hKeyboard = NULL;

  000b4	89 1d 00 00 00
	00		 mov	 DWORD PTR ?hKeyboard@@3PAUHHOOK__@@A, ebx ; hKeyboard

; 158  : 	bThreadTerminate = FALSE;
; 159  : 	DeleteCriticalSection (&critRandProt);

  000ba	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  000bf	89 1d 00 00 00
	00		 mov	 DWORD PTR ?bThreadTerminate@@3HC, ebx ; bThreadTerminate
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 160  : 
; 161  : 	bRandDidInit = FALSE;

  000cb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _pRandPool
  000d1	89 1d 00 00 00
	00		 mov	 DWORD PTR _bRandDidInit, ebx
$freePool$81329:

; 162  : 
; 163  : freePool:
; 164  : 	if (freePool)

  000d7	3b eb		 cmp	 ebp, ebx
  000d9	74 3c		 je	 SHORT $LN6@RandStop

; 165  : 	{
; 166  : 		bDidSlowPoll = FALSE;

  000db	89 1d 00 00 00
	00		 mov	 DWORD PTR _bDidSlowPoll, ebx

; 167  : 		RandomPoolEnrichedByUser = FALSE;

  000e1	89 1d 00 00 00
	00		 mov	 DWORD PTR _RandomPoolEnrichedByUser, ebx

; 168  : 
; 169  : 		if (pRandPool != NULL)

  000e7	3b fb		 cmp	 edi, ebx
  000e9	74 2c		 je	 SHORT $LN6@RandStop

; 170  : 		{
; 171  : 			burn (pRandPool, RANDOMPOOL_ALLOCSIZE);

  000eb	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  000f0	8b d7		 mov	 edx, edi
  000f2	8b f1		 mov	 esi, ecx
  000f4	8b c7		 mov	 eax, edi
$LL19@RandStop:
  000f6	88 18		 mov	 BYTE PTR [eax], bl
  000f8	40		 inc	 eax
  000f9	83 ee 01	 sub	 esi, 1
  000fc	75 f8		 jne	 SHORT $LL19@RandStop
  000fe	8b ff		 npad	 2
$LL2@RandStop:
  00100	49		 dec	 ecx
  00101	88 1a		 mov	 BYTE PTR [edx], bl
  00103	42		 inc	 edx
  00104	3b cb		 cmp	 ecx, ebx
  00106	75 f8		 jne	 SHORT $LL2@RandStop

; 172  : 			TCfree (pRandPool);

  00108	57		 push	 edi
  00109	e8 00 00 00 00	 call	 _free
  0010e	83 c4 04	 add	 esp, 4

; 173  : 			pRandPool = NULL;

  00111	89 1d 00 00 00
	00		 mov	 DWORD PTR _pRandPool, ebx
$LN6@RandStop:
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5d		 pop	 ebp
  0011a	5b		 pop	 ebx

; 174  : 		}
; 175  : 	}
; 176  : }

  0011b	c3		 ret	 0
_RandStop ENDP
_TEXT	ENDS
PUBLIC	_IsRandomNumberGeneratorStarted
; Function compile flags: /Ogtpy
;	COMDAT _IsRandomNumberGeneratorStarted
_TEXT	SEGMENT
_IsRandomNumberGeneratorStarted PROC			; COMDAT

; 180  : 	return bRandDidInit;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _bRandDidInit

; 181  : }

  00005	c3		 ret	 0
_IsRandomNumberGeneratorStarted ENDP
_TEXT	ENDS
PUBLIC	_RandSetHashFunction
EXTRN	_HashIsDeprecated:PROC
; Function compile flags: /Ogtpy
;	COMDAT _RandSetHashFunction
_TEXT	SEGMENT
_hash_algo_id$ = 8					; size = 4
_RandSetHashFunction PROC				; COMDAT

; 184  : {

  00000	56		 push	 esi

; 185  : 	if (HashIsDeprecated (hash_algo_id))

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _hash_algo_id$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _HashIsDeprecated
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN4@RandSetHas

; 186  : 		hash_algo_id = DEFAULT_HASH_ALGORITHM;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 187  : 
; 188  : 	HashFunction = hash_algo_id;

  00017	a3 00 00 00 00	 mov	 DWORD PTR _HashFunction, eax
  0001c	5e		 pop	 esi

; 189  : }

  0001d	c3		 ret	 0
$LN4@RandSetHas:

; 187  : 
; 188  : 	HashFunction = hash_algo_id;

  0001e	89 35 00 00 00
	00		 mov	 DWORD PTR _HashFunction, esi
  00024	5e		 pop	 esi

; 189  : }

  00025	c3		 ret	 0
_RandSetHashFunction ENDP
_TEXT	ENDS
PUBLIC	_RandGetHashFunction
; Function compile flags: /Ogtpy
;	COMDAT _RandGetHashFunction
_TEXT	SEGMENT
_RandGetHashFunction PROC				; COMDAT

; 193  : 	return HashFunction;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction

; 194  : }

  00005	c3		 ret	 0
_RandGetHashFunction ENDP
_TEXT	ENDS
PUBLIC	_SetRandomPoolEnrichedByUserStatus
; Function compile flags: /Ogtpy
;	COMDAT _SetRandomPoolEnrichedByUserStatus
_TEXT	SEGMENT
_enriched$ = 8						; size = 4
_SetRandomPoolEnrichedByUserStatus PROC			; COMDAT

; 198  : 	RandomPoolEnrichedByUser = enriched;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _enriched$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, eax

; 199  : }

  00009	c3		 ret	 0
_SetRandomPoolEnrichedByUserStatus ENDP
_TEXT	ENDS
PUBLIC	_IsRandomPoolEnrichedByUser
; Function compile flags: /Ogtpy
;	COMDAT _IsRandomPoolEnrichedByUser
_TEXT	SEGMENT
_IsRandomPoolEnrichedByUser PROC			; COMDAT

; 203  : 	return RandomPoolEnrichedByUser;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _RandomPoolEnrichedByUser

; 204  : }

  00005	c3		 ret	 0
_IsRandomPoolEnrichedByUser ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_Randmix
EXTRN	_RMD160Final:PROC
EXTRN	_RMD160Update:PROC
EXTRN	_RMD160Init:PROC
EXTRN	_sha512_end:PROC
EXTRN	_sha512_hash:PROC
EXTRN	_sha512_begin:PROC
EXTRN	_WHIRLPOOL_finalize:PROC
EXTRN	_WHIRLPOOL_add:PROC
EXTRN	_WHIRLPOOL_init:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Randmix
_TEXT	SEGMENT
_digestSize$81371 = -544				; size = 4
_sctx$81368 = -540					; size = 208
_rctx$81367 = -332					; size = 96
_wctx$81366 = -236					; size = 168
_hashOutputBuffer$81365 = -68				; size = 64
__$ArrayPad$ = -4					; size = 4
_Randmix PROC						; COMDAT

; 208  : {

  00000	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 1c 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+544], eax

; 209  : 	if (bRandmixEnabled)

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _bRandmixEnabled
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 19 02 00
	00		 je	 $LN107@Randmix

; 210  : 	{
; 211  : 		unsigned char hashOutputBuffer [MAX_DIGESTSIZE];
; 212  : 		WHIRLPOOL_CTX	wctx;
; 213  : 		RMD160_CTX		rctx;
; 214  : 		sha512_ctx		sctx;
; 215  : 		int poolIndex, digestIndex, digestSize;
; 216  : 
; 217  : 		switch (HashFunction)

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00026	83 e8 01	 sub	 eax, 1
  00029	56		 push	 esi
  0002a	74 1e		 je	 SHORT $LN43@Randmix
  0002c	83 e8 01	 sub	 eax, 1
  0002f	74 12		 je	 SHORT $LN42@Randmix
  00031	83 e8 01	 sub	 eax, 1
  00034	74 0d		 je	 SHORT $LN42@Randmix

; 226  : 
; 227  : 		case WHIRLPOOL:
; 228  : 			digestSize = WHIRLPOOL_DIGESTSIZE;
; 229  : 			break;
; 230  : 
; 231  : 		default:
; 232  : 			TC_THROW_FATAL_EXCEPTION;

  00036	8b 74 24 04	 mov	 esi, DWORD PTR _digestSize$81371[esp+548]
  0003a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00041	eb 0c		 jmp	 SHORT $LN44@Randmix
$LN42@Randmix:

; 221  : 			break;
; 222  : 
; 223  : 		case SHA512:
; 224  : 			digestSize = SHA512_DIGESTSIZE;

  00043	be 40 00 00 00	 mov	 esi, 64			; 00000040H

; 225  : 			break;

  00048	eb 05		 jmp	 SHORT $LN44@Randmix
$LN43@Randmix:

; 218  : 		{
; 219  : 		case RIPEMD160:
; 220  : 			digestSize = RIPEMD160_DIGESTSIZE;

  0004a	be 14 00 00 00	 mov	 esi, 20			; 00000014H
$LN44@Randmix:

; 233  : 		}
; 234  : 
; 235  : 		if (RNG_POOL_SIZE % digestSize)

  0004f	b8 40 01 00 00	 mov	 eax, 320		; 00000140H
  00054	99		 cdq
  00055	f7 fe		 idiv	 esi
  00057	85 d2		 test	 edx, edx
  00059	74 07		 je	 SHORT $LN39@Randmix

; 236  : 			TC_THROW_FATAL_EXCEPTION;

  0005b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN39@Randmix:
  00062	57		 push	 edi

; 237  : 
; 238  : 		for (poolIndex = 0; poolIndex < RNG_POOL_SIZE; poolIndex += digestSize)		

  00063	33 ff		 xor	 edi, edi
  00065	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL108@Randmix:

; 239  : 		{
; 240  : 			/* Compute the message digest of the entire pool using the selected hash function. */
; 241  : 			switch (HashFunction)

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  00075	83 e8 01	 sub	 eax, 1
  00078	0f 84 86 00 00
	00		 je	 $LN33@Randmix
  0007e	83 e8 01	 sub	 eax, 1
  00081	74 4d		 je	 SHORT $LN32@Randmix
  00083	83 e8 01	 sub	 eax, 1
  00086	74 0c		 je	 SHORT $LN31@Randmix

; 260  : 
; 261  : 			default:		
; 262  : 				// Unknown/wrong ID
; 263  : 				TC_THROW_FATAL_EXCEPTION;

  00088	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  0008f	e9 ad 00 00 00	 jmp	 $LN34@Randmix
$LN31@Randmix:

; 254  : 
; 255  : 			case WHIRLPOOL:
; 256  : 				WHIRLPOOL_init (&wctx);

  00094	8d 8c 24 3c 01
	00 00		 lea	 ecx, DWORD PTR _wctx$81366[esp+552]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _WHIRLPOOL_init

; 257  : 				WHIRLPOOL_add (pRandPool, RNG_POOL_SIZE * 8, &wctx);

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _pRandPool
  000a6	8d 94 24 40 01
	00 00		 lea	 edx, DWORD PTR _wctx$81366[esp+556]
  000ad	52		 push	 edx
  000ae	68 00 0a 00 00	 push	 2560			; 00000a00H
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _WHIRLPOOL_add

; 258  : 				WHIRLPOOL_finalize (&wctx, hashOutputBuffer);

  000b9	8d 8c 24 f4 01
	00 00		 lea	 ecx, DWORD PTR _hashOutputBuffer$81365[esp+568]
  000c0	51		 push	 ecx
  000c1	8d 94 24 50 01
	00 00		 lea	 edx, DWORD PTR _wctx$81366[esp+572]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _WHIRLPOOL_finalize

; 259  : 				break;

  000ce	eb 6e		 jmp	 SHORT $LN117@Randmix
$LN32@Randmix:

; 247  : 				break;
; 248  : 
; 249  : 			case SHA512:
; 250  : 				sha512_begin (&sctx);

  000d0	8d 44 24 0c	 lea	 eax, DWORD PTR _sctx$81368[esp+552]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _sha512_begin

; 251  : 				sha512_hash (pRandPool, RNG_POOL_SIZE, &sctx);

  000da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pRandPool
  000e0	8d 4c 24 10	 lea	 ecx, DWORD PTR _sctx$81368[esp+556]
  000e4	51		 push	 ecx
  000e5	68 40 01 00 00	 push	 320			; 00000140H
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _sha512_hash

; 252  : 				sha512_end (hashOutputBuffer, &sctx);

  000f0	8d 44 24 1c	 lea	 eax, DWORD PTR _sctx$81368[esp+568]
  000f4	50		 push	 eax
  000f5	8d 8c 24 f8 01
	00 00		 lea	 ecx, DWORD PTR _hashOutputBuffer$81365[esp+572]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 _sha512_end

; 253  : 				break;

  00102	eb 3a		 jmp	 SHORT $LN117@Randmix
$LN33@Randmix:

; 242  : 			{
; 243  : 			case RIPEMD160:
; 244  : 				RMD160Init(&rctx);

  00104	8d 94 24 dc 00
	00 00		 lea	 edx, DWORD PTR _rctx$81367[esp+552]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _RMD160Init

; 245  : 				RMD160Update(&rctx, pRandPool, RNG_POOL_SIZE);

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR _pRandPool
  00116	68 40 01 00 00	 push	 320			; 00000140H
  0011b	50		 push	 eax
  0011c	8d 8c 24 e8 00
	00 00		 lea	 ecx, DWORD PTR _rctx$81367[esp+564]
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 _RMD160Update

; 246  : 				RMD160Final(hashOutputBuffer, &rctx);

  00129	8d 94 24 ec 00
	00 00		 lea	 edx, DWORD PTR _rctx$81367[esp+568]
  00130	52		 push	 edx
  00131	8d 84 24 f8 01
	00 00		 lea	 eax, DWORD PTR _hashOutputBuffer$81365[esp+572]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _RMD160Final
$LN117@Randmix:
  0013e	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@Randmix:

; 264  : 			}
; 265  : 
; 266  : 			/* XOR the resultant message digest to the pool at the poolIndex position. */
; 267  : 			for (digestIndex = 0; digestIndex < digestSize; digestIndex++)

  00141	33 c0		 xor	 eax, eax
  00143	85 f6		 test	 esi, esi
  00145	7e 18		 jle	 SHORT $LN37@Randmix
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  0014d	03 cf		 add	 ecx, edi
  0014f	90		 npad	 1
$LL29@Randmix:

; 268  : 			{
; 269  : 				pRandPool [poolIndex + digestIndex] ^= hashOutputBuffer [digestIndex];

  00150	8a 94 04 e4 01
	00 00		 mov	 dl, BYTE PTR _hashOutputBuffer$81365[esp+eax+552]
  00157	30 14 01	 xor	 BYTE PTR [ecx+eax], dl
  0015a	40		 inc	 eax
  0015b	3b c6		 cmp	 eax, esi
  0015d	7c f1		 jl	 SHORT $LL29@Randmix
$LN37@Randmix:

; 237  : 
; 238  : 		for (poolIndex = 0; poolIndex < RNG_POOL_SIZE; poolIndex += digestSize)		

  0015f	03 fe		 add	 edi, esi
  00161	81 ff 40 01 00
	00		 cmp	 edi, 320		; 00000140H
  00167	0f 8c 03 ff ff
	ff		 jl	 $LL108@Randmix

; 270  : 			}
; 271  : 		}
; 272  : 
; 273  : 		/* Prevent leaks */
; 274  : 		burn (hashOutputBuffer, MAX_DIGESTSIZE);	

  0016d	8d 94 24 e4 01
	00 00		 lea	 edx, DWORD PTR _hashOutputBuffer$81365[esp+552]
  00174	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00179	8b f1		 mov	 esi, ecx
  0017b	8b c2		 mov	 eax, edx
  0017d	5f		 pop	 edi
  0017e	8b ff		 npad	 2
$LL50@Randmix:
  00180	c6 00 00	 mov	 BYTE PTR [eax], 0
  00183	40		 inc	 eax
  00184	83 ee 01	 sub	 esi, 1
  00187	75 f7		 jne	 SHORT $LL50@Randmix
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL23@Randmix:
  00190	49		 dec	 ecx
  00191	c6 02 00	 mov	 BYTE PTR [edx], 0
  00194	42		 inc	 edx
  00195	85 c9		 test	 ecx, ecx
  00197	75 f7		 jne	 SHORT $LL23@Randmix

; 275  : 		switch (HashFunction)

  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _HashFunction
  0019e	83 e8 01	 sub	 eax, 1
  001a1	74 68		 je	 SHORT $LN18@Randmix
  001a3	83 e8 01	 sub	 eax, 1
  001a6	74 34		 je	 SHORT $LN12@Randmix
  001a8	83 e8 01	 sub	 eax, 1
  001ab	74 0b		 je	 SHORT $LN6@Randmix

; 288  : 
; 289  : 		default:		
; 290  : 			// Unknown/wrong ID
; 291  : 			TC_THROW_FATAL_EXCEPTION;

  001ad	88 0d 00 00 00
	00		 mov	 BYTE PTR ds:0, cl
  001b3	e9 81 00 00 00	 jmp	 $LN118@Randmix
$LN6@Randmix:

; 284  : 
; 285  : 		case WHIRLPOOL:
; 286  : 			burn (&wctx, sizeof(wctx));		

  001b8	8d 94 24 38 01
	00 00		 lea	 edx, DWORD PTR _wctx$81366[esp+548]
  001bf	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  001c4	8b f1		 mov	 esi, ecx
  001c6	8b c2		 mov	 eax, edx
$LL62@Randmix:
  001c8	c6 00 00	 mov	 BYTE PTR [eax], 0
  001cb	40		 inc	 eax
  001cc	83 ee 01	 sub	 esi, 1
  001cf	75 f7		 jne	 SHORT $LL62@Randmix
$LL3@Randmix:
  001d1	49		 dec	 ecx
  001d2	c6 02 00	 mov	 BYTE PTR [edx], 0
  001d5	42		 inc	 edx
  001d6	85 c9		 test	 ecx, ecx
  001d8	75 f7		 jne	 SHORT $LL3@Randmix

; 287  : 			break;

  001da	eb 5d		 jmp	 SHORT $LN118@Randmix
$LN12@Randmix:

; 279  : 			break;
; 280  : 
; 281  : 		case SHA512:
; 282  : 			burn (&sctx, sizeof(sctx));		

  001dc	8d 54 24 08	 lea	 edx, DWORD PTR _sctx$81368[esp+548]
  001e0	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  001e5	8b f1		 mov	 esi, ecx
  001e7	8b c2		 mov	 eax, edx
  001e9	8d a4 24 00 00
	00 00		 npad	 7
$LL58@Randmix:
  001f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001f3	40		 inc	 eax
  001f4	83 ee 01	 sub	 esi, 1
  001f7	75 f7		 jne	 SHORT $LL58@Randmix
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL9@Randmix:
  00200	49		 dec	 ecx
  00201	c6 02 00	 mov	 BYTE PTR [edx], 0
  00204	42		 inc	 edx
  00205	85 c9		 test	 ecx, ecx
  00207	75 f7		 jne	 SHORT $LL9@Randmix

; 283  : 			break;

  00209	eb 2e		 jmp	 SHORT $LN118@Randmix
$LN18@Randmix:

; 276  : 		{
; 277  : 		case RIPEMD160:
; 278  : 			burn (&rctx, sizeof(rctx));		

  0020b	8d 94 24 d8 00
	00 00		 lea	 edx, DWORD PTR _rctx$81367[esp+548]
  00212	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00217	8b f1		 mov	 esi, ecx
  00219	8b c2		 mov	 eax, edx
  0021b	eb 03 8d 49 00	 npad	 5
$LL54@Randmix:
  00220	c6 00 00	 mov	 BYTE PTR [eax], 0
  00223	40		 inc	 eax
  00224	83 ee 01	 sub	 esi, 1
  00227	75 f7		 jne	 SHORT $LL54@Randmix
  00229	8d a4 24 00 00
	00 00		 npad	 7
$LL15@Randmix:
  00230	49		 dec	 ecx
  00231	c6 02 00	 mov	 BYTE PTR [edx], 0
  00234	42		 inc	 edx
  00235	85 c9		 test	 ecx, ecx
  00237	75 f7		 jne	 SHORT $LL15@Randmix
$LN118@Randmix:
  00239	5e		 pop	 esi
$LN107@Randmix:

; 292  : 		}
; 293  : 	}
; 294  : 	return TRUE;
; 295  : }

  0023a	8b 8c 24 1c 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+544]
  00241	33 cc		 xor	 ecx, esp
  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024d	81 c4 20 02 00
	00		 add	 esp, 544		; 00000220H
  00253	c3		 ret	 0
_Randmix ENDP
_TEXT	ENDS
PUBLIC	_RandaddBuf
; Function compile flags: /Ogtpy
;	COMDAT _RandaddBuf
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_RandaddBuf PROC					; COMDAT

; 299  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 300  : 	int i;
; 301  : 	for (i = 0; i < len; i++)

  00002	8b 7c 24 10	 mov	 edi, DWORD PTR _len$[esp+4]
  00006	33 f6		 xor	 esi, esi
  00008	85 ff		 test	 edi, edi
  0000a	7e 55		 jle	 SHORT $LN3@RandaddBuf
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  00017	55		 push	 ebp
  00018	8b 6c 24 10	 mov	 ebp, DWORD PTR _buf$[esp+8]
  0001c	8d 64 24 00	 npad	 4
$LL5@RandaddBuf:

; 302  : 	{
; 303  : 		RandaddByte (((unsigned char *) buf)[i]);

  00020	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00025	75 07		 jne	 SHORT $LN2@RandaddBuf
  00027	33 c0		 xor	 eax, eax
  00029	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN2@RandaddBuf:
  0002e	8a 14 2e	 mov	 dl, BYTE PTR [esi+ebp]
  00031	00 14 01	 add	 BYTE PTR [ecx+eax], dl
  00034	8b d0		 mov	 edx, eax
  00036	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0003c	79 05		 jns	 SHORT $LN10@RandaddBuf
  0003e	4a		 dec	 edx
  0003f	83 ca f0	 or	 edx, -16		; fffffff0H
  00042	42		 inc	 edx
$LN10@RandaddBuf:
  00043	75 10		 jne	 SHORT $LN1@RandaddBuf
  00045	e8 00 00 00 00	 call	 _Randmix
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN1@RandaddBuf:
  00055	40		 inc	 eax
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
  0005e	7c c0		 jl	 SHORT $LL5@RandaddBuf
  00060	5d		 pop	 ebp
$LN3@RandaddBuf:
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 304  : 	}
; 305  : }

  00063	c3		 ret	 0
_RandaddBuf ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@ ; `string'
PUBLIC	_RandpeekBytes
EXTRN	_Error:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
CONST	SEGMENT
??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@ DB 'ERR_NOT_ENOUGH_RAN'
	DB	'DOM_DATA', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _RandpeekBytes
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_RandpeekBytes PROC					; COMDAT

; 309  : 	if (!bRandDidInit)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  00007	75 03		 jne	 SHORT $LN2@RandpeekBy

; 310  : 		return FALSE;

  00009	33 c0		 xor	 eax, eax

; 323  : }

  0000b	c3		 ret	 0
$LN2@RandpeekBy:
  0000c	56		 push	 esi

; 311  : 
; 312  : 	if (len > RNG_POOL_SIZE)

  0000d	8b 74 24 0c	 mov	 esi, DWORD PTR _len$[esp]
  00011	81 fe 40 01 00
	00		 cmp	 esi, 320		; 00000140H
  00017	7e 12		 jle	 SHORT $LN1@RandpeekBy

; 313  : 	{
; 314  : 		Error ("ERR_NOT_ENOUGH_RANDOM_DATA");	

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
  0001e	e8 00 00 00 00	 call	 _Error
  00023	83 c4 04	 add	 esp, 4

; 315  : 		len = RNG_POOL_SIZE;

  00026	be 40 01 00 00	 mov	 esi, 320		; 00000140H
$LN1@RandpeekBy:

; 316  : 	}
; 317  : 
; 318  : 	EnterCriticalSection (&critRandProt);

  0002b	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 319  : 	memcpy (buf, pRandPool, len);

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _pRandPool
  0003b	8b 4c 24 08	 mov	 ecx, DWORD PTR _buf$[esp]
  0003f	56		 push	 esi
  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _memcpy
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 320  : 	LeaveCriticalSection (&critRandProt);

  0004a	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 321  : 
; 322  : 	return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	5e		 pop	 esi

; 323  : }

  0005b	c3		 ret	 0
_RandpeekBytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@ ; `string'
PUBLIC	??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@	; `string'
PUBLIC	??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@	; `string'
PUBLIC	??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@	; `string'
PUBLIC	??_C@_05LELOMLIF@WinNT?$AA@			; `string'
PUBLIC	??_C@_0M@GGPOPAAP@ProductType?$AA@		; `string'
PUBLIC	??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_SlowPoll
EXTRN	__imp__CryptGenRandom@12:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	_sprintf_s:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
_BSS	SEGMENT
_buffer	DB	0140H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
CONST	SEGMENT
??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@ DB '\\.\PhysicalDrive%'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@ DB 'L'
	DB	00H, 'a', 00H, 'n', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'S', 00H
	DB	'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'L'
	DB	00H, 'a', 00H, 'n', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'W', 00H
	DB	'o', 00H, 'r', 00H, 'k', 00H, 's', 00H, 't', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
CONST	SEGMENT
??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@ DB 'NetApiBufferFree', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@
CONST	SEGMENT
??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@ DB 'NetApiBufferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
CONST	SEGMENT
??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@ DB 'NetStatisticsGet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LELOMLIF@WinNT?$AA@
CONST	SEGMENT
??_C@_05LELOMLIF@WinNT?$AA@ DB 'WinNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGPOPAAP@ProductType?$AA@
CONST	SEGMENT
??_C@_0M@GGPOPAAP@ProductType?$AA@ DB 'ProductType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\ProductOptions', 00H	; `string'
CONST	ENDS
;	COMDAT ?isWorkstation@?1??SlowPoll@@9@4HA
_DATA	SEGMENT
?isWorkstation@?1??SlowPoll@@9@4HA DD 0ffffffffH	; `SlowPoll'::`2'::isWorkstation
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\random.cpp
_DATA	ENDS
;	COMDAT _SlowPoll
_TEXT	SEGMENT
_dwSize$ = -160						; size = 4
_lpBuffer$ = -156					; size = 4
_hKey$81623 = -152					; size = 4
_diskPerformance$81655 = -148				; size = 88
_szDevice$81656 = -60					; size = 24
_szValue$81629 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_SlowPoll PROC						; COMDAT

; 537  : {

  00000	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+160], eax

; 538  : 	static int isWorkstation = -1;
; 539  : 	static int cbPerfData = 0x10000;
; 540  : 	HANDLE hDevice;
; 541  : 	LPBYTE lpBuffer;
; 542  : 	DWORD dwSize, status;
; 543  : 	LPWSTR lpszLanW, lpszLanS;
; 544  : 	int nDrive;
; 545  : 
; 546  : 	/* Find out whether this is an NT server or workstation if necessary */
; 547  : 	if (isWorkstation == -1)

  00014	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@4HA, -1
  0001b	75 7f		 jne	 SHORT $LN43@SlowPoll

; 548  : 	{
; 549  : 		HKEY hKey;
; 550  : 
; 551  : 		if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
; 552  : 		       "SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
; 553  : 				  0, KEY_READ, &hKey) == ERROR_SUCCESS)

  0001d	8d 44 24 08	 lea	 eax, DWORD PTR _hKey$81623[esp+160]
  00021	50		 push	 eax
  00022	68 19 00 02 00	 push	 131097			; 00020019H
  00027	6a 00		 push	 0
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NKLICLFP@SYSTEM?2CurrentControlSet?2Control@
  0002e	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00039	85 c0		 test	 eax, eax
  0003b	75 5f		 jne	 SHORT $LN43@SlowPoll

; 554  : 		{
; 555  : 			unsigned char szValue[32];
; 556  : 			dwSize = sizeof (szValue);
; 557  : 
; 558  : 			isWorkstation = TRUE;
; 559  : 			status = RegQueryValueEx (hKey, "ProductType", 0, NULL,
; 560  : 						  szValue, &dwSize);

  0003d	8d 0c 24	 lea	 ecx, DWORD PTR _dwSize$[esp+160]
  00040	51		 push	 ecx
  00041	8d 94 24 80 00
	00 00		 lea	 edx, DWORD PTR _szValue$81629[esp+164]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	50		 push	 eax
  0004b	8b 44 24 18	 mov	 eax, DWORD PTR _hKey$81623[esp+176]
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GGPOPAAP@ProductType?$AA@
  00054	50		 push	 eax
  00055	c7 44 24 18 20
	00 00 00	 mov	 DWORD PTR _dwSize$[esp+184], 32 ; 00000020H
  0005d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@4HA, 1
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 561  : 
; 562  : 			if (status == ERROR_SUCCESS && _stricmp ((char *) szValue, "WinNT"))

  0006d	85 c0		 test	 eax, eax
  0006f	75 20		 jne	 SHORT $LN17@SlowPoll
  00071	8d 4c 24 7c	 lea	 ecx, DWORD PTR _szValue$81629[esp+160]
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_05LELOMLIF@WinNT?$AA@
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 __stricmp
  00080	83 c4 08	 add	 esp, 8
  00083	85 c0		 test	 eax, eax
  00085	74 0a		 je	 SHORT $LN17@SlowPoll

; 563  : 				/* Note: There are (at least) three cases for
; 564  : 				   ProductType: WinNT = NT Workstation,
; 565  : 				   ServerNT = NT Server, LanmanNT = NT Server
; 566  : 				   acting as a Domain Controller */
; 567  : 				isWorkstation = FALSE;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@4HA, 0
$LN17@SlowPoll:

; 568  : 
; 569  : 			RegCloseKey (hKey);

  00091	8b 54 24 08	 mov	 edx, DWORD PTR _hKey$81623[esp+160]
  00095	52		 push	 edx
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN43@SlowPoll:
  0009c	56		 push	 esi
  0009d	57		 push	 edi

; 570  : 		}
; 571  : 	}
; 572  : 	/* Initialize the NetAPI32 function pointers if necessary */
; 573  : 	if (hNetAPI32 == NULL)

  0009e	33 ff		 xor	 edi, edi
  000a0	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A, edi ; hNetAPI32
  000a6	0f 85 85 00 00
	00		 jne	 $LN44@SlowPoll

; 574  : 	{
; 575  : 		/* Obtain a handle to the module containing the Lan Manager
; 576  : 		   functions */
; 577  : 		hNetAPI32 = LoadDLL_NETAPI32();

  000ac	6a 0d		 push	 13			; 0000000dH
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@ECNDHJLG@?$AAN?$AAE?$AAT?$AAA?$AAP?$AAI?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL?$AA?$AA@
  000b3	e8 00 00 00 00	 call	 ?LoadDLL@@YAPAUHINSTANCE__@@PA_WI@Z ; LoadDLL
  000b8	83 c4 08	 add	 esp, 8
  000bb	a3 00 00 00 00	 mov	 DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A, eax ; hNetAPI32

; 578  : 		if (hNetAPI32 != NULL)

  000c0	3b c7		 cmp	 eax, edi
  000c2	0f 84 bb 00 00
	00		 je	 $LN12@SlowPoll

; 579  : 		{
; 580  : 			/* Now get pointers to the functions */
; 581  : 			pNetStatisticsGet = (NETSTATISTICSGET) GetProcAddress (hNetAPI32,
; 582  : 							"NetStatisticsGet");

  000c8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
  000d3	50		 push	 eax
  000d4	ff d6		 call	 esi
  000d6	a3 00 00 00 00	 mov	 DWORD PTR ?pNetStatisticsGet@@3P6GKPA_W0KKPAPAE@ZA, eax ; pNetStatisticsGet

; 583  : 			pNetApiBufferSize = (NETAPIBUFFERSIZE) GetProcAddress (hNetAPI32,
; 584  : 							"NetApiBufferSize");

  000db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A ; hNetAPI32
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HGFPEPHK@NetApiBufferSize?$AA@
  000e5	50		 push	 eax
  000e6	ff d6		 call	 esi

; 585  : 			pNetApiBufferFree = (NETAPIBUFFERFREE) GetProcAddress (hNetAPI32,
; 586  : 							"NetApiBufferFree");

  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A ; hNetAPI32
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
  000f3	51		 push	 ecx
  000f4	a3 00 00 00 00	 mov	 DWORD PTR ?pNetApiBufferSize@@3P6GKPAXPAK@ZA, eax ; pNetApiBufferSize
  000f9	ff d6		 call	 esi
  000fb	a3 00 00 00 00	 mov	 DWORD PTR ?pNetApiBufferFree@@3P6GKPAX@ZA, eax ; pNetApiBufferFree

; 587  : 
; 588  : 			/* Make sure we got valid pointers for every NetAPI32
; 589  : 			   function */
; 590  : 			if (pNetStatisticsGet == NULL ||
; 591  : 			    pNetApiBufferSize == NULL ||
; 592  : 			    pNetApiBufferFree == NULL)

  00100	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?pNetStatisticsGet@@3P6GKPA_W0KKPAPAE@ZA, edi ; pNetStatisticsGet
  00106	74 0c		 je	 SHORT $LN13@SlowPoll
  00108	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?pNetApiBufferSize@@3P6GKPAXPAK@ZA, edi ; pNetApiBufferSize
  0010e	74 04		 je	 SHORT $LN13@SlowPoll
  00110	3b c7		 cmp	 eax, edi
  00112	75 15		 jne	 SHORT $LN14@SlowPoll
$LN13@SlowPoll:

; 593  : 			{
; 594  : 				/* Free the library reference and reset the
; 595  : 				   static handle */
; 596  : 				FreeLibrary (hNetAPI32);

  00114	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A ; hNetAPI32
  0011a	52		 push	 edx
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 597  : 				hNetAPI32 = NULL;

  00121	89 3d 00 00 00
	00		 mov	 DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A, edi ; hNetAPI32

; 598  : 			}
; 599  : 		}
; 600  : 	}
; 601  : 
; 602  : 	/* Get network statistics.  Note: Both NT Workstation and NT Server
; 603  : 	   by default will be running both the workstation and server
; 604  : 	   services.  The heuristic below is probably useful though on the
; 605  : 	   assumption that the majority of the network traffic will be via
; 606  : 	   the appropriate service */
; 607  : 	lpszLanW = (LPWSTR) WIDE ("LanmanWorkstation");
; 608  : 	lpszLanS = (LPWSTR) WIDE ("LanmanServer");
; 609  : 	if (hNetAPI32 &&
; 610  : 	    pNetStatisticsGet (NULL,
; 611  : 			       isWorkstation ? lpszLanW : lpszLanS,
; 612  : 			       0, 0, &lpBuffer) == 0)

  00127	eb 5a		 jmp	 SHORT $LN12@SlowPoll
$LN14@SlowPoll:
  00129	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?hNetAPI32@@3PAUHINSTANCE__@@A, edi ; hNetAPI32
  0012f	74 52		 je	 SHORT $LN12@SlowPoll
$LN44@SlowPoll:
  00131	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
  00136	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?isWorkstation@?1??SlowPoll@@9@4HA, edi
  0013c	75 05		 jne	 SHORT $LN23@SlowPoll
  0013e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
$LN23@SlowPoll:
  00143	8d 4c 24 0c	 lea	 ecx, DWORD PTR _lpBuffer$[esp+168]
  00147	51		 push	 ecx
  00148	57		 push	 edi
  00149	57		 push	 edi
  0014a	50		 push	 eax
  0014b	57		 push	 edi
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR ?pNetStatisticsGet@@3P6GKPA_W0KKPAPAE@ZA ; pNetStatisticsGet
  00152	85 c0		 test	 eax, eax
  00154	75 2d		 jne	 SHORT $LN12@SlowPoll

; 613  : 	{
; 614  : 		pNetApiBufferSize (lpBuffer, &dwSize);

  00156	8b 44 24 0c	 mov	 eax, DWORD PTR _lpBuffer$[esp+168]
  0015a	8d 54 24 08	 lea	 edx, DWORD PTR _dwSize$[esp+168]
  0015e	52		 push	 edx
  0015f	50		 push	 eax
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR ?pNetApiBufferSize@@3P6GKPAXPAK@ZA ; pNetApiBufferSize

; 615  : 		RandaddBuf ((unsigned char *) lpBuffer, dwSize);

  00166	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwSize$[esp+168]
  0016a	8b 54 24 0c	 mov	 edx, DWORD PTR _lpBuffer$[esp+168]
  0016e	51		 push	 ecx
  0016f	52		 push	 edx
  00170	e8 00 00 00 00	 call	 _RandaddBuf

; 616  : 		pNetApiBufferFree (lpBuffer);

  00175	8b 44 24 14	 mov	 eax, DWORD PTR _lpBuffer$[esp+176]
  00179	83 c4 08	 add	 esp, 8
  0017c	50		 push	 eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR ?pNetApiBufferFree@@3P6GKPAX@ZA ; pNetApiBufferFree
$LN12@SlowPoll:
  00183	55		 push	 ebp

; 617  : 	}
; 618  : 
; 619  : 	/* Get disk I/O statistics for all the hard drives */
; 620  : 	for (nDrive = 0;; nDrive++)
; 621  : 	{
; 622  : 		DISK_PERFORMANCE diskPerformance;
; 623  : 		char szDevice[24];
; 624  : 
; 625  : 		/* Check whether we can access this device */
; 626  : 		snprintf (szDevice, ARRAY_LENGTH(szDevice), "\\\\.\\PhysicalDrive%d", nDrive);

  00184	57		 push	 edi
  00185	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
  0018a	8d 4c 24 78	 lea	 ecx, DWORD PTR _szDevice$81656[esp+180]
  0018e	6a 18		 push	 24			; 00000018H
  00190	51		 push	 ecx
  00191	e8 00 00 00 00	 call	 _sprintf_s

; 627  : 		hDevice = CreateFile (szDevice, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
; 628  : 				      NULL, OPEN_EXISTING, 0, NULL);

  00196	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__CreateFileA@28
  0019c	83 c4 10	 add	 esp, 16			; 00000010H
  0019f	57		 push	 edi
  001a0	57		 push	 edi
  001a1	6a 03		 push	 3
  001a3	57		 push	 edi
  001a4	6a 03		 push	 3
  001a6	57		 push	 edi
  001a7	8d 94 24 88 00
	00 00		 lea	 edx, DWORD PTR _szDevice$81656[esp+196]
  001ae	52		 push	 edx
  001af	ff d5		 call	 ebp
  001b1	8b f0		 mov	 esi, eax

; 629  : 		if (hDevice == INVALID_HANDLE_VALUE)

  001b3	83 fe ff	 cmp	 esi, -1
  001b6	74 73		 je	 SHORT $LN34@SlowPoll
  001b8	53		 push	 ebx
  001b9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CloseHandle@4
  001bf	90		 npad	 1
$LL11@SlowPoll:

; 630  : 			break;
; 631  : 
; 632  : 
; 633  : 		/* Note: This only works if you have turned on the disk
; 634  : 		   performance counters with 'diskperf -y'.  These counters
; 635  : 		   are off by default */
; 636  : 		if (DeviceIoControl (hDevice, IOCTL_DISK_PERFORMANCE, NULL, 0,
; 637  : 				&diskPerformance, sizeof (DISK_PERFORMANCE),
; 638  : 				     &dwSize, NULL))

  001c0	6a 00		 push	 0
  001c2	8d 44 24 14	 lea	 eax, DWORD PTR _dwSize$[esp+180]
  001c6	50		 push	 eax
  001c7	6a 58		 push	 88			; 00000058H
  001c9	8d 4c 24 28	 lea	 ecx, DWORD PTR _diskPerformance$81655[esp+188]
  001cd	51		 push	 ecx
  001ce	6a 00		 push	 0
  001d0	6a 00		 push	 0
  001d2	68 20 00 07 00	 push	 458784			; 00070020H
  001d7	56		 push	 esi
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  001de	85 c0		 test	 eax, eax
  001e0	74 12		 je	 SHORT $LN7@SlowPoll

; 639  : 		{
; 640  : 			RandaddBuf ((unsigned char *) &diskPerformance, dwSize);

  001e2	8b 54 24 10	 mov	 edx, DWORD PTR _dwSize$[esp+176]
  001e6	52		 push	 edx
  001e7	8d 44 24 20	 lea	 eax, DWORD PTR _diskPerformance$81655[esp+180]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _RandaddBuf
  001f1	83 c4 08	 add	 esp, 8
$LN7@SlowPoll:

; 641  : 		}
; 642  : 		CloseHandle (hDevice);

  001f4	56		 push	 esi
  001f5	ff d3		 call	 ebx
  001f7	47		 inc	 edi
  001f8	57		 push	 edi
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBDFGGOO@?2?2?4?2PhysicalDrive?$CFd?$AA@
  001fe	8d 4c 24 7c	 lea	 ecx, DWORD PTR _szDevice$81656[esp+184]
  00202	6a 18		 push	 24			; 00000018H
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 _sprintf_s
  0020a	83 c4 10	 add	 esp, 16			; 00000010H
  0020d	6a 00		 push	 0
  0020f	6a 00		 push	 0
  00211	6a 03		 push	 3
  00213	6a 00		 push	 0
  00215	6a 03		 push	 3
  00217	6a 00		 push	 0
  00219	8d 94 24 8c 00
	00 00		 lea	 edx, DWORD PTR _szDevice$81656[esp+200]
  00220	52		 push	 edx
  00221	ff d5		 call	 ebp
  00223	8b f0		 mov	 esi, eax
  00225	83 fe ff	 cmp	 esi, -1
  00228	75 96		 jne	 SHORT $LL11@SlowPoll
  0022a	5b		 pop	 ebx
$LN34@SlowPoll:

; 643  : 	}
; 644  : 
; 645  : 	// CryptoAPI
; 646  : 	if (CryptoAPIAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer)) 

  0022b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?CryptoAPIAvailable@@3HA, 0 ; CryptoAPIAvailable
  00232	5d		 pop	 ebp
  00233	74 2c		 je	 SHORT $LN5@SlowPoll
  00235	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCryptProv@@3KA ; hCryptProv
  0023a	68 00 00 00 00	 push	 OFFSET _buffer
  0023f	68 40 01 00 00	 push	 320			; 00000140H
  00244	50		 push	 eax
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  0024b	85 c0		 test	 eax, eax
  0024d	74 12		 je	 SHORT $LN5@SlowPoll

; 647  : 		RandaddBuf (buffer, sizeof (buffer));

  0024f	68 40 01 00 00	 push	 320			; 00000140H
  00254	68 00 00 00 00	 push	 OFFSET _buffer
  00259	e8 00 00 00 00	 call	 _RandaddBuf
  0025e	83 c4 08	 add	 esp, 8
$LN5@SlowPoll:

; 648  : 
; 649  : 	burn(buffer, sizeof (buffer));

  00261	ba 00 00 00 00	 mov	 edx, OFFSET _buffer
  00266	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  0026b	8b f1		 mov	 esi, ecx
  0026d	8b c2		 mov	 eax, edx
  0026f	90		 npad	 1
$LL27@SlowPoll:
  00270	c6 00 00	 mov	 BYTE PTR [eax], 0
  00273	40		 inc	 eax
  00274	83 ee 01	 sub	 esi, 1
  00277	75 f7		 jne	 SHORT $LL27@SlowPoll
  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	eb 03 8d 49 00	 npad	 5
$LL2@SlowPoll:
  00280	49		 dec	 ecx
  00281	c6 02 00	 mov	 BYTE PTR [edx], 0
  00284	42		 inc	 edx
  00285	85 c9		 test	 ecx, ecx
  00287	75 f7		 jne	 SHORT $LL2@SlowPoll

; 650  : 	Randmix();

  00289	e8 00 00 00 00	 call	 _Randmix

; 651  : 	return TRUE;
; 652  : }

  0028e	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+160]
  00295	33 cc		 xor	 ecx, esp
  00297	b8 01 00 00 00	 mov	 eax, 1
  0029c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a1	81 c4 a0 00 00
	00		 add	 esp, 160		; 000000a0H
  002a7	c3		 ret	 0
_SlowPoll ENDP
_TEXT	ENDS
PUBLIC	_RandAddInt
; Function compile flags: /Ogtpy
;	COMDAT _RandAddInt
_TEXT	SEGMENT
_x$ = 8							; size = 4
_RandAddInt PROC					; COMDAT

; 43   : 	RandaddByte(x); 

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00005	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0000a	75 07		 jne	 SHORT $LN8@RandAddInt
  0000c	33 c0		 xor	 eax, eax
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN8@RandAddInt:
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
  00019	53		 push	 ebx
  0001a	8b 5c 24 08	 mov	 ebx, DWORD PTR _x$[esp]
  0001e	00 1c 01	 add	 BYTE PTR [ecx+eax], bl
  00021	8b d0		 mov	 edx, eax
  00023	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00029	79 05		 jns	 SHORT $LN12@RandAddInt
  0002b	4a		 dec	 edx
  0002c	83 ca f0	 or	 edx, -16		; fffffff0H
  0002f	42		 inc	 edx
$LN12@RandAddInt:
  00030	75 10		 jne	 SHORT $LN7@RandAddInt
  00032	e8 00 00 00 00	 call	 _Randmix
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN7@RandAddInt:
  00042	40		 inc	 eax
  00043	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 44   : 	RandaddByte((x >> 8)); 

  00048	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0004d	75 07		 jne	 SHORT $LN6@RandAddInt
  0004f	33 c0		 xor	 eax, eax
  00051	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN6@RandAddInt:
  00056	8b d3		 mov	 edx, ebx
  00058	c1 ea 08	 shr	 edx, 8
  0005b	00 14 01	 add	 BYTE PTR [ecx+eax], dl
  0005e	8b d0		 mov	 edx, eax
  00060	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00066	79 05		 jns	 SHORT $LN13@RandAddInt
  00068	4a		 dec	 edx
  00069	83 ca f0	 or	 edx, -16		; fffffff0H
  0006c	42		 inc	 edx
$LN13@RandAddInt:
  0006d	75 10		 jne	 SHORT $LN5@RandAddInt
  0006f	e8 00 00 00 00	 call	 _Randmix
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN5@RandAddInt:
  0007f	40		 inc	 eax
  00080	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 45   : 	RandaddByte((x >> 16));

  00085	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0008a	75 07		 jne	 SHORT $LN4@RandAddInt
  0008c	33 c0		 xor	 eax, eax
  0008e	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN4@RandAddInt:
  00093	8b d3		 mov	 edx, ebx
  00095	c1 ea 10	 shr	 edx, 16			; 00000010H
  00098	00 14 01	 add	 BYTE PTR [ecx+eax], dl
  0009b	8b d0		 mov	 edx, eax
  0009d	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  000a3	79 05		 jns	 SHORT $LN14@RandAddInt
  000a5	4a		 dec	 edx
  000a6	83 ca f0	 or	 edx, -16		; fffffff0H
  000a9	42		 inc	 edx
$LN14@RandAddInt:
  000aa	75 10		 jne	 SHORT $LN3@RandAddInt
  000ac	e8 00 00 00 00	 call	 _Randmix
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _nRandIndex
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pRandPool
$LN3@RandAddInt:
  000bc	40		 inc	 eax
  000bd	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 46   : 	RandaddByte((x >> 24));

  000c2	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  000c7	75 07		 jne	 SHORT $LN2@RandAddInt
  000c9	33 c0		 xor	 eax, eax
  000cb	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax
$LN2@RandAddInt:
  000d0	c1 eb 18	 shr	 ebx, 24			; 00000018H
  000d3	00 1c 01	 add	 BYTE PTR [ecx+eax], bl
  000d6	8b c8		 mov	 ecx, eax
  000d8	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  000de	5b		 pop	 ebx
  000df	79 05		 jns	 SHORT $LN15@RandAddInt
  000e1	49		 dec	 ecx
  000e2	83 c9 f0	 or	 ecx, -16		; fffffff0H
  000e5	41		 inc	 ecx
$LN15@RandAddInt:
  000e6	75 0c		 jne	 SHORT $LN11@RandAddInt
  000e8	e8 00 00 00 00	 call	 _Randmix
  000ed	ff 05 00 00 00
	00		 inc	 DWORD PTR _nRandIndex

; 47   : }

  000f3	c3		 ret	 0
$LN11@RandAddInt:

; 46   : 	RandaddByte((x >> 24));

  000f4	40		 inc	 eax
  000f5	a3 00 00 00 00	 mov	 DWORD PTR _nRandIndex, eax

; 47   : }

  000fa	c3		 ret	 0
_RandAddInt ENDP
_TEXT	ENDS
PUBLIC	_MouseProc@12
EXTRN	_crc_32_tab:BYTE
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__CallNextHookEx@16:PROC
;	COMDAT ?lastCrc2@?1??MouseProc@@9@12@4IA
_BSS	SEGMENT
?lastCrc2@?1??MouseProc@@9@12@4IA DD 01H DUP (?)	; `MouseProc'::`2'::lastCrc2
_BSS	ENDS
;	COMDAT ?lastCrc@?1??MouseProc@@9@12@4IA
_BSS	SEGMENT
?lastCrc@?1??MouseProc@@9@12@4IA DD 01H DUP (?)		; `MouseProc'::`2'::lastCrc
_BSS	ENDS
;	COMDAT ?dwLastTimer@?1??MouseProc@@9@12@4KA
_BSS	SEGMENT
?dwLastTimer@?1??MouseProc@@9@12@4KA DD 01H DUP (?)	; `MouseProc'::`2'::dwLastTimer
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _MouseProc@12
_TEXT	SEGMENT
_j$81511 = 8						; size = 4
_nCode$ = 8						; size = 4
_dwTimer$81510 = 12					; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
_MouseProc@12 PROC					; COMDAT

; 397  : 	static DWORD dwLastTimer;
; 398  : 	static unsigned __int32 lastCrc, lastCrc2;
; 399  : 	MOUSEHOOKSTRUCT *lpMouse = (MOUSEHOOKSTRUCT *) lParam;
; 400  : 
; 401  : 	if (nCode < 0)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nCode$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	7d 1a		 jge	 SHORT $LN12@MouseProc

; 402  : 		return CallNextHookEx (hMouse, nCode, wParam, lParam);

  00008	8b 4c 24 0c	 mov	 ecx, DWORD PTR _lParam$[esp-4]
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR _wParam$[esp-4]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMouse@@3PAUHHOOK__@@A ; hMouse
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16

; 440  : }

  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN12@MouseProc:
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi

; 403  : 	else
; 404  : 	{
; 405  : 		DWORD dwTimer = GetTickCount ();

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 406  : 		DWORD j = dwLastTimer - dwTimer;

  0002b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?dwLastTimer@?1??MouseProc@@9@12@4KA
  00031	8b 54 24 18	 mov	 edx, DWORD PTR _lParam$[esp+8]
  00035	2b d8		 sub	 ebx, eax

; 407  : 		unsigned __int32 crc = 0L;

  00037	33 f6		 xor	 esi, esi
  00039	89 44 24 14	 mov	 DWORD PTR _dwTimer$81510[esp+8], eax
  0003d	89 5c 24 10	 mov	 DWORD PTR _j$81511[esp+8], ebx

; 408  : 		int i;
; 409  : 
; 410  : 		dwLastTimer = dwTimer;

  00041	a3 00 00 00 00	 mov	 DWORD PTR ?dwLastTimer@?1??MouseProc@@9@12@4KA, eax
  00046	42		 inc	 edx
  00047	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0004a	55		 push	 ebp
  0004b	eb 03 8d 49 00	 npad	 5
$LL10@MouseProc:

; 411  : 
; 412  : 		for (i = 0; i < sizeof (MOUSEHOOKSTRUCT); i++)
; 413  : 		{
; 414  : 			crc = UPDC32 (((unsigned char *) lpMouse)[i], crc);

  00050	0f b6 6a ff	 movzx	 ebp, BYTE PTR [edx-1]
  00054	33 ee		 xor	 ebp, esi
  00056	8b ce		 mov	 ecx, esi
  00058	0f b6 32	 movzx	 esi, BYTE PTR [edx]
  0005b	c1 e9 08	 shr	 ecx, 8
  0005e	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  00064	33 0c ad 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[ebp*4]
  0006b	83 c2 05	 add	 edx, 5
  0006e	33 f1		 xor	 esi, ecx
  00070	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00076	c1 e9 08	 shr	 ecx, 8
  00079	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  00080	0f b6 72 fc	 movzx	 esi, BYTE PTR [edx-4]
  00084	33 f1		 xor	 esi, ecx
  00086	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  0008c	c1 e9 08	 shr	 ecx, 8
  0008f	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  00096	0f b6 72 fd	 movzx	 esi, BYTE PTR [edx-3]
  0009a	33 f1		 xor	 esi, ecx
  0009c	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  000a2	c1 e9 08	 shr	 ecx, 8
  000a5	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  000ac	0f b6 72 fe	 movzx	 esi, BYTE PTR [edx-2]
  000b0	33 f1		 xor	 esi, ecx
  000b2	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  000b8	c1 e9 08	 shr	 ecx, 8
  000bb	33 0c b5 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[esi*4]
  000c2	83 ef 01	 sub	 edi, 1
  000c5	8b f1		 mov	 esi, ecx
  000c7	75 87		 jne	 SHORT $LL10@MouseProc
  000c9	5d		 pop	 ebp

; 415  : 		}
; 416  : 
; 417  : 		if (crc != lastCrc && crc != lastCrc2)

  000ca	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lastCrc@?1??MouseProc@@9@12@4IA
  000d0	0f 84 d2 00 00
	00		 je	 $LN7@MouseProc
  000d6	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lastCrc2@?1??MouseProc@@9@12@4IA
  000dc	0f 84 c6 00 00
	00		 je	 $LN7@MouseProc

; 418  : 		{
; 419  : 			unsigned __int32 timeCrc = 0L;
; 420  : 
; 421  : 			for (i = 0; i < 4; i++)
; 422  : 			{
; 423  : 				timeCrc = UPDC32 (((unsigned char *) &j)[i], timeCrc);

  000e2	0f b6 cb	 movzx	 ecx, bl
  000e5	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _crc_32_tab[ecx*4]
  000ec	0f b6 d7	 movzx	 edx, bh
  000ef	33 d1		 xor	 edx, ecx
  000f1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000f7	c1 e9 08	 shr	 ecx, 8
  000fa	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00101	0f b6 54 24 12	 movzx	 edx, BYTE PTR _j$81511[esp+10]
  00106	33 d1		 xor	 edx, ecx
  00108	c1 e9 08	 shr	 ecx, 8
  0010b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00111	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00118	0f b6 54 24 13	 movzx	 edx, BYTE PTR _j$81511[esp+11]
  0011d	33 d1		 xor	 edx, ecx
  0011f	c1 e9 08	 shr	 ecx, 8
  00122	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00128	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]

; 424  : 			}
; 425  : 
; 426  : 			for (i = 0; i < 4; i++)
; 427  : 			{
; 428  : 				timeCrc = UPDC32 (((unsigned char *) &dwTimer)[i], timeCrc);

  0012f	0f b6 d0	 movzx	 edx, al
  00132	33 d1		 xor	 edx, ecx
  00134	c1 e9 08	 shr	 ecx, 8
  00137	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0013d	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00144	0f b6 54 24 16	 movzx	 edx, BYTE PTR _dwTimer$81510[esp+10]
  00149	0f b6 c4	 movzx	 eax, ah
  0014c	33 c1		 xor	 eax, ecx
  0014e	c1 e9 08	 shr	 ecx, 8
  00151	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00156	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]
  0015d	0f b6 44 24 17	 movzx	 eax, BYTE PTR _dwTimer$81510[esp+11]
  00162	33 d1		 xor	 edx, ecx
  00164	c1 e9 08	 shr	 ecx, 8
  00167	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0016d	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]

; 429  : 			}
; 430  : 
; 431  : 			EnterCriticalSection (&critRandProt);

  00174	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00179	33 c1		 xor	 eax, ecx
  0017b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00180	c1 e9 08	 shr	 ecx, 8
  00183	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]
  0018a	8b f9		 mov	 edi, ecx
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 432  : 			RandaddInt32 ((unsigned __int32) (crc + timeCrc));

  00192	03 fe		 add	 edi, esi
  00194	57		 push	 edi
  00195	e8 00 00 00 00	 call	 _RandAddInt
  0019a	83 c4 04	 add	 esp, 4

; 433  : 			LeaveCriticalSection (&critRandProt);

  0019d	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN7@MouseProc:

; 434  : 		}
; 435  : 		lastCrc2 = lastCrc;

  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lastCrc@?1??MouseProc@@9@12@4IA
  001ae	5f		 pop	 edi

; 436  : 		lastCrc = crc;

  001af	89 35 00 00 00
	00		 mov	 DWORD PTR ?lastCrc@?1??MouseProc@@9@12@4IA, esi
  001b5	5e		 pop	 esi
  001b6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastCrc2@?1??MouseProc@@9@12@4IA, ecx

; 437  : 
; 438  : 	}
; 439  : 	return 0;

  001bc	33 c0		 xor	 eax, eax
  001be	5b		 pop	 ebx

; 440  : }

  001bf	c2 0c 00	 ret	 12			; 0000000cH
_MouseProc@12 ENDP
_TEXT	ENDS
PUBLIC	_KeyboardProc@12
EXTRN	_crc32int:PROC
;	COMDAT ?dwLastTimer@?1??KeyboardProc@@9@12@4KA
_BSS	SEGMENT
?dwLastTimer@?1??KeyboardProc@@9@12@4KA DD 01H DUP (?)	; `KeyboardProc'::`2'::dwLastTimer
_BSS	ENDS
;	COMDAT ?lLastKey2@?1??KeyboardProc@@9@12@4HA
_BSS	SEGMENT
?lLastKey2@?1??KeyboardProc@@9@12@4HA DD 01H DUP (?)	; `KeyboardProc'::`2'::lLastKey2
_BSS	ENDS
;	COMDAT ?lLastKey@?1??KeyboardProc@@9@12@4HA
_BSS	SEGMENT
?lLastKey@?1??KeyboardProc@@9@12@4HA DD 01H DUP (?)	; `KeyboardProc'::`2'::lLastKey
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _KeyboardProc@12
_TEXT	SEGMENT
_dwTimer$81562 = -4					; size = 4
_j$81563 = 8						; size = 4
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
_KeyboardProc@12 PROC					; COMDAT

; 448  : {

  00000	51		 push	 ecx

; 449  : 	static int lLastKey, lLastKey2;
; 450  : 	static DWORD dwLastTimer;
; 451  : 	int nKey = (lParam & 0x00ff0000) >> 16;

  00001	8b 44 24 10	 mov	 eax, DWORD PTR _lParam$[esp]
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax
  00008	c1 fe 10	 sar	 esi, 16			; 00000010H
  0000b	57		 push	 edi

; 452  : 	int nCapture = 0;
; 453  : 
; 454  : 	if (nCode < 0)

  0000c	8b 7c 24 10	 mov	 edi, DWORD PTR _nCode$[esp+8]
  00010	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00016	85 ff		 test	 edi, edi
  00018	7d 1a		 jge	 SHORT $LN12@KeyboardPr

; 455  : 		return CallNextHookEx (hMouse, nCode, wParam, lParam);

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hMouse@@3PAUHHOOK__@@A ; hMouse
  00020	50		 push	 eax
  00021	8b 44 24 18	 mov	 eax, DWORD PTR _wParam$[esp+12]
  00025	50		 push	 eax
  00026	57		 push	 edi
  00027	51		 push	 ecx

; 489  : 	}
; 490  : 
; 491  : 	return CallNextHookEx (hMouse, nCode, wParam, lParam);

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 492  : }

  00030	59		 pop	 ecx
  00031	c2 0c 00	 ret	 12			; 0000000cH
$LN12@KeyboardPr:

; 456  : 
; 457  : 	if ((lParam & 0x0000ffff) == 1 && !(lParam & 0x20000000) &&
; 458  : 	    (lParam & 0x80000000))

  00034	8b d0		 mov	 edx, eax
  00036	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0003c	83 fa 01	 cmp	 edx, 1
  0003f	0f 85 28 01 00
	00		 jne	 $LN7@KeyboardPr
  00045	a9 00 00 00 20	 test	 eax, 536870912		; 20000000H
  0004a	0f 85 1d 01 00
	00		 jne	 $LN7@KeyboardPr
  00050	85 c0		 test	 eax, eax
  00052	0f 89 15 01 00
	00		 jns	 $LN7@KeyboardPr

; 459  : 	{
; 460  : 		if (nKey != lLastKey)

  00058	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lLastKey@?1??KeyboardProc@@9@12@4HA

; 461  : 			nCapture = 1;	/* Capture this key */

  0005e	75 0c		 jne	 SHORT $LN27@KeyboardPr

; 462  : 		else if (nKey != lLastKey2)

  00060	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?lLastKey2@?1??KeyboardProc@@9@12@4HA
  00066	0f 84 01 01 00
	00		 je	 $LN7@KeyboardPr
$LN27@KeyboardPr:

; 463  : 			nCapture = 1;	/* Allow for one repeat */
; 464  : 	}
; 465  : 	if (nCapture)
; 466  : 	{
; 467  : 		DWORD dwTimer = GetTickCount ();

  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 468  : 		DWORD j = dwLastTimer - dwTimer;

  00072	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwLastTimer@?1??KeyboardProc@@9@12@4KA

; 469  : 		unsigned __int32 timeCrc = 0L;
; 470  : 		int i;
; 471  : 
; 472  : 		dwLastTimer = dwTimer;
; 473  : 		lLastKey2 = lLastKey;

  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lLastKey@?1??KeyboardProc@@9@12@4HA
  0007e	2b d0		 sub	 edx, eax
  00080	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lLastKey2@?1??KeyboardProc@@9@12@4HA, ecx

; 474  : 		lLastKey = nKey;
; 475  : 
; 476  : 		for (i = 0; i < 4; i++)
; 477  : 		{
; 478  : 			timeCrc = UPDC32 (((unsigned char *) &j)[i], timeCrc);

  00086	0f b6 ca	 movzx	 ecx, dl
  00089	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _crc_32_tab[ecx*4]
  00090	89 54 24 10	 mov	 DWORD PTR _j$81563[esp+8], edx
  00094	0f b6 d6	 movzx	 edx, dh
  00097	33 d1		 xor	 edx, ecx
  00099	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0009f	c1 e9 08	 shr	 ecx, 8
  000a2	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  000a9	0f b6 54 24 12	 movzx	 edx, BYTE PTR _j$81563[esp+10]
  000ae	33 d1		 xor	 edx, ecx
  000b0	c1 e9 08	 shr	 ecx, 8
  000b3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b9	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  000c0	0f b6 54 24 13	 movzx	 edx, BYTE PTR _j$81563[esp+11]
  000c5	33 d1		 xor	 edx, ecx
  000c7	c1 e9 08	 shr	 ecx, 8
  000ca	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000d0	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]

; 479  : 		}
; 480  : 
; 481  : 		for (i = 0; i < 4; i++)
; 482  : 		{
; 483  : 			timeCrc = UPDC32 (((unsigned char *) &dwTimer)[i], timeCrc);

  000d7	0f b6 d0	 movzx	 edx, al
  000da	33 d1		 xor	 edx, ecx
  000dc	89 44 24 08	 mov	 DWORD PTR _dwTimer$81562[esp+12], eax
  000e0	c1 e9 08	 shr	 ecx, 8
  000e3	a3 00 00 00 00	 mov	 DWORD PTR ?dwLastTimer@?1??KeyboardProc@@9@12@4KA, eax
  000e8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000ee	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  000f5	0f b6 54 24 0a	 movzx	 edx, BYTE PTR _dwTimer$81562[esp+14]
  000fa	0f b6 c4	 movzx	 eax, ah
  000fd	33 c1		 xor	 eax, ecx
  000ff	c1 e9 08	 shr	 ecx, 8
  00102	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00107	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]
  0010e	0f b6 44 24 0b	 movzx	 eax, BYTE PTR _dwTimer$81562[esp+15]
  00113	33 d1		 xor	 edx, ecx
  00115	c1 e9 08	 shr	 ecx, 8
  00118	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0011e	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[edx*4]
  00125	89 35 00 00 00
	00		 mov	 DWORD PTR ?lLastKey@?1??KeyboardProc@@9@12@4HA, esi
  0012b	33 c1		 xor	 eax, ecx
  0012d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00132	c1 e9 08	 shr	 ecx, 8
  00135	33 0c 85 00 00
	00 00		 xor	 ecx, DWORD PTR _crc_32_tab[eax*4]

; 484  : 		}
; 485  : 
; 486  : 		EnterCriticalSection (&critRandProt);

  0013c	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00141	8b f1		 mov	 esi, ecx
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 487  : 		RandaddInt32 ((unsigned __int32) (crc32int((unsigned int *)&lParam) + timeCrc));

  00149	8d 4c 24 18	 lea	 ecx, DWORD PTR _lParam$[esp+8]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 _crc32int
  00153	03 c6		 add	 eax, esi
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _RandAddInt
  0015b	83 c4 08	 add	 esp, 8

; 488  : 		LeaveCriticalSection (&critRandProt);

  0015e	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00169	8b 44 24 18	 mov	 eax, DWORD PTR _lParam$[esp+8]
$LN7@KeyboardPr:

; 489  : 	}
; 490  : 
; 491  : 	return CallNextHookEx (hMouse, nCode, wParam, lParam);

  0016d	8b 54 24 14	 mov	 edx, DWORD PTR _wParam$[esp+8]
  00171	50		 push	 eax
  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hMouse@@3PAUHHOOK__@@A ; hMouse
  00177	52		 push	 edx
  00178	57		 push	 edi
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallNextHookEx@16
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi

; 492  : }

  00182	59		 pop	 ecx
  00183	c2 0c 00	 ret	 12			; 0000000cH
_KeyboardProc@12 ENDP
_TEXT	ENDS
PUBLIC	_FastPoll
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__GetStartupInfoA@4:PROC
EXTRN	__imp__GetProcessWorkingSetSize@12:PROC
EXTRN	__imp__GetProcessTimes@20:PROC
EXTRN	__imp__GetThreadTimes@20:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__GetCaretPos@4:PROC
EXTRN	__imp__GetQueueStatus@4:PROC
EXTRN	__imp__GetProcessWindowStation@0:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__GetOpenClipboardWindow@0:PROC
EXTRN	__imp__GetMessageTime@0:PROC
EXTRN	__imp__GetMessagePos@0:PROC
EXTRN	__imp__GetInputState@0:PROC
EXTRN	__imp__GetFocus@0:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetClipboardViewer@0:PROC
EXTRN	__imp__GetClipboardOwner@0:PROC
EXTRN	__imp__GetCapture@0:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
;	COMDAT ?addedFixedItems@?1??FastPoll@@9@4HA
_BSS	SEGMENT
?addedFixedItems@?1??FastPoll@@9@4HA DD 01H DUP (?)	; `FastPoll'::`2'::addedFixedItems
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _FastPoll
_TEXT	SEGMENT
_exitTime$ = -164					; size = 8
_minimumWorkingSetSize$ = -156				; size = 4
_kernelTime$ = -152					; size = 8
_dwTicks$81747 = -144					; size = 4
_userTime$ = -140					; size = 8
_creationTime$ = -132					; size = 8
_point$ = -124						; size = 8
_maximumWorkingSetSize$ = -116				; size = 4
_performanceCount$ = -112				; size = 8
_memoryStatus$ = -104					; size = 32
_startupInfo$81739 = -72				; size = 68
_FastPoll PROC						; COMDAT

; 657  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0000c	53		 push	 ebx
  0000d	55		 push	 ebp

; 658  : 	int nOriginalRandIndex = nRandIndex;

  0000e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _nRandIndex
  00014	56		 push	 esi
  00015	57		 push	 edi

; 659  : 	static BOOL addedFixedItems = FALSE;
; 660  : 	FILETIME creationTime, exitTime, kernelTime, userTime;
; 661  : 	DWORD minimumWorkingSetSize, maximumWorkingSetSize;
; 662  : 	LARGE_INTEGER performanceCount;
; 663  : 	MEMORYSTATUS memoryStatus;
; 664  : 	HANDLE handle;
; 665  : 	POINT point;
; 666  : 
; 667  : 	/* Get various basic pieces of system information */
; 668  : 	RandaddInt32 (GetActiveWindow ());	/* Handle of active window */

  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _RandAddInt
  00022	83 c4 04	 add	 esp, 4

; 669  : 	RandaddInt32 (GetCapture ());	/* Handle of window with mouse

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCapture@0
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _RandAddInt
  00031	83 c4 04	 add	 esp, 4

; 670  : 					   capture */
; 671  : 	RandaddInt32 (GetClipboardOwner ());	/* Handle of clipboard owner */

  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardOwner@0
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _RandAddInt
  00040	83 c4 04	 add	 esp, 4

; 672  : 	RandaddInt32 (GetClipboardViewer ());	/* Handle of start of

  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardViewer@0
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _RandAddInt

; 673  : 						   clpbd.viewer list */
; 674  : 	RandaddInt32 (GetCurrentProcess ());	/* Pseudohandle of current

  0004f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetCurrentProcess@0
  00055	83 c4 04	 add	 esp, 4
  00058	ff d6		 call	 esi
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _RandAddInt
  00060	83 c4 04	 add	 esp, 4

; 675  : 						   process */
; 676  : 	RandaddInt32 (GetCurrentProcessId ());	/* Current process ID */

  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _RandAddInt

; 677  : 	RandaddInt32 (GetCurrentThread ());	/* Pseudohandle of current

  0006f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetCurrentThread@0
  00075	83 c4 04	 add	 esp, 4
  00078	ff d7		 call	 edi
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _RandAddInt
  00080	83 c4 04	 add	 esp, 4

; 678  : 						   thread */
; 679  : 	RandaddInt32 (GetCurrentThreadId ());	/* Current thread ID */

  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _RandAddInt

; 680  : 	RandaddInt32 (GetCurrentTime ());	/* Milliseconds since Windows

  0008f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00095	83 c4 04	 add	 esp, 4
  00098	ff d3		 call	 ebx
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _RandAddInt
  000a0	83 c4 04	 add	 esp, 4

; 681  : 						   started */
; 682  : 	RandaddInt32 (GetDesktopWindow ());	/* Handle of desktop window */

  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDesktopWindow@0
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _RandAddInt
  000af	83 c4 04	 add	 esp, 4

; 683  : 	RandaddInt32 (GetFocus ());	/* Handle of window with kb.focus */

  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _RandAddInt
  000be	83 c4 04	 add	 esp, 4

; 684  : 	RandaddInt32 (GetInputState ());	/* Whether sys.queue has any events */

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetInputState@0
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _RandAddInt
  000cd	83 c4 04	 add	 esp, 4

; 685  : 	RandaddInt32 (GetMessagePos ());	/* Cursor pos.for last message */

  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _RandAddInt
  000dc	83 c4 04	 add	 esp, 4

; 686  : 	RandaddInt32 (GetMessageTime ());	/* 1 ms time for last message */

  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageTime@0
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _RandAddInt
  000eb	83 c4 04	 add	 esp, 4

; 687  : 	RandaddInt32 (GetOpenClipboardWindow ());	/* Handle of window with

  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetOpenClipboardWindow@0
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _RandAddInt
  000fa	83 c4 04	 add	 esp, 4

; 688  : 							   clpbd.open */
; 689  : 	RandaddInt32 (GetProcessHeap ());	/* Handle of process heap */

  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _RandAddInt
  00109	83 c4 04	 add	 esp, 4

; 690  : 	RandaddInt32 (GetProcessWindowStation ());	/* Handle of procs

  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWindowStation@0
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _RandAddInt
  00118	83 c4 04	 add	 esp, 4

; 691  : 							   window station */
; 692  : 	RandaddInt32 (GetQueueStatus (QS_ALLEVENTS));	/* Types of events in

  0011b	68 bf 04 00 00	 push	 1215			; 000004bfH
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueueStatus@4
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _RandAddInt
  0012c	83 c4 04	 add	 esp, 4

; 693  : 							   input queue */
; 694  : 
; 695  : 	/* Get multiword system information */
; 696  : 	GetCaretPos (&point);	/* Current caret position */

  0012f	8d 44 24 3c	 lea	 eax, DWORD PTR _point$[esp+184]
  00133	50		 push	 eax
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCaretPos@4

; 697  : 	RandaddBuf ((unsigned char *) &point, sizeof (POINT));

  0013a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _point$[esp+184]
  0013e	6a 08		 push	 8
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _RandaddBuf
  00146	83 c4 08	 add	 esp, 8

; 698  : 	GetCursorPos (&point);	/* Current mouse cursor position */

  00149	8d 54 24 3c	 lea	 edx, DWORD PTR _point$[esp+184]
  0014d	52		 push	 edx
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4

; 699  : 	RandaddBuf ((unsigned char *) &point, sizeof (POINT));

  00154	8d 44 24 3c	 lea	 eax, DWORD PTR _point$[esp+184]
  00158	6a 08		 push	 8
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _RandaddBuf
  00160	83 c4 08	 add	 esp, 8

; 700  : 
; 701  : 	/* Get percent of memory in use, bytes of physical memory, bytes of
; 702  : 	   free physical memory, bytes in paging file, free bytes in paging
; 703  : 	   file, user bytes of address space, and free user bytes */
; 704  : 	memoryStatus.dwLength = sizeof (MEMORYSTATUS);
; 705  : 	GlobalMemoryStatus (&memoryStatus);

  00163	8d 4c 24 50	 lea	 ecx, DWORD PTR _memoryStatus$[esp+184]
  00167	51		 push	 ecx
  00168	c7 44 24 54 20
	00 00 00	 mov	 DWORD PTR _memoryStatus$[esp+188], 32 ; 00000020H
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4

; 706  : 	RandaddBuf ((unsigned char *) &memoryStatus, sizeof (MEMORYSTATUS));

  00176	8d 54 24 50	 lea	 edx, DWORD PTR _memoryStatus$[esp+184]
  0017a	6a 20		 push	 32			; 00000020H
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _RandaddBuf
  00182	83 c4 08	 add	 esp, 8

; 707  : 
; 708  : 	/* Get thread and process creation time, exit time, time in kernel
; 709  : 	   mode, and time in user mode in 100ns intervals */
; 710  : 	handle = GetCurrentThread ();

  00185	ff d7		 call	 edi

; 711  : 	GetThreadTimes (handle, &creationTime, &exitTime, &kernelTime, &userTime);

  00187	8d 4c 24 2c	 lea	 ecx, DWORD PTR _userTime$[esp+184]
  0018b	51		 push	 ecx
  0018c	8d 54 24 24	 lea	 edx, DWORD PTR _kernelTime$[esp+188]
  00190	52		 push	 edx
  00191	8d 4c 24 1c	 lea	 ecx, DWORD PTR _exitTime$[esp+192]
  00195	51		 push	 ecx
  00196	8d 54 24 40	 lea	 edx, DWORD PTR _creationTime$[esp+196]
  0019a	52		 push	 edx
  0019b	50		 push	 eax
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadTimes@20

; 712  : 	RandaddBuf ((unsigned char *) &creationTime, sizeof (FILETIME));

  001a2	8d 44 24 34	 lea	 eax, DWORD PTR _creationTime$[esp+184]
  001a6	6a 08		 push	 8
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _RandaddBuf

; 713  : 	RandaddBuf ((unsigned char *) &exitTime, sizeof (FILETIME));

  001ae	8d 4c 24 1c	 lea	 ecx, DWORD PTR _exitTime$[esp+192]
  001b2	6a 08		 push	 8
  001b4	51		 push	 ecx
  001b5	e8 00 00 00 00	 call	 _RandaddBuf

; 714  : 	RandaddBuf ((unsigned char *) &kernelTime, sizeof (FILETIME));

  001ba	8d 54 24 30	 lea	 edx, DWORD PTR _kernelTime$[esp+200]
  001be	6a 08		 push	 8
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 _RandaddBuf

; 715  : 	RandaddBuf ((unsigned char *) &userTime, sizeof (FILETIME));

  001c6	8d 44 24 44	 lea	 eax, DWORD PTR _userTime$[esp+208]
  001ca	6a 08		 push	 8
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _RandaddBuf
  001d2	83 c4 20	 add	 esp, 32			; 00000020H

; 716  : 	handle = GetCurrentProcess ();

  001d5	ff d6		 call	 esi

; 717  : 	GetProcessTimes (handle, &creationTime, &exitTime, &kernelTime, &userTime);

  001d7	8d 4c 24 2c	 lea	 ecx, DWORD PTR _userTime$[esp+184]
  001db	51		 push	 ecx
  001dc	8b f0		 mov	 esi, eax
  001de	8d 54 24 24	 lea	 edx, DWORD PTR _kernelTime$[esp+188]
  001e2	52		 push	 edx
  001e3	8d 44 24 1c	 lea	 eax, DWORD PTR _exitTime$[esp+192]
  001e7	50		 push	 eax
  001e8	8d 4c 24 40	 lea	 ecx, DWORD PTR _creationTime$[esp+196]
  001ec	51		 push	 ecx
  001ed	56		 push	 esi
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessTimes@20

; 718  : 	RandaddBuf ((unsigned char *) &creationTime, sizeof (FILETIME));

  001f4	8d 54 24 34	 lea	 edx, DWORD PTR _creationTime$[esp+184]
  001f8	6a 08		 push	 8
  001fa	52		 push	 edx
  001fb	e8 00 00 00 00	 call	 _RandaddBuf

; 719  : 	RandaddBuf ((unsigned char *) &exitTime, sizeof (FILETIME));

  00200	8d 44 24 1c	 lea	 eax, DWORD PTR _exitTime$[esp+192]
  00204	6a 08		 push	 8
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 _RandaddBuf

; 720  : 	RandaddBuf ((unsigned char *) &kernelTime, sizeof (FILETIME));

  0020c	8d 4c 24 30	 lea	 ecx, DWORD PTR _kernelTime$[esp+200]
  00210	6a 08		 push	 8
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 _RandaddBuf

; 721  : 	RandaddBuf ((unsigned char *) &userTime, sizeof (FILETIME));

  00218	8d 54 24 44	 lea	 edx, DWORD PTR _userTime$[esp+208]
  0021c	6a 08		 push	 8
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 _RandaddBuf
  00224	83 c4 20	 add	 esp, 32			; 00000020H

; 722  : 
; 723  : 	/* Get the minimum and maximum working set size for the current
; 724  : 	   process */
; 725  : 	GetProcessWorkingSetSize (handle, &minimumWorkingSetSize,
; 726  : 				  &maximumWorkingSetSize);

  00227	8d 44 24 44	 lea	 eax, DWORD PTR _maximumWorkingSetSize$[esp+184]
  0022b	50		 push	 eax
  0022c	8d 4c 24 20	 lea	 ecx, DWORD PTR _minimumWorkingSetSize$[esp+188]
  00230	51		 push	 ecx
  00231	56		 push	 esi
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessWorkingSetSize@12

; 727  : 	RandaddInt32 (minimumWorkingSetSize);

  00238	8b 54 24 1c	 mov	 edx, DWORD PTR _minimumWorkingSetSize$[esp+184]
  0023c	52		 push	 edx
  0023d	e8 00 00 00 00	 call	 _RandAddInt

; 728  : 	RandaddInt32 (maximumWorkingSetSize);

  00242	8b 44 24 48	 mov	 eax, DWORD PTR _maximumWorkingSetSize$[esp+188]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 _RandAddInt
  0024c	83 c4 08	 add	 esp, 8

; 729  : 
; 730  : 	/* The following are fixed for the lifetime of the process so we only
; 731  : 	   add them once */
; 732  : 	if (addedFixedItems == 0)

  0024f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@4HA, 0
  00256	75 2c		 jne	 SHORT $LN4@FastPoll

; 733  : 	{
; 734  : 		STARTUPINFO startupInfo;
; 735  : 
; 736  : 		/* Get name of desktop, console window title, new window
; 737  : 		   position and size, window flags, and handles for stdin,
; 738  : 		   stdout, and stderr */
; 739  : 		startupInfo.cb = sizeof (STARTUPINFO);
; 740  : 		GetStartupInfo (&startupInfo);

  00258	8d 4c 24 70	 lea	 ecx, DWORD PTR _startupInfo$81739[esp+184]
  0025c	51		 push	 ecx
  0025d	c7 44 24 74 44
	00 00 00	 mov	 DWORD PTR _startupInfo$81739[esp+188], 68 ; 00000044H
  00265	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStartupInfoA@4

; 741  : 		RandaddBuf ((unsigned char *) &startupInfo, sizeof (STARTUPINFO));

  0026b	8d 54 24 70	 lea	 edx, DWORD PTR _startupInfo$81739[esp+184]
  0026f	6a 44		 push	 68			; 00000044H
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 _RandaddBuf
  00277	83 c4 08	 add	 esp, 8

; 742  : 		addedFixedItems = TRUE;

  0027a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?addedFixedItems@?1??FastPoll@@9@4HA, 1
$LN4@FastPoll:

; 743  : 	}
; 744  : 	/* The docs say QPC can fail if appropriate hardware is not
; 745  : 	   available. It works on 486 & Pentium boxes, but hasn't been tested
; 746  : 	   for 386 or RISC boxes */
; 747  : 	if (QueryPerformanceCounter (&performanceCount))

  00284	8d 44 24 48	 lea	 eax, DWORD PTR _performanceCount$[esp+184]
  00288	50		 push	 eax
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0028f	85 c0		 test	 eax, eax
  00291	74 09		 je	 SHORT $LN3@FastPoll

; 748  : 		RandaddBuf ((unsigned char *) &performanceCount, sizeof (LARGE_INTEGER));

  00293	6a 08		 push	 8
  00295	8d 4c 24 4c	 lea	 ecx, DWORD PTR _performanceCount$[esp+188]
  00299	51		 push	 ecx

; 749  : 	else

  0029a	eb 0d		 jmp	 SHORT $LN7@FastPoll
$LN3@FastPoll:

; 750  : 	{
; 751  : 		/* Millisecond accuracy at best... */
; 752  : 		DWORD dwTicks = GetTickCount ();

  0029c	ff d3		 call	 ebx

; 753  : 		RandaddBuf ((unsigned char *) &dwTicks, sizeof (dwTicks));

  0029e	6a 04		 push	 4
  002a0	8d 54 24 2c	 lea	 edx, DWORD PTR _dwTicks$81747[esp+188]
  002a4	89 44 24 2c	 mov	 DWORD PTR _dwTicks$81747[esp+188], eax
  002a8	52		 push	 edx
$LN7@FastPoll:
  002a9	e8 00 00 00 00	 call	 _RandaddBuf
  002ae	83 c4 08	 add	 esp, 8

; 754  : 	}
; 755  : 
; 756  : 	// CryptoAPI
; 757  : 	if (CryptoAPIAvailable && CryptGenRandom (hCryptProv, sizeof (buffer), buffer)) 

  002b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?CryptoAPIAvailable@@3HA, 0 ; CryptoAPIAvailable
  002b8	74 2c		 je	 SHORT $LN1@FastPoll
  002ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hCryptProv@@3KA ; hCryptProv
  002bf	68 00 00 00 00	 push	 OFFSET _buffer
  002c4	68 40 01 00 00	 push	 320			; 00000140H
  002c9	50		 push	 eax
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  002d0	85 c0		 test	 eax, eax
  002d2	74 12		 je	 SHORT $LN1@FastPoll

; 758  : 		RandaddBuf (buffer, sizeof (buffer));

  002d4	68 40 01 00 00	 push	 320			; 00000140H
  002d9	68 00 00 00 00	 push	 OFFSET _buffer
  002de	e8 00 00 00 00	 call	 _RandaddBuf
  002e3	83 c4 08	 add	 esp, 8
$LN1@FastPoll:

; 759  : 
; 760  : 	/* Apply the pool mixing function */
; 761  : 	Randmix();

  002e6	e8 00 00 00 00	 call	 _Randmix

; 762  : 
; 763  : 	/* Restore the original pool cursor position. If this wasn't done, mouse coordinates
; 764  : 	   could be written to a limited area of the pool, especially when moving the mouse
; 765  : 	   uninterruptedly. The severity of the problem would depend on the length of data
; 766  : 	   written by FastPoll (if it was equal to the size of the pool, mouse coordinates
; 767  : 	   would be written only to a particular 4-byte area, whenever moving the mouse
; 768  : 	   uninterruptedly). */
; 769  : 	nRandIndex = nOriginalRandIndex;
; 770  : 
; 771  : 	return TRUE;
; 772  : }

  002eb	5f		 pop	 edi
  002ec	89 2d 00 00 00
	00		 mov	 DWORD PTR _nRandIndex, ebp
  002f2	b8 01 00 00 00	 mov	 eax, 1
  002f7	5e		 pop	 esi
  002f8	5d		 pop	 ebp
  002f9	5b		 pop	 ebx
  002fa	8b e5		 mov	 esp, ebp
  002fc	5d		 pop	 ebp
  002fd	c3		 ret	 0
_FastPoll ENDP
_TEXT	ENDS
PUBLIC	_RandgetBytes
; Function compile flags: /Ogtpy
;	COMDAT _RandgetBytes
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_forceSlowPoll$ = 16					; size = 4
_RandgetBytes PROC					; COMDAT

; 329  : 	int i;
; 330  : 	BOOL ret = TRUE;
; 331  : 
; 332  : 	if (!bRandDidInit || HashFunction == 0)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	bb 01 00 00 00	 mov	 ebx, 1
  0000e	74 09		 je	 SHORT $LN20@RandgetByt
  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _HashFunction, 0
  00017	75 07		 jne	 SHORT $LN21@RandgetByt
$LN20@RandgetByt:

; 333  : 		TC_THROW_FATAL_EXCEPTION;

  00019	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN21@RandgetByt:

; 334  : 
; 335  : 	EnterCriticalSection (&critRandProt);

  00020	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 336  : 
; 337  : 	if (bDidSlowPoll == FALSE || forceSlowPoll)

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDidSlowPoll, 0
  00032	74 07		 je	 SHORT $LN18@RandgetByt
  00034	83 7c 24 14 00	 cmp	 DWORD PTR _forceSlowPoll$[esp+4], 0
  00039	74 13		 je	 SHORT $LN16@RandgetByt
$LN18@RandgetByt:

; 338  : 	{
; 339  : 		if (!SlowPoll ())

  0003b	e8 00 00 00 00	 call	 _SlowPoll
  00040	85 c0		 test	 eax, eax
  00042	75 04		 jne	 SHORT $LN17@RandgetByt

; 340  : 			ret = FALSE;

  00044	33 db		 xor	 ebx, ebx

; 341  : 		else

  00046	eb 06		 jmp	 SHORT $LN16@RandgetByt
$LN17@RandgetByt:

; 342  : 			bDidSlowPoll = TRUE;

  00048	89 1d 00 00 00
	00		 mov	 DWORD PTR _bDidSlowPoll, ebx
$LN16@RandgetByt:

; 343  : 	}
; 344  : 
; 345  : 	if (!FastPoll ())

  0004e	e8 00 00 00 00	 call	 _FastPoll
  00053	85 c0		 test	 eax, eax
  00055	75 02		 jne	 SHORT $LN15@RandgetByt

; 346  : 		ret = FALSE;

  00057	33 db		 xor	 ebx, ebx
$LN15@RandgetByt:

; 347  : 
; 348  : 	/* There's never more than RNG_POOL_SIZE worth of randomess */
; 349  : 	if (len > RNG_POOL_SIZE)

  00059	8b 6c 24 10	 mov	 ebp, DWORD PTR _len$[esp+4]
  0005d	81 fd 40 01 00
	00		 cmp	 ebp, 320		; 00000140H
  00063	7e 12		 jle	 SHORT $LN14@RandgetByt

; 350  : 	{
; 351  : 		Error ("ERR_NOT_ENOUGH_RANDOM_DATA");	

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BENPDJPG@ERR_NOT_ENOUGH_RANDOM_DATA?$AA@
  0006a	e8 00 00 00 00	 call	 _Error
  0006f	83 c4 04	 add	 esp, 4
  00072	5d		 pop	 ebp

; 352  : 		len = RNG_POOL_SIZE;
; 353  : 		return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	5b		 pop	 ebx

; 387  : }

  00076	c3		 ret	 0
$LN14@RandgetByt:
  00077	56		 push	 esi

; 354  : 	}
; 355  : 
; 356  : 	// Requested number of bytes is copied from pool to output buffer,
; 357  : 	// pool is rehashed, and output buffer is XORed with new data from pool
; 358  : 	for (i = 0; i < len; i++)

  00078	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  0007e	33 c9		 xor	 ecx, ecx
  00080	57		 push	 edi
  00081	8b 7c 24 14	 mov	 edi, DWORD PTR _buf$[esp+12]
  00085	85 ed		 test	 ebp, ebp
  00087	7e 21		 jle	 SHORT $LN30@RandgetByt
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _randPoolReadIndex
  0008e	8b ff		 npad	 2
$LL13@RandgetByt:

; 359  : 	{
; 360  : 		buf[i] = pRandPool[randPoolReadIndex++];

  00090	8a 14 30	 mov	 dl, BYTE PTR [eax+esi]
  00093	40		 inc	 eax
  00094	88 14 39	 mov	 BYTE PTR [ecx+edi], dl

; 361  : 		if (randPoolReadIndex == RNG_POOL_SIZE) randPoolReadIndex = 0;

  00097	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0009c	75 02		 jne	 SHORT $LN12@RandgetByt
  0009e	33 c0		 xor	 eax, eax
$LN12@RandgetByt:

; 354  : 	}
; 355  : 
; 356  : 	// Requested number of bytes is copied from pool to output buffer,
; 357  : 	// pool is rehashed, and output buffer is XORed with new data from pool
; 358  : 	for (i = 0; i < len; i++)

  000a0	41		 inc	 ecx
  000a1	3b cd		 cmp	 ecx, ebp
  000a3	7c eb		 jl	 SHORT $LL13@RandgetByt

; 359  : 	{
; 360  : 		buf[i] = pRandPool[randPoolReadIndex++];

  000a5	a3 00 00 00 00	 mov	 DWORD PTR _randPoolReadIndex, eax
$LN30@RandgetByt:

; 362  : 	}
; 363  : 
; 364  : 	/* Invert the pool */
; 365  : 	for (i = 0; i < RNG_POOL_SIZE / 4; i++)

  000aa	33 c0		 xor	 eax, eax
  000ac	8d 64 24 00	 npad	 4
$LL9@RandgetByt:

; 366  : 	{
; 367  : 		((unsigned __int32 *) pRandPool)[i] = ~((unsigned __int32 *) pRandPool)[i];

  000b0	8b 0c 86	 mov	 ecx, DWORD PTR [esi+eax*4]
  000b3	f7 d1		 not	 ecx
  000b5	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  000b8	40		 inc	 eax
  000b9	83 f8 50	 cmp	 eax, 80			; 00000050H
  000bc	7c f2		 jl	 SHORT $LL9@RandgetByt

; 368  : 	}
; 369  : 
; 370  : 	// Mix the pool
; 371  : 	if (!FastPoll ())

  000be	e8 00 00 00 00	 call	 _FastPoll
  000c3	85 c0		 test	 eax, eax
  000c5	75 02		 jne	 SHORT $LN31@RandgetByt

; 372  : 		ret = FALSE;

  000c7	33 db		 xor	 ebx, ebx
$LN31@RandgetByt:

; 373  : 
; 374  : 	// XOR the current pool content into the output buffer to prevent pool state leaks
; 375  : 	for (i = 0; i < len; i++)

  000c9	33 c9		 xor	 ecx, ecx
  000cb	85 ed		 test	 ebp, ebp
  000cd	7e 2b		 jle	 SHORT $LN3@RandgetByt
  000cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pRandPool
  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _randPoolReadIndex
  000da	8d 9b 00 00 00
	00		 npad	 6
$LL5@RandgetByt:

; 376  : 	{
; 377  : 		buf[i] ^= pRandPool[randPoolReadIndex++];

  000e0	8a 14 30	 mov	 dl, BYTE PTR [eax+esi]
  000e3	30 14 39	 xor	 BYTE PTR [ecx+edi], dl
  000e6	40		 inc	 eax

; 378  : 		if (randPoolReadIndex == RNG_POOL_SIZE) randPoolReadIndex = 0;

  000e7	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  000ec	75 02		 jne	 SHORT $LN4@RandgetByt
  000ee	33 c0		 xor	 eax, eax
$LN4@RandgetByt:

; 373  : 
; 374  : 	// XOR the current pool content into the output buffer to prevent pool state leaks
; 375  : 	for (i = 0; i < len; i++)

  000f0	41		 inc	 ecx
  000f1	3b cd		 cmp	 ecx, ebp
  000f3	7c eb		 jl	 SHORT $LL5@RandgetByt

; 376  : 	{
; 377  : 		buf[i] ^= pRandPool[randPoolReadIndex++];

  000f5	a3 00 00 00 00	 mov	 DWORD PTR _randPoolReadIndex, eax
$LN3@RandgetByt:

; 379  : 	}
; 380  : 
; 381  : 	LeaveCriticalSection (&critRandProt);

  000fa	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi

; 382  : 
; 383  : 	if (!ret)

  00107	85 db		 test	 ebx, ebx
  00109	75 07		 jne	 SHORT $LN1@RandgetByt

; 384  : 		TC_THROW_FATAL_EXCEPTION;

  0010b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN1@RandgetByt:
  00112	5d		 pop	 ebp

; 385  : 
; 386  : 	return ret;

  00113	8b c3		 mov	 eax, ebx
  00115	5b		 pop	 ebx

; 387  : }

  00116	c3		 ret	 0
_RandgetBytes ENDP
_TEXT	ENDS
EXTRN	__endthreadex:PROC
EXTRN	__imp__Sleep@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _PeriodicFastPollThreadProc@4
_TEXT	SEGMENT
_dummy$ = 8						; size = 4
_PeriodicFastPollThreadProc@4 PROC			; COMDAT

; 496  : {

  00000	53		 push	 ebx
  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnterCriticalSection@4
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LeaveCriticalSection@4
  0000e	57		 push	 edi
  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Sleep@4
$LL5@PeriodicFa:

; 497  : 	for (;;)
; 498  : 	{
; 499  : 		EnterCriticalSection (&critRandProt);

  00015	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  0001a	ff d3		 call	 ebx

; 500  : 
; 501  : 		if (bThreadTerminate)

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bThreadTerminate@@3HC ; bThreadTerminate
  00021	85 c0		 test	 eax, eax
  00023	74 2b		 je	 SHORT $LN3@PeriodicFa

; 502  : 		{
; 503  : 			bThreadTerminate = FALSE;
; 504  : 			LeaveCriticalSection (&critRandProt);

  00025	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bThreadTerminate@@3HC, 0 ; bThreadTerminate
  00034	ff d6		 call	 esi

; 505  : 			_endthreadex (0);

  00036	6a 00		 push	 0
  00038	e8 00 00 00 00	 call	 __endthreadex
  0003d	83 c4 04	 add	 esp, 4

; 510  : 		}
; 511  : 
; 512  : 		LeaveCriticalSection (&critRandProt);

  00040	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00045	ff d6		 call	 esi

; 513  : 
; 514  : 		Sleep (FASTPOLL_INTERVAL);

  00047	68 f4 01 00 00	 push	 500			; 000001f4H
  0004c	ff d7		 call	 edi

; 515  : 	}

  0004e	eb c5		 jmp	 SHORT $LL5@PeriodicFa
$LN3@PeriodicFa:

; 506  : 		}
; 507  : 		else if (bFastPollEnabled)

  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bFastPollEnabled
  00056	85 c9		 test	 ecx, ecx
  00058	74 05		 je	 SHORT $LN1@PeriodicFa

; 508  : 		{
; 509  : 			FastPoll ();

  0005a	e8 00 00 00 00	 call	 _FastPoll
$LN1@PeriodicFa:

; 510  : 		}
; 511  : 
; 512  : 		LeaveCriticalSection (&critRandProt);

  0005f	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00064	ff d6		 call	 esi

; 513  : 
; 514  : 		Sleep (FASTPOLL_INTERVAL);

  00066	68 f4 01 00 00	 push	 500			; 000001f4H
  0006b	ff d7		 call	 edi

; 515  : 	}

  0006d	eb a6		 jmp	 SHORT $LL5@PeriodicFa
_PeriodicFastPollThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_Randinit
EXTRN	__beginthreadex:PROC
EXTRN	__imp__CryptAcquireContextA@20:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	__imp__SetWindowsHookExA@16:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Randinit
_TEXT	SEGMENT
_Randinit PROC						; COMDAT

; 71   : 	if (GetMaxPkcs5OutSize() > RNG_POOL_SIZE)

  00000	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00005	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0000a	7e 07		 jle	 SHORT $LN12@Randinit

; 72   : 		TC_THROW_FATAL_EXCEPTION;

  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN12@Randinit:

; 73   : 
; 74   : 	if(bRandDidInit) 

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bRandDidInit, 0
  0001a	74 03		 je	 SHORT $LN11@Randinit

; 75   : 		return 0;

  0001c	33 c0		 xor	 eax, eax

; 118  : }

  0001e	c3		 ret	 0
$LN11@Randinit:
  0001f	56		 push	 esi

; 76   : 
; 77   : 	InitializeCriticalSection (&critRandProt);

  00020	68 00 00 00 00	 push	 OFFSET ?critRandProt@@3U_RTL_CRITICAL_SECTION@@A ; critRandProt
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 78   : 
; 79   : 	bRandDidInit = TRUE;
; 80   : 
; 81   : 	if (pRandPool == NULL)

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pRandPool, 0
  00032	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bRandDidInit, 1
  0003c	75 4d		 jne	 SHORT $LN10@Randinit

; 82   : 	{
; 83   : 		pRandPool = (unsigned char *) TCalloc (RANDOMPOOL_ALLOCSIZE);

  0003e	68 40 01 00 00	 push	 320			; 00000140H
  00043	e8 00 00 00 00	 call	 _malloc
  00048	8b f0		 mov	 esi, eax
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 35 00 00 00
	00		 mov	 DWORD PTR _pRandPool, esi

; 84   : 		if (pRandPool == NULL)

  00053	85 f6		 test	 esi, esi
  00055	0f 84 f0 00 00
	00		 je	 $error$81313

; 85   : 			goto error;
; 86   : 
; 87   : 		bDidSlowPoll = FALSE;
; 88   : 		RandomPoolEnrichedByUser = FALSE;
; 89   : 
; 90   : 		memset (pRandPool, 0, RANDOMPOOL_ALLOCSIZE);

  0005b	68 40 01 00 00	 push	 320			; 00000140H
  00060	6a 00		 push	 0
  00062	56		 push	 esi
  00063	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDidSlowPoll, 0
  0006d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _RandomPoolEnrichedByUser, 0
  00077	e8 00 00 00 00	 call	 _memset
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 		VirtualLock (pRandPool, RANDOMPOOL_ALLOCSIZE);

  0007f	68 40 01 00 00	 push	 320			; 00000140H
  00084	56		 push	 esi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8
$LN10@Randinit:

; 92   : 	}
; 93   : 
; 94   : 	hKeyboard = SetWindowsHookEx (WH_KEYBOARD, (HOOKPROC)&KeyboardProc, NULL, GetCurrentThreadId ());

  0008b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetCurrentThreadId@0
  00091	57		 push	 edi
  00092	ff d6		 call	 esi
  00094	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SetWindowsHookExA@16
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	68 00 00 00 00	 push	 OFFSET _KeyboardProc@12
  000a2	6a 02		 push	 2
  000a4	ff d7		 call	 edi
  000a6	a3 00 00 00 00	 mov	 DWORD PTR ?hKeyboard@@3PAUHHOOK__@@A, eax ; hKeyboard

; 95   : 	if (hKeyboard == 0) handleWin32Error (0);

  000ab	85 c0		 test	 eax, eax
  000ad	75 09		 jne	 SHORT $LN7@Randinit
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _handleWin32Error
  000b5	83 c4 04	 add	 esp, 4
$LN7@Randinit:

; 96   : 
; 97   : 	hMouse = SetWindowsHookEx (WH_MOUSE, (HOOKPROC)&MouseProc, NULL, GetCurrentThreadId ());

  000b8	ff d6		 call	 esi
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	68 00 00 00 00	 push	 OFFSET _MouseProc@12
  000c2	6a 07		 push	 7
  000c4	ff d7		 call	 edi
  000c6	a3 00 00 00 00	 mov	 DWORD PTR ?hMouse@@3PAUHHOOK__@@A, eax ; hMouse
  000cb	5f		 pop	 edi

; 98   : 	if (hMouse == 0)

  000cc	85 c0		 test	 eax, eax
  000ce	75 1a		 jne	 SHORT $LN6@Randinit

; 99   : 	{
; 100  : 		handleWin32Error (0);

  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _handleWin32Error
  000d6	83 c4 04	 add	 esp, 4

; 114  : 
; 115  : error:
; 116  : 	RandStop (TRUE);

  000d9	6a 01		 push	 1
  000db	e8 00 00 00 00	 call	 _RandStop
  000e0	83 c4 04	 add	 esp, 4

; 117  : 	return 1;

  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	5e		 pop	 esi

; 118  : }

  000e9	c3		 ret	 0
$LN6@Randinit:

; 101  : 		goto error;
; 102  : 	}
; 103  : 
; 104  : 	if (!CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)
; 105  : 		&& !CryptAcquireContext (&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))

  000ea	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CryptAcquireContextA@20
  000f0	68 00 00 00 f0	 push	 -268435456		; f0000000H
  000f5	6a 01		 push	 1
  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	68 00 00 00 00	 push	 OFFSET ?hCryptProv@@3KA	; hCryptProv
  00100	ff d6		 call	 esi
  00102	85 c0		 test	 eax, eax
  00104	75 1b		 jne	 SHORT $LN4@Randinit
  00106	6a 08		 push	 8
  00108	6a 01		 push	 1
  0010a	50		 push	 eax
  0010b	50		 push	 eax
  0010c	68 00 00 00 00	 push	 OFFSET ?hCryptProv@@3KA	; hCryptProv
  00111	ff d6		 call	 esi

; 106  : 		CryptoAPIAvailable = FALSE;

  00113	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CryptoAPIAvailable@@3HA, 0 ; CryptoAPIAvailable
  0011d	85 c0		 test	 eax, eax
  0011f	74 0a		 je	 SHORT $LN3@Randinit
$LN4@Randinit:

; 107  : 	else
; 108  : 		CryptoAPIAvailable = TRUE;

  00121	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CryptoAPIAvailable@@3HA, 1 ; CryptoAPIAvailable
$LN3@Randinit:

; 109  : 
; 110  : 	if (!(PeriodicFastPollThreadHandle = (HANDLE) _beginthreadex (NULL, 0, PeriodicFastPollThreadProc, NULL, 0, NULL)))

  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	68 00 00 00 00	 push	 OFFSET _PeriodicFastPollThreadProc@4
  00136	6a 00		 push	 0
  00138	6a 00		 push	 0
  0013a	e8 00 00 00 00	 call	 __beginthreadex
  0013f	83 c4 18	 add	 esp, 24			; 00000018H
  00142	a3 00 00 00 00	 mov	 DWORD PTR _PeriodicFastPollThreadHandle, eax
  00147	85 c0		 test	 eax, eax
  00149	75 11		 jne	 SHORT $LN2@Randinit
$error$81313:

; 114  : 
; 115  : error:
; 116  : 	RandStop (TRUE);

  0014b	6a 01		 push	 1
  0014d	e8 00 00 00 00	 call	 _RandStop
  00152	83 c4 04	 add	 esp, 4

; 117  : 	return 1;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	5e		 pop	 esi

; 118  : }

  0015b	c3		 ret	 0
$LN2@Randinit:

; 111  : 		goto error;
; 112  : 
; 113  : 	return 0;

  0015c	33 c0		 xor	 eax, eax
  0015e	5e		 pop	 esi

; 118  : }

  0015f	c3		 ret	 0
_Randinit ENDP
_TEXT	ENDS
END
