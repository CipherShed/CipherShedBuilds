; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\Format.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?FormatExResult@@3EC				; FormatExResult
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	_FormatWriteBufferSize
_BSS	SEGMENT
?FormatExResult@@3EC DB 01H DUP (?)			; FormatExResult
	ALIGN	4

_FormatSectorSize DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_FormatWriteBufferSize DD 0100000H
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	?LoadDLL_fmifs@@YAPAUHINSTANCE__@@XZ		; LoadDLL_fmifs
EXTRN	?LoadDLL@@YAPAUHINSTANCE__@@PA_WI@Z:PROC	; LoadDLL
;	COMDAT ??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
; File c:\users\public\desktop\projects\ciphershed\src\common\util\dll.h
CONST	SEGMENT
??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB 'f'
	DB	00H, 'm', 00H, 'i', 00H, 'f', 00H, 's', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?LoadDLL_fmifs@@YAPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?LoadDLL_fmifs@@YAPAUHINSTANCE__@@XZ PROC		; LoadDLL_fmifs, COMDAT

; 70   : 	return LoadDLL((const LPWSTR)dll,(UINT)ARRAYSIZE(dll));

  00000	6a 0a		 push	 10			; 0000000aH
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  00007	e8 00 00 00 00	 call	 ?LoadDLL@@YAPAUHINSTANCE__@@PA_WI@Z ; LoadDLL
  0000c	83 c4 08	 add	 esp, 8

; 71   : }

  0000f	c3		 ret	 0
?LoadDLL_fmifs@@YAPAUHINSTANCE__@@XZ ENDP		; LoadDLL_fmifs
_TEXT	ENDS
PUBLIC	?GetHandleDLL_fmifs@@YAPAUHINSTANCE__@@XZ	; GetHandleDLL_fmifs
EXTRN	?GetHandleDLL@@YAPAUHINSTANCE__@@PA_WI@Z:PROC	; GetHandleDLL
; Function compile flags: /Ogtpy
;	COMDAT ?GetHandleDLL_fmifs@@YAPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetHandleDLL_fmifs@@YAPAUHINSTANCE__@@XZ PROC		; GetHandleDLL_fmifs, COMDAT

; 74   : 	return GetHandleDLL((const LPWSTR)dll,(UINT)ARRAYSIZE(dll));

  00000	6a 0a		 push	 10			; 0000000aH
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  00007	e8 00 00 00 00	 call	 ?GetHandleDLL@@YAPAUHINSTANCE__@@PA_WI@Z ; GetHandleDLL
  0000c	83 c4 08	 add	 esp, 8

; 75   : }

  0000f	c3		 ret	 0
?GetHandleDLL_fmifs@@YAPAUHINSTANCE__@@XZ ENDP		; GetHandleDLL_fmifs
_TEXT	ENDS
PUBLIC	_GetVolumeDataAreaSize
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\format.cpp
;	COMDAT _GetVolumeDataAreaSize
_TEXT	SEGMENT
_hiddenVolume$ = 8					; size = 4
_volumeSize$ = 12					; size = 8
_GetVolumeDataAreaSize PROC				; COMDAT

; 40   : 	uint64 reservedSize;
; 41   : 
; 42   : 	if (hiddenVolume)

  00000	83 7c 24 04 00	 cmp	 DWORD PTR _hiddenVolume$[esp-4], 0
  00005	8b 54 24 0c	 mov	 edx, DWORD PTR _volumeSize$[esp]
  00009	8b 44 24 08	 mov	 eax, DWORD PTR _volumeSize$[esp-4]
  0000d	56		 push	 esi
  0000e	74 1b		 je	 SHORT $LN5@GetVolumeD

; 43   : 	{
; 44   : 		// Reserve free space at the end of the host filesystem. FAT file system fills the last sector with
; 45   : 		// zeroes (marked as free; observed when quick format was performed using the OS format tool).
; 46   : 		// Therefore, when the outer volume is mounted with hidden volume protection, such write operations
; 47   : 		// (e.g. quick formatting the outer volume filesystem as FAT) would needlessly trigger hidden volume
; 48   : 		// protection.
; 49   : 
; 50   : #if TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE > 4096
; 51   : #	error	TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE too large for very small volumes. Revise the code.
; 52   : #endif
; 53   : 
; 54   : #if TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH < TC_MAX_VOLUME_SECTOR_SIZE
; 55   : #	error	TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH too small.
; 56   : #endif
; 57   : 		
; 58   : 		if (volumeSize < TC_VOLUME_SMALL_SIZE_THRESHOLD)

  00010	85 d2		 test	 edx, edx
  00012	77 10		 ja	 SHORT $LN4@GetVolumeD
  00014	72 07		 jb	 SHORT $LN8@GetVolumeD
  00016	3d 00 00 20 00	 cmp	 eax, 2097152		; 00200000H
  0001b	73 07		 jae	 SHORT $LN4@GetVolumeD
$LN8@GetVolumeD:

; 59   : 			reservedSize = TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE;

  0001d	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H

; 60   : 		else

  00022	eb 0c		 jmp	 SHORT $LN10@GetVolumeD
$LN4@GetVolumeD:

; 61   : 			reservedSize = TC_HIDDEN_VOLUME_HOST_FS_RESERVED_END_AREA_SIZE_HIGH; // Ensure size of a hidden volume larger than TC_VOLUME_SMALL_SIZE_THRESHOLD is a multiple of the maximum supported sector size

  00024	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H

; 62   : 	}
; 63   : 	else

  00029	eb 05		 jmp	 SHORT $LN10@GetVolumeD
$LN5@GetVolumeD:

; 64   : 	{
; 65   : 		reservedSize = TC_TOTAL_VOLUME_HEADERS_SIZE;

  0002b	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
$LN10@GetVolumeD:
  00030	33 f6		 xor	 esi, esi

; 66   : 	}
; 67   : 
; 68   : 	if (volumeSize < reservedSize)

  00032	3b d6		 cmp	 edx, esi
  00034	77 0c		 ja	 SHORT $LN1@GetVolumeD
  00036	72 04		 jb	 SHORT $LN9@GetVolumeD
  00038	3b c1		 cmp	 eax, ecx
  0003a	73 06		 jae	 SHORT $LN1@GetVolumeD
$LN9@GetVolumeD:

; 69   : 		return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	33 d2		 xor	 edx, edx
  00040	5e		 pop	 esi

; 72   : }

  00041	c3		 ret	 0
$LN1@GetVolumeD:

; 70   : 
; 71   : 	return volumeSize - reservedSize;

  00042	2b c1		 sub	 eax, ecx
  00044	1b d6		 sbb	 edx, esi
  00046	5e		 pop	 esi

; 72   : }

  00047	c3		 ret	 0
_GetVolumeDataAreaSize ENDP
_TEXT	ENDS
PUBLIC	?FormatExCallback@@YGEHKPAX@Z			; FormatExCallback
; Function compile flags: /Ogtpy
;	COMDAT ?FormatExCallback@@YGEHKPAX@Z
_TEXT	SEGMENT
_command$ = 8						; size = 4
_subCommand$ = 12					; size = 4
_parameter$ = 16					; size = 4
?FormatExCallback@@YGEHKPAX@Z PROC			; FormatExCallback, COMDAT

; 793  : 	if (command == FMIFS_DONE)

  00000	83 7c 24 04 0b	 cmp	 DWORD PTR _command$[esp-4], 11 ; 0000000bH
  00005	75 0c		 jne	 SHORT $LN4@FormatExCa

; 794  : 		FormatExResult = *(BOOLEAN *) parameter;

  00007	8b 44 24 0c	 mov	 eax, DWORD PTR _parameter$[esp-4]
  0000b	8a 08		 mov	 cl, BYTE PTR [eax]
  0000d	88 0d 00 00 00
	00		 mov	 BYTE PTR ?FormatExResult@@3EC, cl ; FormatExResult
$LN4@FormatExCa:

; 795  : 	return TRUE;

  00013	b0 01		 mov	 al, 1

; 796  : }

  00015	c2 0c 00	 ret	 12			; 0000000cH
?FormatExCallback@@YGEHKPAX@Z ENDP			; FormatExCallback
_TEXT	ENDS
PUBLIC	??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@	; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_08KDJACLKO@FormatEx?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_FormatNtfs
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@
; File c:\users\public\desktop\projects\ciphershed\src\common\util\dll.h
CONST	SEGMENT
??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@ DB 'N', 00H, 'T', 00H, 'F', 00H
	DB	'S', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@ DB ':', 00H, '\', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDJACLKO@FormatEx?$AA@
CONST	SEGMENT
??_C@_08KDJACLKO@FormatEx?$AA@ DB 'FormatEx', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\format.cpp
CONST	ENDS
;	COMDAT _FormatNtfs
_TEXT	SEGMENT
_dir$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_driveNo$ = 8						; size = 4
_clusterSize$ = 12					; size = 4
_FormatNtfs PROC					; COMDAT

; 799  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax

; 800  : 	WCHAR dir[8] = { (WCHAR) driveNo + 'A', 0 };

  0000e	8b 44 24 18	 mov	 eax, DWORD PTR _driveNo$[esp+16]
  00012	83 c0 41	 add	 eax, 65			; 00000041H
  00015	55		 push	 ebp
  00016	66 89 44 24 04	 mov	 WORD PTR _dir$[esp+24], ax
  0001b	33 c0		 xor	 eax, eax
  0001d	33 c9		 xor	 ecx, ecx

; 801  : 	PFORMATEX FormatEx;
; 802  : 	HMODULE hModule = LoadDLL_fmifs();

  0001f	6a 0a		 push	 10			; 0000000aH
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  00026	66 89 4c 24 0e	 mov	 WORD PTR _dir$[esp+34], cx
  0002b	89 44 24 10	 mov	 DWORD PTR _dir$[esp+36], eax
  0002f	89 44 24 14	 mov	 DWORD PTR _dir$[esp+40], eax
  00033	89 44 24 18	 mov	 DWORD PTR _dir$[esp+44], eax
  00037	e8 00 00 00 00	 call	 ?LoadDLL@@YAPAUHINSTANCE__@@PA_WI@Z ; LoadDLL
  0003c	8b e8		 mov	 ebp, eax
  0003e	83 c4 08	 add	 esp, 8

; 803  : 	int i;
; 804  : 
; 805  : 	if (hModule == NULL)

  00041	85 ed		 test	 ebp, ebp
  00043	75 10		 jne	 SHORT $LN5@FormatNtfs
  00045	5d		 pop	 ebp

; 830  : }

  00046	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  0004a	33 cc		 xor	 ecx, esp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	c3		 ret	 0
$LN5@FormatNtfs:
  00055	53		 push	 ebx

; 806  : 		return FALSE;
; 807  : 
; 808  : 	if (!(FormatEx = (PFORMATEX) GetProcAddress (GetHandleDLL_fmifs(), "FormatEx")))

  00056	6a 0a		 push	 10			; 0000000aH
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@IHGPAAHL@?$AAf?$AAm?$AAi?$AAf?$AAs?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  0005d	e8 00 00 00 00	 call	 ?GetHandleDLL@@YAPAUHINSTANCE__@@PA_WI@Z ; GetHandleDLL
  00062	83 c4 08	 add	 esp, 8
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_08KDJACLKO@FormatEx?$AA@
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00071	8b d8		 mov	 ebx, eax
  00073	85 db		 test	 ebx, ebx
  00075	75 1a		 jne	 SHORT $LN4@FormatNtfs

; 809  : 	{
; 810  : 		FreeLibrary (hModule);

  00077	55		 push	 ebp
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  0007e	5b		 pop	 ebx

; 811  : 		return FALSE;

  0007f	33 c0		 xor	 eax, eax
  00081	5d		 pop	 ebp

; 830  : }

  00082	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  00086	33 cc		 xor	 ecx, esp
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	83 c4 14	 add	 esp, 20			; 00000014H
  00090	c3		 ret	 0
$LN4@FormatNtfs:

; 812  : 	}
; 813  : 
; 814  : 	wcscat (dir, L":\\");

  00091	8d 44 24 08	 lea	 eax, DWORD PTR _dir$[esp+28]
  00095	83 c0 fe	 add	 eax, -2			; fffffffeH
  00098	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL14@FormatNtfs:
  000a0	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000a4	83 c0 02	 add	 eax, 2
  000a7	66 85 c9	 test	 cx, cx
  000aa	75 f4		 jne	 SHORT $LL14@FormatNtfs
  000ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@
  000b2	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR ??_C@_15GKAHMKIN@?$AA?3?$AA?2?$AA?$AA@+4
  000b9	56		 push	 esi
  000ba	89 10		 mov	 DWORD PTR [eax], edx
  000bc	57		 push	 edi

; 815  : 
; 816  : 	FormatExResult = FALSE;
; 817  : 
; 818  : 	// Windows sometimes fails to format a volume (hosted on a removable medium) as NTFS.
; 819  : 	// It often helps to retry several times.
; 820  : 	for (i = 0; i < 50 && FormatExResult != TRUE; i++)

  000bd	8b 7c 24 2c	 mov	 edi, DWORD PTR _clusterSize$[esp+32]
  000c1	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  000c5	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?FormatExResult@@3EC, 0 ; FormatExResult
  000cc	33 f6		 xor	 esi, esi
  000ce	8b ff		 npad	 2
$LL3@FormatNtfs:
  000d0	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?FormatExResult@@3EC ; FormatExResult
  000d6	80 fa 01	 cmp	 dl, 1
  000d9	74 29		 je	 SHORT $LN1@FormatNtfs

; 821  : 	{
; 822  : 		FormatEx (dir, FMIFS_HARDDISK, L"NTFS", L"", TRUE, clusterSize * FormatSectorSize, FormatExCallback);

  000db	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  000e0	0f af c7	 imul	 eax, edi
  000e3	68 00 00 00 00	 push	 OFFSET ?FormatExCallback@@YGEHKPAX@Z ; FormatExCallback
  000e8	50		 push	 eax
  000e9	6a 01		 push	 1
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_19ENNDBEJL@?$AAN?$AAT?$AAF?$AAS?$AA?$AA@
  000f5	6a 0c		 push	 12			; 0000000cH
  000f7	8d 4c 24 28	 lea	 ecx, DWORD PTR _dir$[esp+60]
  000fb	51		 push	 ecx
  000fc	ff d3		 call	 ebx
  000fe	46		 inc	 esi
  000ff	83 fe 32	 cmp	 esi, 50			; 00000032H
  00102	7c cc		 jl	 SHORT $LL3@FormatNtfs
$LN1@FormatNtfs:

; 823  : 	}
; 824  : 
; 825  : 	// The device may be referenced for some time after FormatEx() returns
; 826  : 	Sleep (2000);

  00104	68 d0 07 00 00	 push	 2000			; 000007d0H
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 827  : 
; 828  : 	FreeLibrary (hModule);

  0010f	55		 push	 ebp
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 829  : 	return FormatExResult;

  00116	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?FormatExResult@@3EC ; FormatExResult

; 830  : }

  0011c	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	5d		 pop	 ebp
  00124	33 cc		 xor	 ecx, esp
  00126	0f b6 c2	 movzx	 eax, dl
  00129	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012e	83 c4 14	 add	 esp, 20			; 00000014H
  00131	c3		 ret	 0
_FormatNtfs ENDP
_TEXT	ENDS
EXTRN	__endthread:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
_BSS	SEGMENT
_WriteThreadRunning DD 01H DUP (?)
_WriteBufferEmptyEvent DD 01H DUP (?)
_WriteRequestResult DD 01H DUP (?)
_WriteRequestHandle DD 01H DUP (?)
_WriteThreadBuffer DD 01H DUP (?)
_WriteRequestSize DD 01H DUP (?)
_WriteBufferFullEvent DD 01H DUP (?)
_WriteThreadExitRequested DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT ?FormatWriteThreadProc@@YAXPAX@Z
_TEXT	SEGMENT
_bytesWritten$ = -4					; size = 4
_arg$ = 8						; size = 4
?FormatWriteThreadProc@@YAXPAX@Z PROC			; FormatWriteThreadProc, COMDAT

; 874  : {

  00000	51		 push	 ecx

; 875  : 	DWORD bytesWritten;
; 876  : 
; 877  : 	SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

  00001	6a 02		 push	 2
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThread@0
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 878  : 
; 879  : 	while (!WriteThreadExitRequested)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadExitRequested
  00015	85 c0		 test	 eax, eax
  00017	0f 85 97 00 00
	00		 jne	 $LN14@FormatWrit
  0001d	53		 push	 ebx
  0001e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetLastError@0
  00024	55		 push	 ebp
  00025	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetEvent@4
  0002b	56		 push	 esi
  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  00032	57		 push	 edi
  00033	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WriteFile@20
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL7@FormatWrit:

; 880  : 	{
; 881  : 		if (WaitForSingleObject (WriteBufferFullEvent, INFINITE) == WAIT_FAILED)

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferFullEvent
  00046	6a ff		 push	 -1
  00048	51		 push	 ecx
  00049	ff d6		 call	 esi
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	74 56		 je	 SHORT $LN13@FormatWrit

; 882  : 		{
; 883  : 			handleWin32Error (NULL);
; 884  : 			break;
; 885  : 		}
; 886  : 
; 887  : 		if (WriteThreadExitRequested)

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteThreadExitRequested
  00056	85 d2		 test	 edx, edx
  00058	75 56		 jne	 SHORT $LN15@FormatWrit

; 888  : 			break;
; 889  : 
; 890  : 		if (!WriteFile (WriteRequestHandle, WriteThreadBuffer, WriteRequestSize, &bytesWritten, NULL))

  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteRequestSize
  00060	52		 push	 edx
  00061	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteThreadBuffer
  00067	8d 44 24 14	 lea	 eax, DWORD PTR _bytesWritten$[esp+24]
  0006b	50		 push	 eax
  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestHandle
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	50		 push	 eax
  00074	ff d7		 call	 edi
  00076	85 c0		 test	 eax, eax
  00078	75 09		 jne	 SHORT $LN3@FormatWrit

; 891  : 			WriteRequestResult = GetLastError();

  0007a	ff d3		 call	 ebx
  0007c	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, eax

; 892  : 		else		

  00081	eb 0a		 jmp	 SHORT $LN2@FormatWrit
$LN3@FormatWrit:

; 893  : 			WriteRequestResult = ERROR_SUCCESS;

  00083	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteRequestResult, 0
$LN2@FormatWrit:

; 894  : 
; 895  : 		if (!SetEvent (WriteBufferEmptyEvent))

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00093	51		 push	 ecx
  00094	ff d5		 call	 ebp
  00096	85 c0		 test	 eax, eax
  00098	74 0c		 je	 SHORT $LN13@FormatWrit
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteThreadExitRequested
  000a0	85 d2		 test	 edx, edx
  000a2	74 9c		 je	 SHORT $LL7@FormatWrit
  000a4	eb 0a		 jmp	 SHORT $LN15@FormatWrit
$LN13@FormatWrit:

; 896  : 		{
; 897  : 			handleWin32Error (NULL);

  000a6	6a 00		 push	 0
  000a8	e8 00 00 00 00	 call	 _handleWin32Error
  000ad	83 c4 04	 add	 esp, 4
$LN15@FormatWrit:
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5d		 pop	 ebp
  000b3	5b		 pop	 ebx
$LN14@FormatWrit:

; 898  : 			break;
; 899  : 		}
; 900  : 	}
; 901  : 
; 902  : 	WriteThreadRunning = FALSE;

  000b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WriteThreadRunning, 0

; 903  : 	_endthread();

  000be	e8 00 00 00 00	 call	 __endthread

; 904  : }

  000c3	59		 pop	 ecx
  000c4	c3		 ret	 0
?FormatWriteThreadProc@@YAXPAX@Z ENDP			; FormatWriteThreadProc
_TEXT	ENDS
EXTRN	_free:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__beginthread:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__CreateEventA@16:PROC
_BSS	SEGMENT
_WriteThreadHandle DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _StartFormatWriteThread
_TEXT	SEGMENT
_StartFormatWriteThread PROC				; COMDAT

; 908  : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 909  : 	DWORD sysErr;
; 910  : 
; 911  : 	WriteBufferEmptyEvent = NULL;
; 912  : 	WriteBufferFullEvent = NULL;
; 913  : 	WriteThreadBuffer = NULL;
; 914  : 
; 915  : 	WriteBufferEmptyEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateEventA@16
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	57		 push	 edi
  0000c	6a 01		 push	 1
  0000e	57		 push	 edi
  0000f	57		 push	 edi
  00010	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteBufferEmptyEvent, edi
  00016	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteBufferFullEvent, edi
  0001c	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteThreadBuffer, edi
  00022	ff d6		 call	 esi

; 916  : 	if (!WriteBufferEmptyEvent)

  00024	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__SetLastError@4
  0002a	a3 00 00 00 00	 mov	 DWORD PTR _WriteBufferEmptyEvent, eax
  0002f	3b c7		 cmp	 eax, edi
  00031	74 51		 je	 SHORT $err$81881

; 917  : 		goto err;
; 918  : 
; 919  : 	WriteBufferFullEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  00033	57		 push	 edi
  00034	57		 push	 edi
  00035	57		 push	 edi
  00036	57		 push	 edi
  00037	ff d6		 call	 esi
  00039	a3 00 00 00 00	 mov	 DWORD PTR _WriteBufferFullEvent, eax

; 920  : 	if (!WriteBufferFullEvent)

  0003e	3b c7		 cmp	 eax, edi
  00040	74 42		 je	 SHORT $err$81881

; 921  : 		goto err;
; 922  : 
; 923  : 	WriteThreadBuffer = (byte*)TCalloc (FormatWriteBufferSize);

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatWriteBufferSize
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _malloc
  0004d	83 c4 04	 add	 esp, 4
  00050	a3 00 00 00 00	 mov	 DWORD PTR _WriteThreadBuffer, eax

; 924  : 	if (!WriteThreadBuffer)

  00055	3b c7		 cmp	 eax, edi
  00057	75 06		 jne	 SHORT $LN7@StartForma

; 925  : 	{
; 926  : 		SetLastError (ERROR_OUTOFMEMORY);

  00059	6a 0e		 push	 14			; 0000000eH
  0005b	ff d5		 call	 ebp

; 939  : 
; 940  : err:

  0005d	eb 25		 jmp	 SHORT $err$81881
$LN7@StartForma:

; 927  : 		goto err;
; 928  : 	}
; 929  : 
; 930  : 	WriteThreadExitRequested = FALSE;
; 931  : 	WriteRequestResult = ERROR_SUCCESS;
; 932  : 
; 933  : 	WriteThreadHandle = (HANDLE) _beginthread (FormatWriteThreadProc, 0, NULL);

  0005f	57		 push	 edi
  00060	57		 push	 edi
  00061	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteThreadExitRequested, edi
  00067	68 00 00 00 00	 push	 OFFSET ?FormatWriteThreadProc@@YAXPAX@Z ; FormatWriteThreadProc
  0006c	89 3d 00 00 00
	00		 mov	 DWORD PTR _WriteRequestResult, edi
  00072	e8 00 00 00 00	 call	 __beginthread
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	a3 00 00 00 00	 mov	 DWORD PTR _WriteThreadHandle, eax

; 934  : 	if ((uintptr_t) WriteThreadHandle == -1L)

  0007f	83 f8 ff	 cmp	 eax, -1
  00082	75 43		 jne	 SHORT $LN5@StartForma
$err$81881:
  00084	53		 push	 ebx

; 941  : 	sysErr = GetLastError();

  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 942  : 
; 943  : 	if (WriteBufferEmptyEvent)

  0008b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00091	8b d8		 mov	 ebx, eax
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteBufferEmptyEvent
  00098	3b c7		 cmp	 eax, edi
  0009a	74 03		 je	 SHORT $LN3@StartForma

; 944  : 		CloseHandle (WriteBufferEmptyEvent);

  0009c	50		 push	 eax
  0009d	ff d6		 call	 esi
$LN3@StartForma:

; 945  : 	if (WriteBufferFullEvent)

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteBufferFullEvent
  000a4	3b c7		 cmp	 eax, edi
  000a6	74 03		 je	 SHORT $LN2@StartForma

; 946  : 		CloseHandle (WriteBufferFullEvent);

  000a8	50		 push	 eax
  000a9	ff d6		 call	 esi
$LN2@StartForma:

; 947  : 	if (WriteThreadBuffer)

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadBuffer
  000b0	3b c7		 cmp	 eax, edi
  000b2	74 09		 je	 SHORT $LN1@StartForma

; 948  : 		TCfree (WriteThreadBuffer);

  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _free
  000ba	83 c4 04	 add	 esp, 4
$LN1@StartForma:

; 949  : 
; 950  : 	SetLastError (sysErr);

  000bd	53		 push	 ebx
  000be	ff d5		 call	 ebp
  000c0	5b		 pop	 ebx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi

; 951  : 	return FALSE;

  000c3	33 c0		 xor	 eax, eax
  000c5	5d		 pop	 ebp

; 952  : }

  000c6	c3		 ret	 0
$LN5@StartForma:
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 935  : 		goto err;
; 936  : 
; 937  : 	WriteThreadRunning = TRUE;

  000c9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WriteThreadRunning, 1

; 938  : 	return TRUE;

  000d3	b8 01 00 00 00	 mov	 eax, 1
  000d8	5d		 pop	 ebp

; 952  : }

  000d9	c3		 ret	 0
_StartFormatWriteThread ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _StopFormatWriteThread
_TEXT	SEGMENT
_StopFormatWriteThread PROC				; COMDAT

; 957  : 	if (WriteThreadRunning)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadRunning
  00005	56		 push	 esi
  00006	85 c0		 test	 eax, eax
  00008	74 32		 je	 SHORT $LN1@StopFormat

; 958  : 	{
; 959  : 		WaitForSingleObject (WriteBufferEmptyEvent, INFINITE);

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00010	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  00016	6a ff		 push	 -1
  00018	51		 push	 ecx
  00019	ff d6		 call	 esi

; 960  : 
; 961  : 		WriteThreadExitRequested = TRUE;
; 962  : 		SetEvent (WriteBufferFullEvent);

  0001b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteBufferFullEvent
  00021	52		 push	 edx
  00022	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _WriteThreadExitRequested, 1
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 963  : 
; 964  : 		WaitForSingleObject (WriteThreadHandle, INFINITE);

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadHandle
  00037	6a ff		 push	 -1
  00039	50		 push	 eax
  0003a	ff d6		 call	 esi
$LN1@StopFormat:

; 965  : 	}
; 966  : 
; 967  : 	CloseHandle (WriteBufferEmptyEvent);

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  00042	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00048	51		 push	 ecx
  00049	ff d6		 call	 esi

; 968  : 	CloseHandle (WriteBufferFullEvent);

  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteBufferFullEvent
  00051	52		 push	 edx
  00052	ff d6		 call	 esi

; 969  : 	TCfree (WriteThreadBuffer);

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteThreadBuffer
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _free
  0005f	83 c4 04	 add	 esp, 4
  00062	5e		 pop	 esi

; 970  : }

  00063	c3		 ret	 0
_StopFormatWriteThread ENDP
_TEXT	ENDS
PUBLIC	_FlushFormatWriteBuffer
EXTRN	_EncryptDataUnits:PROC
EXTRN	_memcpy:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FlushFormatWriteBuffer
_TEXT	SEGMENT
_unitNo$ = -8						; size = 8
_dev$ = 8						; size = 4
_write_buf$ = 12					; size = 4
_bytesWritten$ = 16					; size = 4
_write_buf_cnt$ = 16					; size = 4
_nSecNo$ = 20						; size = 4
_cryptoInfo$ = 24					; size = 4
_FlushFormatWriteBuffer PROC				; COMDAT

; 974  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi

; 975  : 	UINT64_STRUCT unitNo;
; 976  : 	DWORD bytesWritten;
; 977  : 
; 978  : 	if (*write_buf_cnt == 0)

  00005	8b 7c 24 1c	 mov	 edi, DWORD PTR _write_buf_cnt$[esp+12]
  00009	8b 37		 mov	 esi, DWORD PTR [edi]
  0000b	85 f6		 test	 esi, esi

; 979  : 		return TRUE;

  0000d	0f 84 05 01 00
	00		 je	 $LN10@FlushForma

; 980  : 
; 981  : 	unitNo.Value = (*nSecNo * FormatSectorSize - *write_buf_cnt) / ENCRYPTION_DATA_UNIT_SIZE;

  00013	8b 44 24 20	 mov	 eax, DWORD PTR _nSecNo$[esp+12]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00021	53		 push	 ebx
  00022	51		 push	 ecx
  00023	52		 push	 edx
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __allmul
  0002c	8b c8		 mov	 ecx, eax
  0002e	8b da		 mov	 ebx, edx
  00030	8b c6		 mov	 eax, esi
  00032	99		 cdq
  00033	6a 00		 push	 0
  00035	2b c8		 sub	 ecx, eax
  00037	68 00 02 00 00	 push	 512			; 00000200H
  0003c	1b da		 sbb	 ebx, edx
  0003e	53		 push	 ebx
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 __alldiv
  00045	89 44 24 0c	 mov	 DWORD PTR _unitNo$[esp+20], eax
  00049	89 54 24 10	 mov	 DWORD PTR _unitNo$[esp+24], edx

; 982  : 
; 983  : 	EncryptDataUnits ((unsigned char*)write_buf, &unitNo, *write_buf_cnt / ENCRYPTION_DATA_UNIT_SIZE, cryptoInfo);

  0004d	8b 54 24 28	 mov	 edx, DWORD PTR _cryptoInfo$[esp+16]
  00051	52		 push	 edx
  00052	8b c6		 mov	 eax, esi
  00054	8b 74 24 20	 mov	 esi, DWORD PTR _write_buf$[esp+20]
  00058	99		 cdq
  00059	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0005f	03 c2		 add	 eax, edx
  00061	c1 f8 09	 sar	 eax, 9
  00064	50		 push	 eax
  00065	8d 44 24 14	 lea	 eax, DWORD PTR _unitNo$[esp+28]
  00069	50		 push	 eax
  0006a	56		 push	 esi
  0006b	e8 00 00 00 00	 call	 _EncryptDataUnits

; 984  : 
; 985  : 	if (WriteThreadRunning)

  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteThreadRunning
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	5b		 pop	 ebx
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 7a		 je	 SHORT $LN6@FlushForma

; 986  : 	{
; 987  : 		if (WaitForSingleObject (WriteBufferEmptyEvent, INFINITE) == WAIT_FAILED)

  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteBufferEmptyEvent
  00084	6a ff		 push	 -1
  00086	52		 push	 edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0008d	83 f8 ff	 cmp	 eax, -1

; 988  : 			return FALSE;

  00090	74 23		 je	 SHORT $LN11@FlushForma

; 989  : 		
; 990  : 		if (WriteRequestResult != ERROR_SUCCESS)

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteRequestResult
  00097	85 c0		 test	 eax, eax
  00099	74 22		 je	 SHORT $LN4@FlushForma

; 991  : 		{
; 992  : 			SetEvent (WriteBufferEmptyEvent);

  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferEmptyEvent
  000a1	51		 push	 ecx
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 993  : 			SetLastError (WriteRequestResult);

  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WriteRequestResult
  000ae	52		 push	 edx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN11@FlushForma:
  000b5	5f		 pop	 edi

; 994  : 			return FALSE;

  000b6	33 c0		 xor	 eax, eax
  000b8	5e		 pop	 esi

; 1012 : }

  000b9	83 c4 08	 add	 esp, 8
  000bc	c3		 ret	 0
$LN4@FlushForma:

; 995  : 		}
; 996  : 
; 997  : 		memcpy (WriteThreadBuffer, write_buf, *write_buf_cnt);

  000bd	8b 07		 mov	 eax, DWORD PTR [edi]
  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteThreadBuffer
  000c5	50		 push	 eax
  000c6	56		 push	 esi
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _memcpy

; 998  : 		WriteRequestHandle = dev;

  000cd	8b 54 24 20	 mov	 edx, DWORD PTR _dev$[esp+24]

; 999  : 		WriteRequestSize = *write_buf_cnt;
; 1000 : 
; 1001 : 		if (!SetEvent (WriteBufferFullEvent))

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _WriteBufferFullEvent
  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	89 15 00 00 00
	00		 mov	 DWORD PTR _WriteRequestHandle, edx
  000e2	51		 push	 ecx
  000e3	a3 00 00 00 00	 mov	 DWORD PTR _WriteRequestSize, eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  000ee	85 c0		 test	 eax, eax
  000f0	75 20		 jne	 SHORT $LN1@FlushForma
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi

; 1012 : }

  000f4	83 c4 08	 add	 esp, 8
  000f7	c3		 ret	 0
$LN6@FlushForma:

; 1002 : 			return FALSE;
; 1003 : 	}
; 1004 : 	else
; 1005 : 	{
; 1006 : 		if (!WriteFile ((HANDLE) dev, write_buf, *write_buf_cnt, &bytesWritten, NULL))

  000f8	8b 07		 mov	 eax, DWORD PTR [edi]
  000fa	8b 4c 24 14	 mov	 ecx, DWORD PTR _dev$[esp+12]
  000fe	6a 00		 push	 0
  00100	8d 54 24 20	 lea	 edx, DWORD PTR _bytesWritten$[esp+16]
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	56		 push	 esi
  00107	51		 push	 ecx
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0010e	85 c0		 test	 eax, eax

; 1007 : 			return FALSE;

  00110	74 a3		 je	 SHORT $LN11@FlushForma
$LN1@FlushForma:

; 1008 : 	}
; 1009 : 
; 1010 : 	*write_buf_cnt = 0;

  00112	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN10@FlushForma:
  00118	5f		 pop	 edi

; 1011 : 	return TRUE;

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	5e		 pop	 esi

; 1012 : }

  0011f	83 c4 08	 add	 esp, 8
  00122	c3		 ret	 0
_FlushFormatWriteBuffer ENDP
_TEXT	ENDS
PUBLIC	_WriteSector
EXTRN	_UpdateProgressBar:PROC
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ?updateTime@?1??WriteSector@@9@4HA
_BSS	SEGMENT
?updateTime@?1??WriteSector@@9@4HA DD 01H DUP (?)	; `WriteSector'::`2'::updateTime
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _WriteSector
_TEXT	SEGMENT
_dev$ = 8						; size = 4
_sector$ = 12						; size = 4
_write_buf$ = 16					; size = 4
_write_buf_cnt$ = 20					; size = 4
_nSecNo$ = 24						; size = 4
_cryptoInfo$ = 28					; size = 4
_WriteSector PROC					; COMDAT

; 837  : 	static __int32 updateTime = 0;
; 838  : 
; 839  : 	(*nSecNo)++;
; 840  : 
; 841  : 	memcpy (write_buf + *write_buf_cnt, sector, FormatSectorSize);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _sector$[esp-4]
  00004	53		 push	 ebx
  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _FormatSectorSize
  0000b	55		 push	 ebp
  0000c	8b 6c 24 14	 mov	 ebp, DWORD PTR _write_buf$[esp+4]
  00010	56		 push	 esi
  00011	8b 74 24 20	 mov	 esi, DWORD PTR _nSecNo$[esp+8]
  00015	83 06 01	 add	 DWORD PTR [esi], 1
  00018	57		 push	 edi
  00019	8b 7c 24 20	 mov	 edi, DWORD PTR _write_buf_cnt$[esp+12]
  0001d	83 56 04 00	 adc	 DWORD PTR [esi+4], 0
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	53		 push	 ebx
  00024	50		 push	 eax
  00025	03 cd		 add	 ecx, ebp
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memcpy

; 842  : 	(*write_buf_cnt) += FormatSectorSize;

  0002d	01 1f		 add	 DWORD PTR [edi], ebx
  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 843  : 
; 844  : 	if (*write_buf_cnt == FormatWriteBufferSize && !FlushFormatWriteBuffer (dev, write_buf, write_buf_cnt, nSecNo, cryptoInfo))

  00034	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _FormatWriteBufferSize
  0003a	75 20		 jne	 SHORT $LN3@WriteSecto
  0003c	8b 54 24 28	 mov	 edx, DWORD PTR _cryptoInfo$[esp+12]
  00040	8b 44 24 14	 mov	 eax, DWORD PTR _dev$[esp+12]
  00044	52		 push	 edx
  00045	56		 push	 esi
  00046	57		 push	 edi
  00047	55		 push	 ebp
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  0004e	83 c4 14	 add	 esp, 20			; 00000014H
  00051	85 c0		 test	 eax, eax
  00053	75 07		 jne	 SHORT $LN3@WriteSecto
$LN6@WriteSecto:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp

; 845  : 		return FALSE;

  00058	33 c0		 xor	 eax, eax
  0005a	5b		 pop	 ebx

; 856  : 
; 857  : }

  0005b	c3		 ret	 0
$LN3@WriteSecto:

; 846  : 	
; 847  : 	if (GetTickCount () - updateTime > 25)

  0005c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00062	ff d7		 call	 edi
  00064	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?updateTime@?1??WriteSector@@9@4HA
  0006a	83 f8 19	 cmp	 eax, 25			; 00000019H
  0006d	76 29		 jbe	 SHORT $LN2@WriteSecto

; 848  : 	{
; 849  : 		if (UpdateProgressBar (*nSecNo * FormatSectorSize))

  0006f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00072	8b 16		 mov	 edx, DWORD PTR [esi]
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00079	51		 push	 ecx
  0007a	52		 push	 edx
  0007b	6a 00		 push	 0
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 __allmul
  00083	52		 push	 edx
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _UpdateProgressBar
  0008a	83 c4 08	 add	 esp, 8
  0008d	85 c0		 test	 eax, eax

; 850  : 			return FALSE;

  0008f	75 c4		 jne	 SHORT $LN6@WriteSecto

; 851  : 
; 852  : 		updateTime = GetTickCount ();

  00091	ff d7		 call	 edi
  00093	a3 00 00 00 00	 mov	 DWORD PTR ?updateTime@?1??WriteSector@@9@4HA, eax
$LN2@WriteSecto:
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5d		 pop	 ebp

; 853  : 	}
; 854  : 
; 855  : 	return TRUE;

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	5b		 pop	 ebx

; 856  : 
; 857  : }

  000a1	c3		 ret	 0
_WriteSector ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_FormatNoFs
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAInit:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _FormatNoFs
_TEXT	SEGMENT
_retVal$ = -4640					; size = 4
_write_buf$ = -4636					; size = 4
_nSecNo$ = -4632					; size = 8
_write_buf_cnt$ = -4624					; size = 4
_newOffset$ = -4620					; size = 8
_temporaryKey$ = -4612					; size = 256
_originalK2$ = -4356					; size = 256
_sector$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_startSector$ = 8					; size = 8
_num_sectors$ = 16					; size = 8
_dev$ = 24						; size = 4
_cryptoInfo$ = 28					; size = 4
_quickFormat$ = 32					; size = 4
_FormatNoFs PROC					; COMDAT

; 681  : {

  00000	b8 20 12 00 00	 mov	 eax, 4640		; 00001220H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 1c 12
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+4640], eax

; 682  : 	int write_buf_cnt = 0;
; 683  : 	char sector[TC_MAX_VOLUME_SECTOR_SIZE], *write_buf;
; 684  : 	unsigned __int64 nSecNo = startSector;

  00018	8b 8c 24 28 12
	00 00		 mov	 ecx, DWORD PTR _startSector$[esp+4640]
  0001f	8b 84 24 24 12
	00 00		 mov	 eax, DWORD PTR _startSector$[esp+4636]
  00026	53		 push	 ebx
  00027	8b 9c 24 3c 12
	00 00		 mov	 ebx, DWORD PTR _cryptoInfo$[esp+4640]
  0002e	55		 push	 ebp
  0002f	8b ac 24 3c 12
	00 00		 mov	 ebp, DWORD PTR _dev$[esp+4644]
  00036	56		 push	 esi
  00037	57		 push	 edi

; 685  : 	int retVal = 0;
; 686  : 	DWORD err;
; 687  : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 688  : 	char originalK2[MASTER_KEYDATA_SIZE];
; 689  : 
; 690  : 	LARGE_INTEGER startOffset;
; 691  : 	LARGE_INTEGER newOffset;
; 692  : 
; 693  : 	// Seek to start sector
; 694  : 	startOffset.QuadPart = startSector * FormatSectorSize;

  00038	51		 push	 ecx
  00039	33 d2		 xor	 edx, edx
  0003b	50		 push	 eax
  0003c	89 44 24 20	 mov	 DWORD PTR _nSecNo$[esp+4664], eax
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	89 54 24 30	 mov	 DWORD PTR _write_buf_cnt$[esp+4672], edx
  0004b	89 4c 24 2c	 mov	 DWORD PTR _nSecNo$[esp+4676], ecx
  0004f	89 54 24 20	 mov	 DWORD PTR _retVal$[esp+4672], edx
  00053	e8 00 00 00 00	 call	 __allmul

; 695  : 	if (!SetFilePointerEx ((HANDLE) dev, startOffset, &newOffset, FILE_BEGIN)
; 696  : 		|| newOffset.QuadPart != startOffset.QuadPart)

  00058	6a 00		 push	 0
  0005a	8d 4c 24 28	 lea	 ecx, DWORD PTR _newOffset$[esp+4660]
  0005e	51		 push	 ecx
  0005f	8b fa		 mov	 edi, edx
  00061	57		 push	 edi
  00062	8b f0		 mov	 esi, eax
  00064	56		 push	 esi
  00065	55		 push	 ebp
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 92 02 00
	00		 je	 $LN42@FormatNoFs
  00074	8b 54 24 24	 mov	 edx, DWORD PTR _newOffset$[esp+4656]
  00078	3b d6		 cmp	 edx, esi
  0007a	0f 85 86 02 00
	00		 jne	 $LN42@FormatNoFs
  00080	8b 44 24 28	 mov	 eax, DWORD PTR _newOffset$[esp+4660]
  00084	3b c7		 cmp	 eax, edi
  00086	0f 85 7a 02 00
	00		 jne	 $LN42@FormatNoFs

; 699  : 	}
; 700  : 
; 701  : 	write_buf = (char *)TCalloc (FormatWriteBufferSize);

  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _FormatWriteBufferSize
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _malloc
  00098	83 c4 04	 add	 esp, 4
  0009b	89 44 24 14	 mov	 DWORD PTR _write_buf$[esp+4656], eax

; 702  : 	if (!write_buf)

  0009f	85 c0		 test	 eax, eax
  000a1	75 0a		 jne	 SHORT $LN41@FormatNoFs

; 703  : 		return ERR_OUTOFMEMORY;

  000a3	b8 02 00 00 00	 mov	 eax, 2
  000a8	e9 5e 02 00 00	 jmp	 $LN44@FormatNoFs
$LN41@FormatNoFs:

; 704  : 
; 705  : 	VirtualLock (temporaryKey, sizeof (temporaryKey));

  000ad	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  000b3	68 00 01 00 00	 push	 256			; 00000100H
  000b8	8d 54 24 30	 lea	 edx, DWORD PTR _temporaryKey$[esp+4660]
  000bc	52		 push	 edx
  000bd	ff d6		 call	 esi

; 706  : 	VirtualLock (originalK2, sizeof (originalK2));

  000bf	68 00 01 00 00	 push	 256			; 00000100H
  000c4	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _originalK2$[esp+4660]
  000cb	50		 push	 eax
  000cc	ff d6		 call	 esi

; 707  : 
; 708  : 	memset (sector, 0, sizeof (sector));

  000ce	68 00 10 00 00	 push	 4096			; 00001000H
  000d3	8d 8c 24 30 02
	00 00		 lea	 ecx, DWORD PTR _sector$[esp+4660]
  000da	6a 00		 push	 0
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _memset
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 709  : 
; 710  : 	// Remember the original secondary key (XTS mode) before generating a temporary one
; 711  : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 712  : 
; 713  : 	/* Fill the rest of the data area with random data */
; 714  : 
; 715  : 	if(!quickFormat)

  000e5	83 bc 24 4c 12
	00 00 00	 cmp	 DWORD PTR _quickFormat$[esp+4652], 0
  000ed	8d b3 a8 42 00
	00		 lea	 esi, DWORD PTR [ebx+17064]
  000f3	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f8	8d bc 24 2c 01
	00 00		 lea	 edi, DWORD PTR _originalK2$[esp+4656]
  000ff	f3 a5		 rep movsd
  00101	0f 85 e1 00 00
	00		 jne	 $LN40@FormatNoFs

; 716  : 	{
; 717  : 		/* Generate a random temporary key set to be used for "dummy" encryption that will fill
; 718  : 		the free disk space (data area) with random data.  This is necessary for plausible
; 719  : 		deniability of hidden volumes. */
; 720  : 
; 721  : 		// Temporary master key
; 722  : 		if (!RandgetBytes ((unsigned char*)temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE))

  00107	8b 13		 mov	 edx, DWORD PTR [ebx]
  00109	6a 00		 push	 0
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _EAGetKeySize
  00111	83 c4 04	 add	 esp, 4
  00114	50		 push	 eax
  00115	8d 44 24 34	 lea	 eax, DWORD PTR _temporaryKey$[esp+4664]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _RandgetBytes
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00122	85 c0		 test	 eax, eax
  00124	0f 84 3e 01 00
	00		 je	 $fail$81756

; 723  : 			goto fail;
; 724  : 
; 725  : 		// Temporary secondary key (XTS mode)
; 726  : 		if (!RandgetBytes (cryptoInfo->k2, sizeof cryptoInfo->k2, FALSE))

  0012a	6a 00		 push	 0
  0012c	8d 83 a8 42 00
	00		 lea	 eax, DWORD PTR [ebx+17064]
  00132	68 00 01 00 00	 push	 256			; 00000100H
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _RandgetBytes
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	85 c0		 test	 eax, eax
  00142	0f 84 20 01 00
	00		 je	 $fail$81756

; 727  : 			goto fail;
; 728  : 
; 729  : 		retVal = EAInit (cryptoInfo->ea, (unsigned char*)temporaryKey, cryptoInfo->ks);

  00148	8b 03		 mov	 eax, DWORD PTR [ebx]
  0014a	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  0014d	51		 push	 ecx
  0014e	8d 54 24 30	 lea	 edx, DWORD PTR _temporaryKey$[esp+4660]
  00152	52		 push	 edx
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _EAInit
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015c	89 44 24 10	 mov	 DWORD PTR _retVal$[esp+4656], eax

; 730  : 		if (retVal != ERR_SUCCESS)

  00160	85 c0		 test	 eax, eax
  00162	0f 85 00 01 00
	00		 jne	 $fail$81756

; 731  : 			goto fail;
; 732  : 
; 733  : 		if (!EAInitMode (cryptoInfo))

  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 _EAInitMode
  0016e	83 c4 04	 add	 esp, 4
  00171	85 c0		 test	 eax, eax

; 774  : 
; 775  : fail:

  00173	0f 84 e7 00 00
	00		 je	 $LN119@FormatNoFs
  00179	8b b4 24 3c 12
	00 00		 mov	 esi, DWORD PTR _num_sectors$[esp+4652]
  00180	8b bc 24 40 12
	00 00		 mov	 edi, DWORD PTR _num_sectors$[esp+4656]
  00187	8b ce		 mov	 ecx, esi
  00189	0b cf		 or	 ecx, edi
  0018b	74 38		 je	 SHORT $LN105@FormatNoFs
  0018d	8d 49 00	 npad	 3
$LL31@FormatNoFs:

; 734  : 		{
; 735  : 			retVal = ERR_MODE_INIT_FAILED;
; 736  : 			goto fail;
; 737  : 		}
; 738  : 
; 739  : 		while (num_sectors--)
; 740  : 		{
; 741  : 			if (WriteSector (dev, sector, write_buf, &write_buf_cnt, (__int64*)&nSecNo,
; 742  : 				cryptoInfo) == FALSE)

  00190	8b 4c 24 14	 mov	 ecx, DWORD PTR _write_buf$[esp+4656]
  00194	53		 push	 ebx
  00195	8d 54 24 1c	 lea	 edx, DWORD PTR _nSecNo$[esp+4660]
  00199	52		 push	 edx
  0019a	8d 44 24 28	 lea	 eax, DWORD PTR _write_buf_cnt$[esp+4664]
  0019e	50		 push	 eax
  0019f	51		 push	 ecx
  001a0	8d 94 24 3c 02
	00 00		 lea	 edx, DWORD PTR _sector$[esp+4672]
  001a7	52		 push	 edx
  001a8	83 c6 ff	 add	 esi, -1
  001ab	55		 push	 ebp
  001ac	83 d7 ff	 adc	 edi, -1
  001af	e8 00 00 00 00	 call	 _WriteSector
  001b4	83 c4 18	 add	 esp, 24			; 00000018H
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 a9 00 00
	00		 je	 $fail$81756
  001bf	8b c6		 mov	 eax, esi
  001c1	0b c7		 or	 eax, edi
  001c3	75 cb		 jne	 SHORT $LL31@FormatNoFs
$LN105@FormatNoFs:

; 743  : 				goto fail;
; 744  : 		}
; 745  : 
; 746  : 		if (!FlushFormatWriteBuffer (dev, write_buf, &write_buf_cnt, (__int64*)&nSecNo, cryptoInfo))

  001c5	8b 44 24 14	 mov	 eax, DWORD PTR _write_buf$[esp+4656]
  001c9	53		 push	 ebx
  001ca	8d 4c 24 1c	 lea	 ecx, DWORD PTR _nSecNo$[esp+4660]
  001ce	51		 push	 ecx
  001cf	8d 54 24 28	 lea	 edx, DWORD PTR _write_buf_cnt$[esp+4664]
  001d3	52		 push	 edx
  001d4	50		 push	 eax
  001d5	55		 push	 ebp
  001d6	e8 00 00 00 00	 call	 _FlushFormatWriteBuffer
  001db	83 c4 14	 add	 esp, 20			; 00000014H
  001de	85 c0		 test	 eax, eax
  001e0	0f 84 82 00 00
	00		 je	 $fail$81756

; 747  : 			goto fail;
; 748  : 	}
; 749  : 	else

  001e6	eb 16		 jmp	 SHORT $LN25@FormatNoFs
$LN40@FormatNoFs:

; 750  : 		nSecNo = num_sectors;

  001e8	8b 8c 24 3c 12
	00 00		 mov	 ecx, DWORD PTR _num_sectors$[esp+4652]
  001ef	8b 94 24 40 12
	00 00		 mov	 edx, DWORD PTR _num_sectors$[esp+4656]
  001f6	89 4c 24 18	 mov	 DWORD PTR _nSecNo$[esp+4656], ecx
  001fa	89 54 24 1c	 mov	 DWORD PTR _nSecNo$[esp+4660], edx
$LN25@FormatNoFs:

; 751  : 
; 752  : 	UpdateProgressBar (nSecNo * FormatSectorSize);

  001fe	8b 44 24 1c	 mov	 eax, DWORD PTR _nSecNo$[esp+4660]
  00202	8b 4c 24 18	 mov	 ecx, DWORD PTR _nSecNo$[esp+4656]
  00206	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  0020c	50		 push	 eax
  0020d	51		 push	 ecx
  0020e	6a 00		 push	 0
  00210	52		 push	 edx
  00211	e8 00 00 00 00	 call	 __allmul
  00216	52		 push	 edx
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 _UpdateProgressBar

; 753  : 
; 754  : 	// Restore the original secondary key (XTS mode) in case NTFS format fails and the user wants to try FAT immediately
; 755  : 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
; 756  : 
; 757  : 	// Reinitialize the encryption algorithm and mode in case NTFS format fails and the user wants to try FAT immediately
; 758  : 	retVal = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);

  0021d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0021f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00224	8d b4 24 34 01
	00 00		 lea	 esi, DWORD PTR _originalK2$[esp+4664]
  0022b	8d bb a8 42 00
	00		 lea	 edi, DWORD PTR [ebx+17064]
  00231	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00234	f3 a5		 rep movsd
  00236	50		 push	 eax
  00237	8d 8b a8 41 00
	00		 lea	 ecx, DWORD PTR [ebx+16808]
  0023d	51		 push	 ecx
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 _EAInit
  00244	83 c4 14	 add	 esp, 20			; 00000014H
  00247	89 44 24 10	 mov	 DWORD PTR _retVal$[esp+4656], eax

; 759  : 	if (retVal != ERR_SUCCESS)

  0024b	85 c0		 test	 eax, eax
  0024d	75 19		 jne	 SHORT $fail$81756

; 760  : 		goto fail;
; 761  : 	if (!EAInitMode (cryptoInfo))

  0024f	53		 push	 ebx
  00250	e8 00 00 00 00	 call	 _EAInitMode
  00255	83 c4 04	 add	 esp, 4
  00258	85 c0		 test	 eax, eax
  0025a	0f 85 c4 00 00
	00		 jne	 $LN20@FormatNoFs
$LN119@FormatNoFs:

; 762  : 	{
; 763  : 		retVal = ERR_MODE_INIT_FAILED;

  00260	c7 44 24 10 1b
	00 00 00	 mov	 DWORD PTR _retVal$[esp+4656], 27 ; 0000001bH
$fail$81756:

; 776  : 	err = GetLastError();

  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 777  : 
; 778  : 	burn (temporaryKey, sizeof(temporaryKey));

  0026e	8d 54 24 2c	 lea	 edx, DWORD PTR _temporaryKey$[esp+4656]
  00272	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00277	8b f8		 mov	 edi, eax
  00279	8b f1		 mov	 esi, ecx
  0027b	8b c2		 mov	 eax, edx
  0027d	8d 49 00	 npad	 3
$LL57@FormatNoFs:
  00280	c6 00 00	 mov	 BYTE PTR [eax], 0
  00283	40		 inc	 eax
  00284	83 ee 01	 sub	 esi, 1
  00287	75 f7		 jne	 SHORT $LL57@FormatNoFs
  00289	8d a4 24 00 00
	00 00		 npad	 7
$LL7@FormatNoFs:
  00290	49		 dec	 ecx
  00291	c6 02 00	 mov	 BYTE PTR [edx], 0
  00294	42		 inc	 edx
  00295	85 c9		 test	 ecx, ecx
  00297	75 f7		 jne	 SHORT $LL7@FormatNoFs

; 779  : 	burn (originalK2, sizeof(originalK2));

  00299	8d 94 24 2c 01
	00 00		 lea	 edx, DWORD PTR _originalK2$[esp+4656]
  002a0	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  002a5	8b f1		 mov	 esi, ecx
  002a7	8b c2		 mov	 eax, edx
  002a9	8d a4 24 00 00
	00 00		 npad	 7
$LL61@FormatNoFs:
  002b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  002b3	40		 inc	 eax
  002b4	83 ee 01	 sub	 esi, 1
  002b7	75 f7		 jne	 SHORT $LL61@FormatNoFs
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL2@FormatNoFs:
  002c0	49		 dec	 ecx
  002c1	c6 02 00	 mov	 BYTE PTR [edx], 0
  002c4	42		 inc	 edx
  002c5	85 c9		 test	 ecx, ecx
  002c7	75 f7		 jne	 SHORT $LL2@FormatNoFs

; 780  : 	VirtualUnlock (temporaryKey, sizeof (temporaryKey));

  002c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  002cf	68 00 01 00 00	 push	 256			; 00000100H
  002d4	8d 44 24 30	 lea	 eax, DWORD PTR _temporaryKey$[esp+4660]
  002d8	50		 push	 eax
  002d9	ff d6		 call	 esi

; 781  : 	VirtualUnlock (originalK2, sizeof (originalK2));

  002db	68 00 01 00 00	 push	 256			; 00000100H
  002e0	8d 8c 24 30 01
	00 00		 lea	 ecx, DWORD PTR _originalK2$[esp+4660]
  002e7	51		 push	 ecx
  002e8	ff d6		 call	 esi

; 782  : 	TCfree (write_buf);

  002ea	8b 54 24 14	 mov	 edx, DWORD PTR _write_buf$[esp+4656]
  002ee	52		 push	 edx
  002ef	e8 00 00 00 00	 call	 _free
  002f4	83 c4 04	 add	 esp, 4

; 783  : 
; 784  : 	SetLastError (err);

  002f7	57		 push	 edi
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 785  : 	return (retVal ? retVal : ERR_OS_ERROR);

  002fe	8b 44 24 10	 mov	 eax, DWORD PTR _retVal$[esp+4656]
  00302	85 c0		 test	 eax, eax
  00304	75 05		 jne	 SHORT $LN44@FormatNoFs
$LN42@FormatNoFs:

; 697  : 	{
; 698  : 		return ERR_OS_ERROR;

  00306	b8 01 00 00 00	 mov	 eax, 1
$LN44@FormatNoFs:

; 786  : }

  0030b	8b 8c 24 2c 12
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+4656]
  00312	5f		 pop	 edi
  00313	5e		 pop	 esi
  00314	5d		 pop	 ebp
  00315	5b		 pop	 ebx
  00316	33 cc		 xor	 ecx, esp
  00318	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031d	81 c4 20 12 00
	00		 add	 esp, 4640		; 00001220H
  00323	c3		 ret	 0
$LN20@FormatNoFs:

; 764  : 		goto fail;
; 765  : 	}
; 766  : 
; 767  : 	burn (temporaryKey, sizeof(temporaryKey));

  00324	8d 54 24 2c	 lea	 edx, DWORD PTR _temporaryKey$[esp+4656]
  00328	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0032d	8b f1		 mov	 esi, ecx
  0032f	8b c2		 mov	 eax, edx
$LL49@FormatNoFs:
  00331	c6 00 00	 mov	 BYTE PTR [eax], 0
  00334	40		 inc	 eax
  00335	83 ee 01	 sub	 esi, 1
  00338	75 f7		 jne	 SHORT $LL49@FormatNoFs
  0033a	8d 9b 00 00 00
	00		 npad	 6
$LL17@FormatNoFs:
  00340	49		 dec	 ecx
  00341	c6 02 00	 mov	 BYTE PTR [edx], 0
  00344	42		 inc	 edx
  00345	85 c9		 test	 ecx, ecx
  00347	75 f7		 jne	 SHORT $LL17@FormatNoFs

; 768  : 	burn (originalK2, sizeof(originalK2));

  00349	8d 94 24 2c 01
	00 00		 lea	 edx, DWORD PTR _originalK2$[esp+4656]
  00350	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00355	8b f1		 mov	 esi, ecx
  00357	8b c2		 mov	 eax, edx
  00359	8d a4 24 00 00
	00 00		 npad	 7
$LL53@FormatNoFs:
  00360	c6 00 00	 mov	 BYTE PTR [eax], 0
  00363	40		 inc	 eax
  00364	83 ee 01	 sub	 esi, 1
  00367	75 f7		 jne	 SHORT $LL53@FormatNoFs
  00369	8d a4 24 00 00
	00 00		 npad	 7
$LL12@FormatNoFs:
  00370	49		 dec	 ecx
  00371	c6 02 00	 mov	 BYTE PTR [edx], 0
  00374	42		 inc	 edx
  00375	85 c9		 test	 ecx, ecx
  00377	75 f7		 jne	 SHORT $LL12@FormatNoFs

; 769  : 	VirtualUnlock (temporaryKey, sizeof (temporaryKey));

  00379	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  0037f	68 00 01 00 00	 push	 256			; 00000100H
  00384	8d 44 24 30	 lea	 eax, DWORD PTR _temporaryKey$[esp+4660]
  00388	50		 push	 eax
  00389	ff d6		 call	 esi

; 770  : 	VirtualUnlock (originalK2, sizeof (originalK2));

  0038b	68 00 01 00 00	 push	 256			; 00000100H
  00390	8d 8c 24 30 01
	00 00		 lea	 ecx, DWORD PTR _originalK2$[esp+4660]
  00397	51		 push	 ecx
  00398	ff d6		 call	 esi

; 771  : 	TCfree (write_buf);

  0039a	8b 54 24 14	 mov	 edx, DWORD PTR _write_buf$[esp+4656]
  0039e	52		 push	 edx
  0039f	e8 00 00 00 00	 call	 _free
  003a4	83 c4 04	 add	 esp, 4

; 772  : 
; 773  : 	return 0;

  003a7	33 c0		 xor	 eax, eax
  003a9	e9 5d ff ff ff	 jmp	 $LN44@FormatNoFs
_FormatNoFs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@	; `string'
PUBLIC	??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@	; `string'
PUBLIC	??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@		; `string'
PUBLIC	??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@ ; `string'
PUBLIC	??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@	; `string'
PUBLIC	??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@		; `string'
PUBLIC	??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@ ; `string'
PUBLIC	??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_TCFormatVolume
EXTRN	_crypto_close:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	_AskErrYesNo:PROC
EXTRN	_UnmountVolume:PROC
EXTRN	_UacFormatNtfs:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_MountVolume:PROC
EXTRN	_GetLastAvailableDrive:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_FormatFat:PROC
EXTRN	_GetFatParams:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__SetEndOfFile@4:PROC
EXTRN	_DisableFileCompression:PROC
EXTRN	_Error:PROC
EXTRN	__imp__FlushFileBuffers@4:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_GetString:PROC
EXTRN	_lpszTitle:DWORD
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__DeleteVolumeMountPointA@4:PROC
EXTRN	__imp__SetVolumeMountPointA@8:PROC
EXTRN	__imp__GetVolumeNameForVolumeMountPointA@12:PROC
EXTRN	_GetFirstAvailableDrive:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	_DismountDrive:PROC
EXTRN	_IsDeviceMounted:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	__imp__DefineDosDeviceA@12:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	__aullrem:PROC
EXTRN	__aulldiv:PROC
;	COMDAT ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
CONST	SEGMENT
??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@ DB 'SECTOR_SIZE_UNSUPPORT'
	DB	'ED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@
CONST	SEGMENT
??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@ DB 'FORMAT_NTFS_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@ DB 'CANT_MOUNT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
CONST	SEGMENT
??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@ DB 'FORMAT_NTFS_STOP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
CONST	SEGMENT
??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@ DB 'NO_FREE_DRIVES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@
CONST	SEGMENT
??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@ DB 'FORMAT_NTFS_FAILED'
	DB	'_ASK_FAT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
CONST	SEGMENT
??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@ DB 'CANT_DISMOUNT_VOLUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@ DB 'NO NAME    ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
CONST	SEGMENT
??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@ DB 'CANT_ACCESS_VOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@
CONST	SEGMENT
??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@ DB 'FORMAT_CANT_DISM'
	DB	'OUNT_FILESYS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@
CONST	SEGMENT
??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@ DB 'DEVICE_IN_USE_FORMAT', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\format.cpp
CONST	ENDS
;	COMDAT _TCFormatVolume
_TEXT	SEGMENT
_cryptoInfo$ = -140836					; size = 4
_szDriveLetter$81565 = -140832				; size = 3
_rootPath$81566 = -140828				; size = 4
_bInstantRetryOtherFilesys$ = -140824			; size = 4
_dataAreaSize$ = -140820				; size = 8
_dwError$ = -140812					; size = 4
_nPass$81553 = -140812					; size = 4
_dataOffset$ = -140808					; size = 8
_bTimeStampValid$ = -140800				; size = 4
_bFailedRequiredDASD$ = -140796				; size = 4
_driveLetter$ = -140792					; size = 4
_dwResult$81552 = -140788				; size = 4
_num_sectors$ = -140784					; size = 8
_bytesWritten$81646 = -140776				; size = 4
_ftLastWriteTime$ = -140772				; size = 8
_ftLastAccessTime$ = -140764				; size = 8
_ftCreationTime$ = -140756				; size = 8
_tmp$81616 = -140748					; size = 4
_bw$81601 = -140744					; size = 4
_ft$ = -140740						; size = 68
_mountOptions$81709 = -140672				; size = 100
_devName$ = -140572					; size = 260
_header$ = -140312					; size = 512
_dosDev$ = -139800					; size = 260
_uniqVolName$81567 = -139540				; size = 261
_deviceName$ = -139276					; size = 520
_buf$81600 = -138756					; size = 8192
_buf$81645 = -130564					; size = 130560
__$ArrayPad$ = -4					; size = 4
_volParams$ = 8						; size = 4
_TCFormatVolume PROC					; COMDAT

; 76   : {

  00000	b8 24 26 02 00	 mov	 eax, 140836		; 00022624H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 20 26
	02 00		 mov	 DWORD PTR __$ArrayPad$[esp+140836], eax
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b b4 24 30 26
	02 00		 mov	 esi, DWORD PTR _volParams$[esp+140840]
  00021	57		 push	 edi

; 77   : 	int nStatus;
; 78   : 	PCRYPTO_INFO cryptoInfo = NULL;

  00022	33 db		 xor	 ebx, ebx

; 79   : 	HANDLE dev = INVALID_HANDLE_VALUE;
; 80   : 	DWORD dwError;
; 81   : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 82   : 	unsigned __int64 num_sectors, startSector;
; 83   : 	fatparams ft;
; 84   : 	FILETIME ftCreationTime;
; 85   : 	FILETIME ftLastWriteTime;
; 86   : 	FILETIME ftLastAccessTime;
; 87   : 	BOOL bTimeStampValid = FALSE;
; 88   : 	BOOL bInstantRetryOtherFilesys = FALSE;
; 89   : 	char dosDev[TC_MAX_PATH] = { 0 };

  00024	68 03 01 00 00	 push	 259			; 00000103H
  00029	8d 84 24 1d 04
	00 00		 lea	 eax, DWORD PTR _dosDev$[esp+140853]
  00030	53		 push	 ebx
  00031	50		 push	 eax
  00032	89 5c 24 18	 mov	 DWORD PTR _cryptoInfo$[esp+140860], ebx
  00036	83 cf ff	 or	 edi, -1
  00039	89 5c 24 3c	 mov	 DWORD PTR _bTimeStampValid$[esp+140860], ebx
  0003d	89 5c 24 24	 mov	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140860], ebx
  00041	88 9c 24 24 04
	00 00		 mov	 BYTE PTR _dosDev$[esp+140860], bl
  00048	e8 00 00 00 00	 call	 _memset

; 90   : 	char devName[MAX_PATH] = { 0 };

  0004d	68 03 01 00 00	 push	 259			; 00000103H
  00052	8d 8c 24 25 01
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+140865]
  00059	53		 push	 ebx
  0005a	51		 push	 ecx
  0005b	88 9c 24 2c 01
	00 00		 mov	 BYTE PTR _devName$[esp+140872], bl
  00062	e8 00 00 00 00	 call	 _memset

; 91   : 	int driveLetter = -1;
; 92   : 	WCHAR deviceName[MAX_PATH];
; 93   : 	uint64 dataOffset, dataAreaSize;
; 94   : 	LARGE_INTEGER offset;
; 95   : 	BOOL bFailedRequiredDASD = FALSE;
; 96   : 
; 97   : 	FormatSectorSize = volParams->sectorSize;

  00067	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]

; 98   : 
; 99   : 	if (FormatSectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 100  : 		|| FormatSectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 101  : 		|| FormatSectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  0006a	8b c2		 mov	 eax, edx
  0006c	8d 88 00 fe ff
	ff		 lea	 ecx, DWORD PTR [eax-512]
  00072	83 c4 18	 add	 esp, 24			; 00000018H
  00075	89 7c 24 38	 mov	 DWORD PTR _driveLetter$[esp+140848], edi
  00079	89 5c 24 34	 mov	 DWORD PTR _bFailedRequiredDASD$[esp+140848], ebx
  0007d	89 15 00 00 00
	00		 mov	 DWORD PTR _FormatSectorSize, edx
  00083	81 f9 00 0e 00
	00		 cmp	 ecx, 3584		; 00000e00H
  00089	0f 87 71 0c 00
	00		 ja	 $LN125@TCFormatVo
  0008f	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  00094	0f 85 66 0c 00
	00		 jne	 $LN125@TCFormatVo

; 104  : 		return ERR_DONT_REPORT; 
; 105  : 	}
; 106  : 
; 107  : 	/* WARNING: Note that if Windows fails to format the volume as NTFS and the volume size is
; 108  : 	less than the maximum FAT size, the user is asked within this function whether he wants to instantly
; 109  : 	retry FAT format instead (to avoid having to re-create the whole container again). If the user
; 110  : 	answers yes, some of the input parameters are modified, the code below 'begin_format' is re-executed 
; 111  : 	and some destructive operations that were performed during the first attempt must be (and are) skipped. 
; 112  : 	Therefore, whenever adding or modifying any potentially destructive operations below 'begin_format',
; 113  : 	determine whether they (or their portions) need to be skipped during such a second attempt; if so, 
; 114  : 	use the 'bInstantRetryOtherFilesys' flag to skip them. */
; 115  : 
; 116  : 	if (volParams->hiddenVol)

  0009a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009d	85 d2		 test	 edx, edx
  0009f	74 21		 je	 SHORT $LN124@TCFormatVo

; 117  : 	{
; 118  : 		dataOffset = volParams->hiddenVolHostSize - TC_VOLUME_HEADER_GROUP_SIZE - volParams->size;

  000a1	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000a4	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000a7	b8 00 00 fe ff	 mov	 eax, -131072		; fffe0000H
  000ac	2b c1		 sub	 eax, ecx
  000ae	8b cf		 mov	 ecx, edi
  000b0	1b ca		 sbb	 ecx, edx
  000b2	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  000b5	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  000b8	03 d0		 add	 edx, eax
  000ba	89 54 24 28	 mov	 DWORD PTR _dataOffset$[esp+140848], edx
  000be	13 d9		 adc	 ebx, ecx

; 119  : 	}
; 120  : 	else

  000c0	eb 36		 jmp	 SHORT $LN223@TCFormatVo
$LN124@TCFormatVo:

; 121  : 	{
; 122  : 		if (volParams->size <= TC_TOTAL_VOLUME_HEADERS_SIZE)

  000c2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c5	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  000c8	77 26		 ja	 SHORT $LN122@TCFormatVo
  000ca	72 07		 jb	 SHORT $LN184@TCFormatVo
  000cc	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  000d1	77 1d		 ja	 SHORT $LN122@TCFormatVo
$LN184@TCFormatVo:
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi

; 123  : 			return ERR_VOL_SIZE_WRONG;

  000d5	b8 07 00 00 00	 mov	 eax, 7
  000da	5b		 pop	 ebx

; 677  : }

  000db	8b 8c 24 20 26
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140836]
  000e2	33 cc		 xor	 ecx, esp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	81 c4 24 26 02
	00		 add	 esp, 140836		; 00022624H
  000ef	c3		 ret	 0
$LN122@TCFormatVo:

; 124  : 
; 125  : 		dataOffset = TC_VOLUME_DATA_OFFSET;

  000f0	c7 44 24 28 00
	00 02 00	 mov	 DWORD PTR _dataOffset$[esp+140848], 131072 ; 00020000H
$LN223@TCFormatVo:

; 126  : 	}
; 127  : 
; 128  : 	dataAreaSize = GetVolumeDataAreaSize (volParams->hiddenVol, volParams->size);

  000f8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000fb	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000fe	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00101	55		 push	 ebp
  00102	50		 push	 eax
  00103	51		 push	 ecx
  00104	52		 push	 edx
  00105	89 5c 24 3c	 mov	 DWORD PTR _dataOffset$[esp+140868], ebx
  00109	e8 00 00 00 00	 call	 _GetVolumeDataAreaSize
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	8b e8		 mov	 ebp, eax

; 129  : 
; 130  : 	num_sectors = dataAreaSize / FormatSectorSize;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00118	6a 00		 push	 0
  0011a	8b da		 mov	 ebx, edx
  0011c	50		 push	 eax
  0011d	53		 push	 ebx
  0011e	55		 push	 ebp
  0011f	89 6c 24 30	 mov	 DWORD PTR _dataAreaSize$[esp+140868], ebp
  00123	89 5c 24 34	 mov	 DWORD PTR _dataAreaSize$[esp+140872], ebx
  00127	e8 00 00 00 00	 call	 __aulldiv

; 131  : 
; 132  : 	if (volParams->bDevice)

  0012c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012e	89 44 24 44	 mov	 DWORD PTR _num_sectors$[esp+140852], eax
  00132	89 54 24 48	 mov	 DWORD PTR _num_sectors$[esp+140856], edx
  00136	85 c9		 test	 ecx, ecx
  00138	74 35		 je	 SHORT $LN121@TCFormatVo

; 133  : 	{
; 134  : 		strcpy ((char *)deviceName, volParams->volumePath);

  0013a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013d	8d 94 24 28 06
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+140852]
$LL129@TCFormatVo:
  00144	8a 01		 mov	 al, BYTE PTR [ecx]
  00146	88 02		 mov	 BYTE PTR [edx], al
  00148	41		 inc	 ecx
  00149	42		 inc	 edx
  0014a	84 c0		 test	 al, al
  0014c	75 f6		 jne	 SHORT $LL129@TCFormatVo

; 135  : 		ToUNICODE ((char *)deviceName);

  0014e	8d 94 24 28 06
	00 00		 lea	 edx, DWORD PTR _deviceName$[esp+140852]
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 _ToUNICODE

; 136  : 
; 137  : 		driveLetter = GetDiskDeviceDriveLetter (deviceName);

  0015b	8d 84 24 2c 06
	00 00		 lea	 eax, DWORD PTR _deviceName$[esp+140856]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  00168	83 c4 08	 add	 esp, 8
  0016b	89 44 24 3c	 mov	 DWORD PTR _driveLetter$[esp+140852], eax
$LN121@TCFormatVo:

; 138  : 	}
; 139  : 
; 140  : 	VirtualLock (header, sizeof (header));

  0016f	68 00 02 00 00	 push	 512			; 00000200H
  00174	8d 8c 24 20 02
	00 00		 lea	 ecx, DWORD PTR _header$[esp+140856]
  0017b	51		 push	 ecx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 141  : 
; 142  : 	nStatus = CreateVolumeHeaderInMemory (FALSE,
; 143  : 				     header,
; 144  : 				     volParams->ea,
; 145  : 					 FIRST_MODE_OF_OPERATION_ID,
; 146  : 				     volParams->password,
; 147  : 				     volParams->pkcs5,
; 148  : 					 NULL,
; 149  : 				     &cryptoInfo,
; 150  : 					 dataAreaSize,
; 151  : 					 volParams->hiddenVol ? dataAreaSize : 0,
; 152  : 					 dataOffset,
; 153  : 					 dataAreaSize,
; 154  : 					 0,
; 155  : 					 volParams->headerFlags,
; 156  : 					 FormatSectorSize,
; 157  : 					 FALSE);

  00182	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00185	85 d2		 test	 edx, edx
  00187	74 06		 je	 SHORT $LN130@TCFormatVo
  00189	8b c5		 mov	 eax, ebp
  0018b	8b cb		 mov	 ecx, ebx
  0018d	eb 04		 jmp	 SHORT $LN131@TCFormatVo
$LN130@TCFormatVo:
  0018f	33 c0		 xor	 eax, eax
  00191	33 c9		 xor	 ecx, ecx
$LN131@TCFormatVo:
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  00199	6a 00		 push	 0
  0019b	52		 push	 edx
  0019c	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0019f	52		 push	 edx
  001a0	8b 54 24 3c	 mov	 edx, DWORD PTR _dataOffset$[esp+140868]
  001a4	6a 00		 push	 0
  001a6	53		 push	 ebx
  001a7	55		 push	 ebp
  001a8	52		 push	 edx
  001a9	8b 54 24 48	 mov	 edx, DWORD PTR _dataOffset$[esp+140880]
  001ad	52		 push	 edx
  001ae	51		 push	 ecx
  001af	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  001b2	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  001b5	50		 push	 eax
  001b6	53		 push	 ebx
  001b7	55		 push	 ebp
  001b8	8d 44 24 40	 lea	 eax, DWORD PTR _cryptoInfo$[esp+140900]
  001bc	50		 push	 eax
  001bd	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001c0	6a 00		 push	 0
  001c2	51		 push	 ecx
  001c3	52		 push	 edx
  001c4	6a 01		 push	 1
  001c6	50		 push	 eax
  001c7	8d 8c 24 64 02
	00 00		 lea	 ecx, DWORD PTR _header$[esp+140924]
  001ce	51		 push	 ecx
  001cf	6a 00		 push	 0
  001d1	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  001d6	8b d8		 mov	 ebx, eax
  001d8	83 c4 50	 add	 esp, 80			; 00000050H

; 158  : 
; 159  : 	if (nStatus != 0)

  001db	85 db		 test	 ebx, ebx
  001dd	74 58		 je	 SHORT $LN190@TCFormatVo

; 160  : 	{
; 161  : 		burn (header, sizeof (header));

  001df	8d 94 24 1c 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140852]
  001e6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001eb	8b f1		 mov	 esi, ecx
  001ed	8b c2		 mov	 eax, edx
  001ef	90		 npad	 1
$LL141@TCFormatVo:
  001f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001f3	40		 inc	 eax
  001f4	83 ee 01	 sub	 esi, 1
  001f7	75 f7		 jne	 SHORT $LL141@TCFormatVo
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL116@TCFormatVo:
  00200	49		 dec	 ecx
  00201	c6 02 00	 mov	 BYTE PTR [edx], 0
  00204	42		 inc	 edx
  00205	85 c9		 test	 ecx, ecx
  00207	75 f7		 jne	 SHORT $LL116@TCFormatVo

; 162  : 		VirtualUnlock (header, sizeof (header));

  00209	68 00 02 00 00	 push	 512			; 00000200H
  0020e	8d 94 24 20 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140856]
  00215	52		 push	 edx
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 163  : 		return nStatus;

  0021c	8b c3		 mov	 eax, ebx
$LN222@TCFormatVo:
  0021e	5d		 pop	 ebp
  0021f	5f		 pop	 edi
  00220	5e		 pop	 esi
  00221	5b		 pop	 ebx

; 677  : }

  00222	8b 8c 24 20 26
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140836]
  00229	33 cc		 xor	 ecx, esp
  0022b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00230	81 c4 24 26 02
	00		 add	 esp, 140836		; 00022624H
  00236	c3		 ret	 0
$LN190@TCFormatVo:

; 164  : 	}
; 165  : 
; 166  : begin_format:
; 167  : 
; 168  : 	if (volParams->bDevice)

  00237	8b 06		 mov	 eax, DWORD PTR [esi]
  00239	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DefineDosDeviceA@12
  0023f	90		 npad	 1
$begin_format$81550:
  00240	85 c0		 test	 eax, eax
  00242	0f 84 01 03 00
	00		 je	 $LN114@TCFormatVo

; 169  : 	{
; 170  : 		/* Device-hosted volume */
; 171  : 
; 172  : 		DWORD dwResult;
; 173  : 		int nPass;
; 174  : 
; 175  : 		if (FakeDosNameForDevice (volParams->volumePath, dosDev, devName, FALSE) != 0)

  00248	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0024b	6a 00		 push	 0
  0024d	8d 8c 24 1c 01
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+140856]
  00254	51		 push	 ecx
  00255	8d 94 24 24 04
	00 00		 lea	 edx, DWORD PTR _dosDev$[esp+140860]
  0025c	52		 push	 edx
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  00263	83 c4 10	 add	 esp, 16			; 00000010H
  00266	85 c0		 test	 eax, eax
  00268	0f 85 62 09 00
	00		 jne	 $LN159@TCFormatVo

; 177  : 
; 178  : 		if (IsDeviceMounted (devName))

  0026e	8d 8c 24 18 01
	00 00		 lea	 ecx, DWORD PTR _devName$[esp+140852]
  00275	51		 push	 ecx
  00276	e8 00 00 00 00	 call	 _IsDeviceMounted
  0027b	83 c4 04	 add	 esp, 4
  0027e	85 c0		 test	 eax, eax
  00280	74 4f		 je	 SHORT $LN112@TCFormatVo

; 179  : 		{
; 180  : 			if ((dev = DismountDrive (devName, volParams->volumePath)) == INVALID_HANDLE_VALUE)

  00282	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00285	52		 push	 edx
  00286	8d 84 24 1c 01
	00 00		 lea	 eax, DWORD PTR _devName$[esp+140856]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 _DismountDrive
  00293	8b f8		 mov	 edi, eax
  00295	83 c4 08	 add	 esp, 8
  00298	83 ff ff	 cmp	 edi, -1

; 181  : 			{
; 182  : 				Error ("FORMAT_CANT_DISMOUNT_FILESYS");
; 183  : 				nStatus = ERR_DONT_REPORT; 

  0029b	0f 84 71 02 00
	00		 je	 $LN227@TCFormatVo

; 184  : 				goto error;
; 185  : 			}
; 186  : 
; 187  : 			/* Gain "raw" access to the partition (it contains a live filesystem and the filesystem driver 
; 188  : 			would otherwise prevent us from writing to hidden sectors). */
; 189  : 
; 190  : 			if (!DeviceIoControl (dev,
; 191  : 				FSCTL_ALLOW_EXTENDED_DASD_IO,
; 192  : 				NULL,
; 193  : 				0,   
; 194  : 				NULL,
; 195  : 				0,
; 196  : 				&dwResult,
; 197  : 				NULL))

  002a1	6a 00		 push	 0
  002a3	8d 4c 24 44	 lea	 ecx, DWORD PTR _dwResult$81552[esp+140856]
  002a7	51		 push	 ecx
  002a8	6a 00		 push	 0
  002aa	6a 00		 push	 0
  002ac	6a 00		 push	 0
  002ae	6a 00		 push	 0
  002b0	68 83 00 09 00	 push	 589955			; 00090083H
  002b5	57		 push	 edi
  002b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  002bc	85 c0		 test	 eax, eax
  002be	0f 85 dc 00 00
	00		 jne	 $LN209@TCFormatVo

; 198  : 			{
; 199  : 				bFailedRequiredDASD = TRUE;

  002c4	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR _bFailedRequiredDASD$[esp+140852], 1

; 200  : 			}
; 201  : 		}

  002cc	e9 cf 00 00 00	 jmp	 $LN209@TCFormatVo
$LN112@TCFormatVo:

; 202  : 		else if (IsOSAtLeast (WIN_VISTA) && driveLetter == -1)

  002d1	6a 0b		 push	 11			; 0000000bH
  002d3	e8 00 00 00 00	 call	 _IsOSAtLeast
  002d8	83 c4 04	 add	 esp, 4
  002db	85 c0		 test	 eax, eax
  002dd	0f 84 bd 00 00
	00		 je	 $LN209@TCFormatVo
  002e3	83 7c 24 3c ff	 cmp	 DWORD PTR _driveLetter$[esp+140852], -1
  002e8	0f 85 b2 00 00
	00		 jne	 $LN209@TCFormatVo

; 203  : 		{
; 204  : 			// Windows Vista doesn't allow overwriting sectors belonging to an unformatted partition 
; 205  : 			// to which no drive letter has been assigned under the system. This problem can be worked
; 206  : 			// around by assigning a drive letter to the partition temporarily.
; 207  : 
; 208  : 			char szDriveLetter[] = { 'A', ':', 0 };
; 209  : 			char rootPath[] = { 'A', ':', '\\', 0 };
; 210  : 			char uniqVolName[MAX_PATH+1] = { 0 };

  002ee	68 04 01 00 00	 push	 260			; 00000104H
  002f3	8d 94 24 25 05
	00 00		 lea	 edx, DWORD PTR _uniqVolName$81567[esp+140857]
  002fa	6a 00		 push	 0
  002fc	52		 push	 edx
  002fd	c6 44 24 20 41	 mov	 BYTE PTR _szDriveLetter$81565[esp+140864], 65 ; 00000041H
  00302	c6 44 24 21 3a	 mov	 BYTE PTR _szDriveLetter$81565[esp+140865], 58 ; 0000003aH
  00307	c6 44 24 22 00	 mov	 BYTE PTR _szDriveLetter$81565[esp+140866], 0
  0030c	c6 44 24 24 41	 mov	 BYTE PTR _rootPath$81566[esp+140864], 65 ; 00000041H
  00311	c6 44 24 25 3a	 mov	 BYTE PTR _rootPath$81566[esp+140865], 58 ; 0000003aH
  00316	c6 44 24 26 5c	 mov	 BYTE PTR _rootPath$81566[esp+140866], 92 ; 0000005cH
  0031b	c6 44 24 27 00	 mov	 BYTE PTR _rootPath$81566[esp+140867], 0
  00320	c6 84 24 2c 05
	00 00 00	 mov	 BYTE PTR _uniqVolName$81567[esp+140864], 0
  00328	e8 00 00 00 00	 call	 _memset
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 211  : 			int tmpDriveLetter = -1;
; 212  : 			BOOL bResult = FALSE;
; 213  : 
; 214  : 			tmpDriveLetter = GetFirstAvailableDrive ();

  00330	e8 00 00 00 00	 call	 _GetFirstAvailableDrive

; 215  :  
; 216  : 			if (tmpDriveLetter != -1)

  00335	83 f8 ff	 cmp	 eax, -1
  00338	74 66		 je	 SHORT $LN209@TCFormatVo

; 217  : 			{
; 218  : 				rootPath[0] += (char) tmpDriveLetter;

  0033a	00 44 24 18	 add	 BYTE PTR _rootPath$81566[esp+140852], al

; 219  : 				szDriveLetter[0] += (char) tmpDriveLetter;

  0033e	00 44 24 14	 add	 BYTE PTR _szDriveLetter$81565[esp+140852], al

; 220  : 
; 221  : 				if (DefineDosDevice (DDD_RAW_TARGET_PATH, szDriveLetter, volParams->volumePath))

  00342	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00345	50		 push	 eax
  00346	8d 4c 24 18	 lea	 ecx, DWORD PTR _szDriveLetter$81565[esp+140856]
  0034a	51		 push	 ecx
  0034b	6a 01		 push	 1
  0034d	ff d3		 call	 ebx
  0034f	85 c0		 test	 eax, eax
  00351	74 4d		 je	 SHORT $LN209@TCFormatVo

; 222  : 				{
; 223  : 					bResult = GetVolumeNameForVolumeMountPoint (rootPath, uniqVolName, MAX_PATH);

  00353	68 04 01 00 00	 push	 260			; 00000104H
  00358	8d 94 24 24 05
	00 00		 lea	 edx, DWORD PTR _uniqVolName$81567[esp+140856]
  0035f	52		 push	 edx
  00360	8d 44 24 20	 lea	 eax, DWORD PTR _rootPath$81566[esp+140860]
  00364	50		 push	 eax
  00365	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeNameForVolumeMountPointA@12

; 224  : 
; 225  : 					DefineDosDevice (DDD_RAW_TARGET_PATH|DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE,
; 226  : 						szDriveLetter,
; 227  : 						volParams->volumePath);

  0036b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0036e	51		 push	 ecx
  0036f	8d 54 24 18	 lea	 edx, DWORD PTR _szDriveLetter$81565[esp+140856]
  00373	52		 push	 edx
  00374	6a 07		 push	 7
  00376	8b e8		 mov	 ebp, eax
  00378	ff d3		 call	 ebx

; 228  : 
; 229  : 					if (bResult 
; 230  : 						&& SetVolumeMountPoint (rootPath, uniqVolName))

  0037a	85 ed		 test	 ebp, ebp
  0037c	74 22		 je	 SHORT $LN209@TCFormatVo
  0037e	8d 84 24 20 05
	00 00		 lea	 eax, DWORD PTR _uniqVolName$81567[esp+140852]
  00385	50		 push	 eax
  00386	8d 4c 24 1c	 lea	 ecx, DWORD PTR _rootPath$81566[esp+140856]
  0038a	51		 push	 ecx
  0038b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetVolumeMountPointA@8
  00391	85 c0		 test	 eax, eax
  00393	74 0b		 je	 SHORT $LN209@TCFormatVo

; 231  : 					{
; 232  : 						// The drive letter can be removed now
; 233  : 						DeleteVolumeMountPoint (rootPath);

  00395	8d 54 24 18	 lea	 edx, DWORD PTR _rootPath$81566[esp+140852]
  00399	52		 push	 edx
  0039a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteVolumeMountPointA@4
$LN209@TCFormatVo:

; 234  : 					}
; 235  : 				}
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 		// For extra safety, we will try to gain "raw" access to the partition. Note that this should actually be
; 240  : 		// redundant because if the filesystem was mounted, we already tried to obtain DASD above. If we failed,
; 241  : 		// bFailedRequiredDASD was set to TRUE and therefore we will perform pseudo "quick format" below. However, 
; 242  : 		// for extra safety, in case IsDeviceMounted() failed to detect a live filesystem, we will blindly
; 243  : 		// send FSCTL_ALLOW_EXTENDED_DASD_IO (possibly for a second time) without checking the result.
; 244  : 
; 245  : 		DeviceIoControl (dev,
; 246  : 			FSCTL_ALLOW_EXTENDED_DASD_IO,
; 247  : 			NULL,
; 248  : 			0,   
; 249  : 			NULL,
; 250  : 			0,
; 251  : 			&dwResult,
; 252  : 			NULL);

  003a0	6a 00		 push	 0
  003a2	8d 44 24 44	 lea	 eax, DWORD PTR _dwResult$81552[esp+140856]
  003a6	50		 push	 eax
  003a7	6a 00		 push	 0
  003a9	6a 00		 push	 0
  003ab	6a 00		 push	 0
  003ad	6a 00		 push	 0
  003af	68 83 00 09 00	 push	 589955			; 00090083H
  003b4	57		 push	 edi
  003b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 253  : 
; 254  : 
; 255  : 		// If DASD is needed but we failed to obtain it, perform open - 'quick format' - close - open 
; 256  : 		// so that the filesystem driver does not prevent us from formatting hidden sectors.
; 257  : 		for (nPass = (bFailedRequiredDASD ? 0 : 1); nPass < 2; nPass++)

  003bb	33 c0		 xor	 eax, eax
  003bd	39 44 24 38	 cmp	 DWORD PTR _bFailedRequiredDASD$[esp+140852], eax
  003c1	0f 94 c0	 sete	 al
  003c4	83 f8 02	 cmp	 eax, 2
  003c7	89 44 24 28	 mov	 DWORD PTR _nPass$81553[esp+140852], eax
  003cb	0f 8d 1e 01 00
	00		 jge	 $LN90@TCFormatVo
  003d1	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateFileA@28
  003d7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL103@TCFormatVo:

; 258  : 		{
; 259  : 			int retryCount;
; 260  : 
; 261  : 			retryCount = 0;

  003e0	33 ed		 xor	 ebp, ebp

; 262  : 
; 263  : 			// Try exclusive access mode first
; 264  : 			// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 265  : 			while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  003e2	83 ff ff	 cmp	 edi, -1
  003e5	0f 85 95 00 00
	00		 jne	 $LN95@TCFormatVo
  003eb	eb 03 8d 49 00	 npad	 5
$LL100@TCFormatVo:
  003f0	8b cd		 mov	 ecx, ebp
  003f2	45		 inc	 ebp
  003f3	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  003f9	7d 2f		 jge	 SHORT $LN99@TCFormatVo

; 266  : 			{
; 267  : 				dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

  003fb	6a 00		 push	 0
  003fd	6a 00		 push	 0
  003ff	6a 03		 push	 3
  00401	6a 00		 push	 0
  00403	6a 00		 push	 0
  00405	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0040a	8d 94 24 30 01
	00 00		 lea	 edx, DWORD PTR _devName$[esp+140876]
  00411	52		 push	 edx
  00412	ff d3		 call	 ebx

; 268  : 
; 269  : 				if (retryCount > 1)

  00414	83 fd 01	 cmp	 ebp, 1
  00417	8b f8		 mov	 edi, eax
  00419	7e 08		 jle	 SHORT $LN98@TCFormatVo

; 270  : 					Sleep (EXCL_ACCESS_AUTO_RETRY_DELAY);

  0041b	6a 0a		 push	 10			; 0000000aH
  0041d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN98@TCFormatVo:

; 262  : 
; 263  : 			// Try exclusive access mode first
; 264  : 			// Note that when exclusive access is denied, it is worth retrying (usually succeeds after a few tries).
; 265  : 			while (dev == INVALID_HANDLE_VALUE && retryCount++ < EXCL_ACCESS_MAX_AUTO_RETRIES)

  00423	83 ff ff	 cmp	 edi, -1
  00426	74 c8		 je	 SHORT $LL100@TCFormatVo

; 271  : 			}
; 272  : 
; 273  : 			if (dev == INVALID_HANDLE_VALUE)

  00428	eb 56		 jmp	 SHORT $LN95@TCFormatVo
$LN99@TCFormatVo:
  0042a	83 ff ff	 cmp	 edi, -1
  0042d	75 51		 jne	 SHORT $LN95@TCFormatVo

; 274  : 			{
; 275  : 				// Exclusive access denied -- retry in shared mode
; 276  : 				dev = CreateFile (devName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  0042f	6a 00		 push	 0
  00431	6a 00		 push	 0
  00433	6a 03		 push	 3
  00435	6a 00		 push	 0
  00437	6a 03		 push	 3
  00439	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0043e	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _devName$[esp+140876]
  00445	50		 push	 eax
  00446	ff d3		 call	 ebx
  00448	8b f8		 mov	 edi, eax

; 277  : 				if (dev != INVALID_HANDLE_VALUE)

  0044a	83 ff ff	 cmp	 edi, -1
  0044d	0f 84 d6 00 00
	00		 je	 $LN96@TCFormatVo

; 278  : 				{
; 279  : 					if (IDNO == MessageBoxW (volParams->hwndDlg, GetString ("DEVICE_IN_USE_FORMAT"), lpszTitle, MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2))

  00453	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00459	68 34 01 00 00	 push	 308			; 00000134H
  0045e	51		 push	 ecx
  0045f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LPDGKFHG@DEVICE_IN_USE_FORMAT?$AA@
  00464	e8 00 00 00 00	 call	 _GetString
  00469	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  0046c	83 c4 04	 add	 esp, 4
  0046f	50		 push	 eax
  00470	52		 push	 edx
  00471	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00477	83 f8 07	 cmp	 eax, 7
  0047a	0f 84 9f 00 00
	00		 je	 $LN156@TCFormatVo
$LN95@TCFormatVo:

; 290  : 					goto error;
; 291  : 				}
; 292  : 			}
; 293  : 
; 294  : 			if (volParams->hiddenVol || bInstantRetryOtherFilesys)

  00480	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00483	85 c0		 test	 eax, eax
  00485	75 68		 jne	 SHORT $LN90@TCFormatVo
  00487	39 44 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], eax
  0048b	75 62		 jne	 SHORT $LN90@TCFormatVo

; 295  : 				break;	// The following "quick format" operation would damage the outer volume
; 296  : 
; 297  : 			if (nPass == 0)

  0048d	39 44 24 28	 cmp	 DWORD PTR _nPass$81553[esp+140852], eax
  00491	75 4a		 jne	 SHORT $LN102@TCFormatVo

; 298  : 			{
; 299  : 				char buf [2 * TC_MAX_VOLUME_SECTOR_SIZE];
; 300  : 				DWORD bw;
; 301  : 
; 302  : 				// Perform pseudo "quick format" so that the filesystem driver does not prevent us from 
; 303  : 				// formatting hidden sectors
; 304  : 				memset (buf, 0, sizeof (buf));

  00493	68 00 20 00 00	 push	 8192			; 00002000H
  00498	50		 push	 eax
  00499	8d 8c 24 38 08
	00 00		 lea	 ecx, DWORD PTR _buf$81600[esp+140860]
  004a0	51		 push	 ecx
  004a1	e8 00 00 00 00	 call	 _memset
  004a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 305  : 
; 306  : 				if (!WriteFile (dev, buf, sizeof (buf), &bw, NULL))

  004a9	6a 00		 push	 0
  004ab	8d 54 24 70	 lea	 edx, DWORD PTR _bw$81601[esp+140856]
  004af	52		 push	 edx
  004b0	68 00 20 00 00	 push	 8192			; 00002000H
  004b5	8d 84 24 3c 08
	00 00		 lea	 eax, DWORD PTR _buf$81600[esp+140864]
  004bc	50		 push	 eax
  004bd	57		 push	 edi
  004be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  004c4	85 c0		 test	 eax, eax
  004c6	0f 84 c4 04 00
	00		 je	 $LN158@TCFormatVo

; 307  : 				{
; 308  : 					nStatus = ERR_OS_ERROR; 
; 309  : 					goto error;
; 310  : 				}
; 311  : 
; 312  : 				FlushFileBuffers (dev);

  004cc	57		 push	 edi
  004cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4

; 313  : 				CloseHandle (dev);

  004d3	57		 push	 edi
  004d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 314  : 				dev = INVALID_HANDLE_VALUE;

  004da	83 cf ff	 or	 edi, -1
$LN102@TCFormatVo:
  004dd	8b 44 24 28	 mov	 eax, DWORD PTR _nPass$81553[esp+140852]
  004e1	40		 inc	 eax
  004e2	83 f8 02	 cmp	 eax, 2
  004e5	89 44 24 28	 mov	 DWORD PTR _nPass$81553[esp+140852], eax
  004e9	0f 8c f1 fe ff
	ff		 jl	 $LL103@TCFormatVo
$LN90@TCFormatVo:

; 315  : 			}
; 316  : 		}
; 317  : 
; 318  : 		if (DeviceIoControl (dev, FSCTL_IS_VOLUME_MOUNTED, NULL, 0, NULL, 0, &dwResult, NULL))

  004ef	6a 00		 push	 0
  004f1	8d 54 24 44	 lea	 edx, DWORD PTR _dwResult$81552[esp+140856]
  004f5	52		 push	 edx
  004f6	6a 00		 push	 0
  004f8	6a 00		 push	 0
  004fa	6a 00		 push	 0
  004fc	6a 00		 push	 0
  004fe	68 28 00 09 00	 push	 589864			; 00090028H
  00503	57		 push	 edi
  00504	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0050a	85 c0		 test	 eax, eax
  0050c	0f 84 13 01 00
	00		 je	 $LN77@TCFormatVo
$LN227@TCFormatVo:

; 319  : 		{
; 320  : 			Error ("FORMAT_CANT_DISMOUNT_FILESYS");

  00512	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NJIOHEOP@FORMAT_CANT_DISMOUNT_FILESYS?$AA@
  00517	e8 00 00 00 00	 call	 _Error
  0051c	83 c4 04	 add	 esp, 4
$LN156@TCFormatVo:

; 321  : 			nStatus = ERR_DONT_REPORT; 

  0051f	bd 1c 00 00 00	 mov	 ebp, 28			; 0000001cH

; 569  : #endif
; 570  : 
; 571  : error:

  00524	e9 ab 04 00 00	 jmp	 $error$81560
$LN96@TCFormatVo:

; 280  : 					{
; 281  : 						nStatus = ERR_DONT_REPORT; 
; 282  : 						goto error;
; 283  : 					}
; 284  : 				}
; 285  : 				else
; 286  : 				{
; 287  : 					handleWin32Error (volParams->hwndDlg);

  00529	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0052c	51		 push	 ecx
  0052d	e8 00 00 00 00	 call	 _handleWin32Error

; 288  : 					Error ("CANT_ACCESS_VOL");

  00532	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GFCNKOPI@CANT_ACCESS_VOL?$AA@
  00537	e8 00 00 00 00	 call	 _Error
  0053c	83 c4 08	 add	 esp, 8

; 289  : 					nStatus = ERR_DONT_REPORT; 

  0053f	bd 1c 00 00 00	 mov	 ebp, 28			; 0000001cH

; 569  : #endif
; 570  : 
; 571  : error:

  00544	e9 8b 04 00 00	 jmp	 $error$81560
$LN114@TCFormatVo:

; 322  : 			goto error;
; 323  : 		}
; 324  : 	}
; 325  : 	else
; 326  : 	{
; 327  : 		/* File-hosted volume */
; 328  : 
; 329  : 		dev = CreateFile (volParams->volumePath, GENERIC_READ | GENERIC_WRITE,
; 330  : 			(volParams->hiddenVol || bInstantRetryOtherFilesys) ? (FILE_SHARE_READ | FILE_SHARE_WRITE) : 0,
; 331  : 			NULL, (volParams->hiddenVol || bInstantRetryOtherFilesys) ? OPEN_EXISTING : CREATE_ALWAYS, 0, NULL);

  00549	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0054c	85 c0		 test	 eax, eax
  0054e	75 09		 jne	 SHORT $LN213@TCFormatVo
  00550	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  00553	39 44 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], eax
  00557	74 05		 je	 SHORT $LN133@TCFormatVo
$LN213@TCFormatVo:
  00559	b9 03 00 00 00	 mov	 ecx, 3
$LN133@TCFormatVo:
  0055e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00561	85 d2		 test	 edx, edx
  00563	75 0a		 jne	 SHORT $LN215@TCFormatVo
  00565	39 54 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], edx
  00569	75 04		 jne	 SHORT $LN215@TCFormatVo
  0056b	33 c0		 xor	 eax, eax
  0056d	eb 05		 jmp	 SHORT $LN135@TCFormatVo
$LN215@TCFormatVo:
  0056f	b8 03 00 00 00	 mov	 eax, 3
$LN135@TCFormatVo:
  00574	6a 00		 push	 0
  00576	6a 00		 push	 0
  00578	51		 push	 ecx
  00579	6a 00		 push	 0
  0057b	50		 push	 eax
  0057c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0057f	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00584	50		 push	 eax
  00585	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0058b	8b f8		 mov	 edi, eax

; 332  : 
; 333  : 		if (dev == INVALID_HANDLE_VALUE)

  0058d	83 ff ff	 cmp	 edi, -1

; 569  : #endif
; 570  : 
; 571  : error:

  00590	0f 84 2f 01 00
	00		 je	 $LN195@TCFormatVo
  00596	57		 push	 edi
  00597	e8 00 00 00 00	 call	 _DisableFileCompression
  0059c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0059f	83 c4 04	 add	 esp, 4
  005a2	85 c9		 test	 ecx, ecx
  005a4	75 7f		 jne	 SHORT $LN77@TCFormatVo

; 334  : 		{
; 335  : 			nStatus = ERR_OS_ERROR; 
; 336  : 			goto error;
; 337  : 		}
; 338  : 
; 339  : 		DisableFileCompression (dev);
; 340  : 
; 341  : 		if (!volParams->hiddenVol && !bInstantRetryOtherFilesys)

  005a6	39 4c 24 1c	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], ecx
  005aa	75 79		 jne	 SHORT $LN77@TCFormatVo

; 342  : 		{
; 343  : 			LARGE_INTEGER volumeSize;
; 344  : 			volumeSize.QuadPart = dataAreaSize + TC_VOLUME_HEADER_GROUP_SIZE;

  005ac	8b 6c 24 20	 mov	 ebp, DWORD PTR _dataAreaSize$[esp+140852]
  005b0	8b 5c 24 24	 mov	 ebx, DWORD PTR _dataAreaSize$[esp+140856]

; 345  : 
; 346  : 			if (volParams->sparseFileSwitch && volParams->quickFormat)

  005b4	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  005b7	81 c5 00 00 02
	00		 add	 ebp, 131072		; 00020000H
  005bd	13 d9		 adc	 ebx, ecx
  005bf	85 d2		 test	 edx, edx
  005c1	74 29		 je	 SHORT $LN79@TCFormatVo
  005c3	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  005c6	85 c0		 test	 eax, eax
  005c8	74 22		 je	 SHORT $LN79@TCFormatVo

; 347  : 			{
; 348  : 				// Create as sparse file container
; 349  : 				DWORD tmp;
; 350  : 				if (!DeviceIoControl (dev, FSCTL_SET_SPARSE, NULL, 0, NULL, 0, &tmp, NULL))

  005ca	51		 push	 ecx
  005cb	8d 4c 24 6c	 lea	 ecx, DWORD PTR _tmp$81616[esp+140856]
  005cf	51		 push	 ecx
  005d0	6a 00		 push	 0
  005d2	6a 00		 push	 0
  005d4	6a 00		 push	 0
  005d6	6a 00		 push	 0
  005d8	68 c4 00 09 00	 push	 590020			; 000900c4H
  005dd	57		 push	 edi
  005de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  005e4	85 c0		 test	 eax, eax

; 569  : #endif
; 570  : 
; 571  : error:

  005e6	0f 84 d9 00 00
	00		 je	 $LN195@TCFormatVo
$LN79@TCFormatVo:

; 351  : 				{
; 352  : 					nStatus = ERR_OS_ERROR; 
; 353  : 					goto error;
; 354  : 				}
; 355  : 			}
; 356  : 
; 357  : 			// Preallocate the file
; 358  : 			if (!SetFilePointerEx (dev, volumeSize, NULL, FILE_BEGIN)
; 359  : 				|| !SetEndOfFile (dev)
; 360  : 				|| SetFilePointer (dev, 0, NULL, FILE_BEGIN) != 0)

  005ec	6a 00		 push	 0
  005ee	6a 00		 push	 0
  005f0	53		 push	 ebx
  005f1	55		 push	 ebp
  005f2	57		 push	 edi
  005f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  005f9	85 c0		 test	 eax, eax
  005fb	0f 84 c4 00 00
	00		 je	 $LN195@TCFormatVo
  00601	57		 push	 edi
  00602	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4
  00608	85 c0		 test	 eax, eax
  0060a	0f 84 b5 00 00
	00		 je	 $LN195@TCFormatVo
  00610	6a 00		 push	 0
  00612	6a 00		 push	 0
  00614	6a 00		 push	 0
  00616	57		 push	 edi
  00617	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  0061d	85 c0		 test	 eax, eax

; 569  : #endif
; 570  : 
; 571  : error:

  0061f	0f 85 a0 00 00
	00		 jne	 $LN195@TCFormatVo
$LN77@TCFormatVo:

; 361  : 			{
; 362  : 				nStatus = ERR_OS_ERROR;
; 363  : 				goto error;
; 364  : 			}
; 365  : 		}
; 366  : 	}
; 367  : 
; 368  : 	if (volParams->hiddenVol && !volParams->bDevice && bPreserveTimestamp)

  00625	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00628	85 d2		 test	 edx, edx
  0062a	74 2e		 je	 SHORT $LN197@TCFormatVo
  0062c	8b 06		 mov	 eax, DWORD PTR [esi]
  0062e	85 c0		 test	 eax, eax
  00630	75 28		 jne	 SHORT $LN197@TCFormatVo
  00632	39 05 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, eax
  00638	74 20		 je	 SHORT $LN197@TCFormatVo

; 369  : 	{
; 370  : 		if (GetFileTime ((HANDLE) dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) == 0)

  0063a	8d 4c 24 50	 lea	 ecx, DWORD PTR _ftLastWriteTime$[esp+140852]
  0063e	51		 push	 ecx
  0063f	8d 54 24 5c	 lea	 edx, DWORD PTR _ftLastAccessTime$[esp+140856]
  00643	52		 push	 edx
  00644	8d 44 24 68	 lea	 eax, DWORD PTR _ftCreationTime$[esp+140860]
  00648	50		 push	 eax
  00649	57		 push	 edi
  0064a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  00650	f7 d8		 neg	 eax
  00652	1b c0		 sbb	 eax, eax
  00654	f7 d8		 neg	 eax
  00656	89 44 24 34	 mov	 DWORD PTR _bTimeStampValid$[esp+140852], eax
$LN197@TCFormatVo:

; 371  : 			bTimeStampValid = FALSE;
; 372  : 		else
; 373  : 			bTimeStampValid = TRUE;
; 374  : 	}
; 375  : 
; 376  : 	KillTimer (volParams->hwndDlg, TIMER_ID_RANDVIEW);

  0065a	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0065d	68 ff 00 00 00	 push	 255			; 000000ffH
  00662	51		 push	 ecx
  00663	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 377  : 
; 378  : 	/* Volume header */
; 379  : 
; 380  : 	// Hidden volume setup
; 381  : 	if (volParams->hiddenVol)

  00669	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0066c	85 d2		 test	 edx, edx
  0066e	74 38		 je	 SHORT $LN71@TCFormatVo

; 382  : 	{
; 383  : 		LARGE_INTEGER headerOffset;
; 384  : 
; 385  : 		// Check hidden volume size
; 386  : 		if (volParams->hiddenVolHostSize < TC_MIN_HIDDEN_VOLUME_HOST_SIZE || volParams->hiddenVolHostSize > TC_MAX_HIDDEN_VOLUME_HOST_SIZE)

  00670	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00673	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00677	77 0b		 ja	 SHORT $LN185@TCFormatVo
  00679	3d 00 50 05 00	 cmp	 eax, 348160		; 00055000H
  0067e	0f 82 60 01 00
	00		 jb	 $LN203@TCFormatVo
$LN185@TCFormatVo:
  00684	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00687	81 7e 1c ff 7f
	00 00		 cmp	 DWORD PTR [esi+28], 32767 ; 00007fffH
  0068e	0f 87 50 01 00
	00		 ja	 $LN203@TCFormatVo
  00694	72 0b		 jb	 SHORT $LN186@TCFormatVo
  00696	3d 00 00 fc ff	 cmp	 eax, -262144		; fffc0000H
  0069b	0f 87 43 01 00
	00		 ja	 $LN203@TCFormatVo
$LN186@TCFormatVo:

; 387  : 		{		
; 388  : 			nStatus = ERR_VOL_SIZE_WRONG;
; 389  : 			goto error;
; 390  : 		}
; 391  : 
; 392  : 		// Seek to hidden volume header location
; 393  : 		
; 394  : 		headerOffset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;

  006a1	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H

; 569  : #endif
; 570  : 
; 571  : error:

  006a6	eb 0c		 jmp	 SHORT $LN226@TCFormatVo
$LN71@TCFormatVo:

; 395  : 
; 396  : 		if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))
; 397  : 		{
; 398  : 			nStatus = ERR_OS_ERROR;
; 399  : 			goto error;
; 400  : 		}
; 401  : 	}
; 402  : 	else if (bInstantRetryOtherFilesys)

  006a8	83 7c 24 1c 00	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], 0
  006ad	74 27		 je	 SHORT $LN201@TCFormatVo

; 403  : 	{
; 404  : 		// The previous file system format failed and the user wants to try again with a different file system.
; 405  : 		// The volume header had been written successfully so we need to seek to the byte after the header.
; 406  : 
; 407  : 		LARGE_INTEGER offset;
; 408  : 		offset.QuadPart = TC_VOLUME_DATA_OFFSET;

  006af	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
$LN226@TCFormatVo:
  006b4	33 c9		 xor	 ecx, ecx

; 409  : 		if (!SetFilePointerEx ((HANDLE) dev, offset, NULL, FILE_BEGIN))

  006b6	51		 push	 ecx
  006b7	51		 push	 ecx
  006b8	51		 push	 ecx
  006b9	50		 push	 eax
  006ba	57		 push	 edi
  006bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  006c1	85 c0		 test	 eax, eax
  006c3	75 0a		 jne	 SHORT $LN199@TCFormatVo
$LN195@TCFormatVo:

; 410  : 		{
; 411  : 			nStatus = ERR_OS_ERROR;

  006c5	bd 01 00 00 00	 mov	 ebp, 1

; 569  : #endif
; 570  : 
; 571  : error:

  006ca	e9 05 03 00 00	 jmp	 $error$81560
$LN199@TCFormatVo:

; 412  : 			goto error;
; 413  : 		}
; 414  : 	}
; 415  : 
; 416  : 	if (!bInstantRetryOtherFilesys)

  006cf	83 7c 24 1c 00	 cmp	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], 0
  006d4	75 7e		 jne	 SHORT $LN55@TCFormatVo
$LN201@TCFormatVo:

; 417  : 	{
; 418  : 		// Write the volume header
; 419  : 		if (!WriteEffectiveVolumeHeader (volParams->bDevice, dev, (byte*)header))

  006d6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006d8	8d 84 24 1c 02
	00 00		 lea	 eax, DWORD PTR _header$[esp+140852]
  006df	50		 push	 eax
  006e0	57		 push	 edi
  006e1	51		 push	 ecx
  006e2	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  006e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  006ea	85 c0		 test	 eax, eax
  006ec	75 08		 jne	 SHORT $LN60@TCFormatVo

; 420  : 		{
; 421  : 			nStatus = ERR_OS_ERROR;

  006ee	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]

; 569  : #endif
; 570  : 
; 571  : error:

  006f1	e9 de 02 00 00	 jmp	 $error$81560
$LN60@TCFormatVo:

; 422  : 			goto error;
; 423  : 		}
; 424  : 
; 425  : 		// To prevent fragmentation, write zeroes to reserved header sectors which are going to be filled with random data
; 426  : 		if (!volParams->bDevice && !volParams->hiddenVol)

  006f6	8b 16		 mov	 edx, DWORD PTR [esi]
  006f8	85 d2		 test	 edx, edx
  006fa	75 58		 jne	 SHORT $LN55@TCFormatVo
  006fc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  006ff	85 c0		 test	 eax, eax
  00701	75 51		 jne	 SHORT $LN55@TCFormatVo

; 427  : 		{
; 428  : 			byte buf[TC_VOLUME_HEADER_GROUP_SIZE - TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 429  : 			DWORD bytesWritten;
; 430  : 			ZeroMemory (buf, sizeof (buf));

  00703	68 00 fe 01 00	 push	 130560			; 0001fe00H
  00708	50		 push	 eax
  00709	8d 8c 24 38 28
	00 00		 lea	 ecx, DWORD PTR _buf$81645[esp+140860]
  00710	51		 push	 ecx
  00711	e8 00 00 00 00	 call	 _memset
  00716	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 
; 432  : 			if (!WriteFile (dev, buf, sizeof (buf), &bytesWritten, NULL))

  00719	6a 00		 push	 0
  0071b	8d 54 24 50	 lea	 edx, DWORD PTR _bytesWritten$81646[esp+140856]
  0071f	52		 push	 edx
  00720	68 00 fe 01 00	 push	 130560			; 0001fe00H
  00725	8d 84 24 3c 28
	00 00		 lea	 eax, DWORD PTR _buf$81645[esp+140864]
  0072c	50		 push	 eax
  0072d	57		 push	 edi
  0072e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00734	85 c0		 test	 eax, eax
  00736	75 08		 jne	 SHORT $LN57@TCFormatVo

; 433  : 			{
; 434  : 				nStatus = ERR_OS_ERROR;

  00738	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]

; 569  : #endif
; 570  : 
; 571  : error:

  0073b	e9 94 02 00 00	 jmp	 $error$81560
$LN57@TCFormatVo:

; 435  : 				goto error;
; 436  : 			}
; 437  : 
; 438  : 			if (bytesWritten != sizeof (buf))

  00740	81 7c 24 4c 00
	fe 01 00	 cmp	 DWORD PTR _bytesWritten$81646[esp+140852], 130560 ; 0001fe00H
  00748	74 0a		 je	 SHORT $LN55@TCFormatVo

; 439  : 			{
; 440  : 				nStatus = ERR_PARAMETER_INCORRECT;

  0074a	bd 1e 00 00 00	 mov	 ebp, 30			; 0000001eH

; 569  : #endif
; 570  : 
; 571  : error:

  0074f	e9 80 02 00 00	 jmp	 $error$81560
$LN55@TCFormatVo:

; 441  : 				goto error;
; 442  : 			}
; 443  : 		}
; 444  : 	}
; 445  : 
; 446  : 	if (volParams->hiddenVol)

  00754	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 447  : 	{
; 448  : 		// Calculate data area position of hidden volume
; 449  : 		cryptoInfo->hiddenVolumeOffset = dataOffset;

  00757	8b 5c 24 2c	 mov	 ebx, DWORD PTR _dataOffset$[esp+140852]
  0075b	8b 6c 24 30	 mov	 ebp, DWORD PTR _dataOffset$[esp+140856]
  0075f	85 c9		 test	 ecx, ecx
  00761	74 39		 je	 SHORT $LN53@TCFormatVo

; 450  : 
; 451  : 		// Validate the offset
; 452  : 		if (dataOffset % FormatSectorSize != 0)

  00763	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _FormatSectorSize
  00769	8b 54 24 10	 mov	 edx, DWORD PTR _cryptoInfo$[esp+140852]
  0076d	6a 00		 push	 0
  0076f	51		 push	 ecx
  00770	89 9a 18 44 00
	00		 mov	 DWORD PTR [edx+17432], ebx
  00776	8b 44 24 18	 mov	 eax, DWORD PTR _cryptoInfo$[esp+140860]
  0077a	55		 push	 ebp
  0077b	53		 push	 ebx
  0077c	89 a8 1c 44 00
	00		 mov	 DWORD PTR [eax+17436], ebp
  00782	e8 00 00 00 00	 call	 __aullrem
  00787	0b c2		 or	 eax, edx
  00789	74 0a		 je	 SHORT $LN52@TCFormatVo

; 453  : 		{
; 454  : 			nStatus = ERR_VOL_SIZE_WRONG; 

  0078b	bd 07 00 00 00	 mov	 ebp, 7

; 569  : #endif
; 570  : 
; 571  : error:

  00790	e9 3f 02 00 00	 jmp	 $error$81560
$LN52@TCFormatVo:

; 455  : 			goto error;
; 456  : 		}
; 457  : 
; 458  : 		volParams->quickFormat = TRUE;		// To entirely format a hidden volume would be redundant

  00795	c7 46 38 01 00
	00 00		 mov	 DWORD PTR [esi+56], 1
$LN53@TCFormatVo:

; 459  : 	}
; 460  : 
; 461  : 	/* Data area */
; 462  : 	startSector = dataOffset / FormatSectorSize;

  0079c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  007a2	6a 00		 push	 0
  007a4	52		 push	 edx
  007a5	55		 push	 ebp
  007a6	53		 push	 ebx
  007a7	e8 00 00 00 00	 call	 __aulldiv
  007ac	8b d8		 mov	 ebx, eax

; 463  : 
; 464  : 	// Format filesystem
; 465  : 
; 466  : 	switch (volParams->fileSystem)

  007ae	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  007b1	83 e8 00	 sub	 eax, 0
  007b4	8b ea		 mov	 ebp, edx
  007b6	0f 84 cc 00 00
	00		 je	 $LN48@TCFormatVo
  007bc	83 e8 01	 sub	 eax, 1
  007bf	74 13		 je	 SHORT $LN44@TCFormatVo
  007c1	83 e8 01	 sub	 eax, 1
  007c4	0f 84 be 00 00
	00		 je	 $LN48@TCFormatVo

; 516  : 
; 517  : 	default:
; 518  : 		nStatus = ERR_PARAMETER_INCORRECT; 

  007ca	bd 1e 00 00 00	 mov	 ebp, 30			; 0000001eH

; 569  : #endif
; 570  : 
; 571  : error:

  007cf	e9 00 02 00 00	 jmp	 $error$81560
$LN44@TCFormatVo:

; 481  : 
; 482  : 		break;
; 483  : 		
; 484  : 	case FILESYS_FAT:
; 485  : 		if (num_sectors > 0xFFFFffff)

  007d4	83 7c 24 48 00	 cmp	 DWORD PTR _num_sectors$[esp+140856], 0
  007d9	77 09		 ja	 SHORT $LN203@TCFormatVo
  007db	8b 44 24 44	 mov	 eax, DWORD PTR _num_sectors$[esp+140852]
  007df	83 f8 ff	 cmp	 eax, -1
  007e2	76 0a		 jbe	 SHORT $LN43@TCFormatVo
$LN203@TCFormatVo:

; 486  : 		{
; 487  : 			nStatus = ERR_VOL_SIZE_WRONG; 

  007e4	bd 07 00 00 00	 mov	 ebp, 7

; 569  : #endif
; 570  : 
; 571  : error:

  007e9	e9 e6 01 00 00	 jmp	 $error$81560
$LN43@TCFormatVo:

; 488  : 			goto error;
; 489  : 		}
; 490  : 
; 491  : 		// Calculate the fats, root dir etc
; 492  : 		ft.num_sectors = (unsigned int) (num_sectors);
; 493  : 
; 494  : #if TC_MAX_VOLUME_SECTOR_SIZE > 0xFFFF
; 495  : #error TC_MAX_VOLUME_SECTOR_SIZE > 0xFFFF
; 496  : #endif
; 497  : 
; 498  : 		ft.sector_size = (uint16) FormatSectorSize;
; 499  : 		ft.cluster_size = volParams->clusterSize;

  007ee	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 500  : 		memcpy (ft.volume_name, "NO NAME    ", 11);

  007f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@
  007f7	89 84 24 80 00
	00 00		 mov	 DWORD PTR _ft$[esp+140868], eax
  007fe	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _FormatSectorSize
  00804	66 89 84 24 a2
	00 00 00	 mov	 WORD PTR _ft$[esp+140902], ax
  0080c	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+4
  00811	89 44 24 74	 mov	 DWORD PTR _ft$[esp+140856], eax
  00815	89 8c 24 98 00
	00 00		 mov	 DWORD PTR _ft$[esp+140892], ecx
  0081c	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+8
  00823	89 54 24 70	 mov	 DWORD PTR _ft$[esp+140852], edx
  00827	8a 15 0a 00 00
	00		 mov	 dl, BYTE PTR ??_C@_0M@BCIBMEHP@NO?5NAME?5?5?5?5?$AA@+10

; 501  : 		GetFatParams (&ft); 

  0082d	8d 44 24 70	 lea	 eax, DWORD PTR _ft$[esp+140852]
  00831	50		 push	 eax
  00832	66 89 4c 24 7c	 mov	 WORD PTR _ft$[esp+140864], cx
  00837	88 54 24 7e	 mov	 BYTE PTR _ft$[esp+140866], dl
  0083b	e8 00 00 00 00	 call	 _GetFatParams

; 502  : 		*(volParams->realClusterSize) = ft.cluster_size * FormatSectorSize;

  00840	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _ft$[esp+140896]
  00847	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _FormatSectorSize
  0084e	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00851	89 01		 mov	 DWORD PTR [ecx], eax

; 503  : 
; 504  : 		if (volParams->bDevice && !StartFormatWriteThread())

  00853	8b 16		 mov	 edx, DWORD PTR [esi]
  00855	83 c4 04	 add	 esp, 4
  00858	85 d2		 test	 edx, edx
  0085a	74 11		 je	 SHORT $LN41@TCFormatVo
  0085c	e8 00 00 00 00	 call	 _StartFormatWriteThread
  00861	85 c0		 test	 eax, eax
  00863	75 08		 jne	 SHORT $LN41@TCFormatVo

; 505  : 		{
; 506  : 			nStatus = ERR_OS_ERROR; 

  00865	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]

; 569  : #endif
; 570  : 
; 571  : error:

  00868	e9 67 01 00 00	 jmp	 $error$81560
$LN41@TCFormatVo:

; 507  : 			goto error;
; 508  : 		}
; 509  : 
; 510  : 		nStatus = FormatFat (startSector, &ft, (void *) dev, cryptoInfo, volParams->quickFormat);

  0086d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00870	8b 4c 24 10	 mov	 ecx, DWORD PTR _cryptoInfo$[esp+140852]
  00874	50		 push	 eax
  00875	51		 push	 ecx
  00876	57		 push	 edi
  00877	8d 54 24 7c	 lea	 edx, DWORD PTR _ft$[esp+140864]
  0087b	52		 push	 edx
  0087c	55		 push	 ebp
  0087d	53		 push	 ebx
  0087e	e8 00 00 00 00	 call	 _FormatFat
  00883	83 c4 18	 add	 esp, 24			; 00000018H

; 511  : 
; 512  : 		if (volParams->bDevice)
; 513  : 			StopFormatWriteThread();
; 514  : 
; 515  : 		break;

  00886	eb 35		 jmp	 SHORT $LN225@TCFormatVo
$LN48@TCFormatVo:

; 467  : 	{
; 468  : 	case FILESYS_NONE:
; 469  : 	case FILESYS_NTFS:
; 470  : 
; 471  : 		if (volParams->bDevice && !StartFormatWriteThread())

  00888	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0088a	85 c9		 test	 ecx, ecx
  0088c	74 11		 je	 SHORT $LN47@TCFormatVo
  0088e	e8 00 00 00 00	 call	 _StartFormatWriteThread
  00893	85 c0		 test	 eax, eax
  00895	75 08		 jne	 SHORT $LN47@TCFormatVo

; 472  : 		{
; 473  : 			nStatus = ERR_OS_ERROR; 

  00897	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]

; 569  : #endif
; 570  : 
; 571  : error:

  0089a	e9 35 01 00 00	 jmp	 $error$81560
$LN47@TCFormatVo:

; 474  : 			goto error;
; 475  : 		}
; 476  : 
; 477  : 		nStatus = FormatNoFs (startSector, num_sectors, dev, cryptoInfo, volParams->quickFormat);

  0089f	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  008a2	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+140852]
  008a6	8b 4c 24 48	 mov	 ecx, DWORD PTR _num_sectors$[esp+140856]
  008aa	52		 push	 edx
  008ab	8b 54 24 48	 mov	 edx, DWORD PTR _num_sectors$[esp+140856]
  008af	50		 push	 eax
  008b0	57		 push	 edi
  008b1	51		 push	 ecx
  008b2	52		 push	 edx
  008b3	55		 push	 ebp
  008b4	53		 push	 ebx
  008b5	e8 00 00 00 00	 call	 _FormatNoFs
  008ba	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN225@TCFormatVo:
  008bd	8b e8		 mov	 ebp, eax

; 478  : 
; 479  : 		if (volParams->bDevice)

  008bf	8b 06		 mov	 eax, DWORD PTR [esi]
  008c1	85 c0		 test	 eax, eax
  008c3	74 05		 je	 SHORT $LN204@TCFormatVo

; 480  : 			StopFormatWriteThread();

  008c5	e8 00 00 00 00	 call	 _StopFormatWriteThread
$LN204@TCFormatVo:

; 519  : 		goto error;
; 520  : 	}
; 521  : 
; 522  : 	if (nStatus != ERR_SUCCESS)

  008ca	85 ed		 test	 ebp, ebp
  008cc	0f 85 02 01 00
	00		 jne	 $error$81560

; 523  : 		goto error;
; 524  : 
; 525  : 	// Write header backup
; 526  : 	offset.QuadPart = volParams->hiddenVol ? volParams->hiddenVolHostSize - TC_HIDDEN_VOLUME_HEADER_OFFSET : dataAreaSize + TC_VOLUME_HEADER_GROUP_SIZE;

  008d2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  008d5	8b 5c 24 20	 mov	 ebx, DWORD PTR _dataAreaSize$[esp+140852]
  008d9	85 c9		 test	 ecx, ecx
  008db	74 0f		 je	 SHORT $LN136@TCFormatVo
  008dd	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  008e0	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  008e3	2d 00 00 01 00	 sub	 eax, 65536		; 00010000H
  008e8	1b cd		 sbb	 ecx, ebp
  008ea	eb 0e		 jmp	 SHORT $LN137@TCFormatVo
$LN136@TCFormatVo:
  008ec	8b 4c 24 24	 mov	 ecx, DWORD PTR _dataAreaSize$[esp+140856]
  008f0	8b c3		 mov	 eax, ebx
  008f2	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  008f7	83 d1 00	 adc	 ecx, 0
$LN137@TCFormatVo:

; 527  : 
; 528  : 	if (!SetFilePointerEx ((HANDLE) dev, offset, NULL, FILE_BEGIN))

  008fa	6a 00		 push	 0
  008fc	6a 00		 push	 0
  008fe	51		 push	 ecx
  008ff	50		 push	 eax
  00900	57		 push	 edi
  00901	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00907	85 c0		 test	 eax, eax
  00909	75 08		 jne	 SHORT $LN34@TCFormatVo

; 529  : 	{
; 530  : 		nStatus = ERR_OS_ERROR;

  0090b	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]

; 569  : #endif
; 570  : 
; 571  : error:

  0090e	e9 c1 00 00 00	 jmp	 $error$81560
$LN34@TCFormatVo:

; 531  : 		goto error;
; 532  : 	}
; 533  : 
; 534  : 	nStatus = CreateVolumeHeaderInMemory (FALSE,
; 535  : 		header,
; 536  : 		volParams->ea,
; 537  : 		FIRST_MODE_OF_OPERATION_ID,
; 538  : 		volParams->password,
; 539  : 		volParams->pkcs5,
; 540  : 		(char*)cryptoInfo->master_keydata,
; 541  : 		&cryptoInfo,
; 542  : 		dataAreaSize,
; 543  : 		volParams->hiddenVol ? dataAreaSize : 0,
; 544  : 		dataOffset,
; 545  : 		dataAreaSize,
; 546  : 		0,
; 547  : 		volParams->headerFlags,
; 548  : 		FormatSectorSize,
; 549  : 		FALSE);

  00913	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00916	85 d2		 test	 edx, edx
  00918	74 08		 je	 SHORT $LN138@TCFormatVo
  0091a	8b 4c 24 24	 mov	 ecx, DWORD PTR _dataAreaSize$[esp+140856]
  0091e	8b c3		 mov	 eax, ebx
  00920	eb 04		 jmp	 SHORT $LN139@TCFormatVo
$LN138@TCFormatVo:
  00922	33 c0		 xor	 eax, eax
  00924	33 c9		 xor	 ecx, ecx
$LN139@TCFormatVo:
  00926	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _FormatSectorSize
  0092c	8b 6c 24 30	 mov	 ebp, DWORD PTR _dataOffset$[esp+140856]
  00930	6a 00		 push	 0
  00932	52		 push	 edx
  00933	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00936	52		 push	 edx
  00937	8b 54 24 30	 mov	 edx, DWORD PTR _dataAreaSize$[esp+140868]
  0093b	6a 00		 push	 0
  0093d	52		 push	 edx
  0093e	53		 push	 ebx
  0093f	55		 push	 ebp
  00940	8b 6c 24 48	 mov	 ebp, DWORD PTR _dataOffset$[esp+140880]
  00944	55		 push	 ebp
  00945	51		 push	 ecx
  00946	8b 4c 24 34	 mov	 ecx, DWORD PTR _cryptoInfo$[esp+140888]
  0094a	50		 push	 eax
  0094b	52		 push	 edx
  0094c	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0094f	53		 push	 ebx
  00950	8d 44 24 40	 lea	 eax, DWORD PTR _cryptoInfo$[esp+140900]
  00954	50		 push	 eax
  00955	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00958	81 c1 a8 41 00
	00		 add	 ecx, 16808		; 000041a8H
  0095e	51		 push	 ecx
  0095f	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00962	52		 push	 edx
  00963	50		 push	 eax
  00964	6a 01		 push	 1
  00966	51		 push	 ecx
  00967	8d 94 24 64 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140924]
  0096e	52		 push	 edx
  0096f	6a 00		 push	 0
  00971	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory

; 550  : 
; 551  : 	if (!WriteEffectiveVolumeHeader (volParams->bDevice, dev, (byte*)header))

  00976	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00978	8b e8		 mov	 ebp, eax
  0097a	8d 84 24 6c 02
	00 00		 lea	 eax, DWORD PTR _header$[esp+140932]
  00981	50		 push	 eax
  00982	57		 push	 edi
  00983	51		 push	 ecx
  00984	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  00989	83 c4 5c	 add	 esp, 92			; 0000005cH
  0098c	85 c0		 test	 eax, eax
  0098e	75 07		 jne	 SHORT $LN32@TCFormatVo
$LN158@TCFormatVo:

; 552  : 	{
; 553  : 		nStatus = ERR_OS_ERROR;

  00990	bd 01 00 00 00	 mov	 ebp, 1

; 569  : #endif
; 570  : 
; 571  : error:

  00995	eb 3d		 jmp	 SHORT $error$81560
$LN32@TCFormatVo:

; 554  : 		goto error;
; 555  : 	}
; 556  : 
; 557  : 	// Fill reserved header sectors (including the backup header area) with random data
; 558  : 	if (!volParams->hiddenVol)

  00997	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0099a	85 d2		 test	 edx, edx
  0099c	75 1c		 jne	 SHORT $LN29@TCFormatVo

; 559  : 	{
; 560  : 		nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, dataAreaSize, FALSE, FALSE);

  0099e	8b 44 24 24	 mov	 eax, DWORD PTR _dataAreaSize$[esp+140856]
  009a2	8b 4c 24 10	 mov	 ecx, DWORD PTR _cryptoInfo$[esp+140852]
  009a6	52		 push	 edx
  009a7	52		 push	 edx
  009a8	50		 push	 eax
  009a9	53		 push	 ebx
  009aa	51		 push	 ecx
  009ab	57		 push	 edi
  009ac	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  009b1	8b e8		 mov	 ebp, eax
  009b3	83 c4 18	 add	 esp, 24			; 00000018H

; 561  : 
; 562  : 		if (nStatus != ERR_SUCCESS)

  009b6	85 ed		 test	 ebp, ebp
  009b8	75 1a		 jne	 SHORT $error$81560
$LN29@TCFormatVo:

; 563  : 			goto error;
; 564  : 	}
; 565  : 
; 566  : #ifndef DEBUG
; 567  : 	if (volParams->quickFormat && volParams->fileSystem != FILESYS_NTFS)

  009ba	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  009bd	85 d2		 test	 edx, edx
  009bf	74 13		 je	 SHORT $error$81560
  009c1	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  009c4	83 f8 02	 cmp	 eax, 2
  009c7	74 0b		 je	 SHORT $error$81560

; 568  : 		Sleep (500);	// User-friendly GUI

  009c9	68 f4 01 00 00	 push	 500			; 000001f4H
  009ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$error$81560:

; 572  : 	dwError = GetLastError();

  009d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 573  : 
; 574  : 	burn (header, sizeof (header));

  009da	8d 94 24 1c 02
	00 00		 lea	 edx, DWORD PTR _header$[esp+140852]
  009e1	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  009e6	89 44 24 28	 mov	 DWORD PTR _dwError$[esp+140852], eax
  009ea	8b d9		 mov	 ebx, ecx
  009ec	8b c2		 mov	 eax, edx
  009ee	8b ff		 npad	 2
$LL145@TCFormatVo:
  009f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  009f3	40		 inc	 eax
  009f4	83 eb 01	 sub	 ebx, 1
  009f7	75 f7		 jne	 SHORT $LL145@TCFormatVo
  009f9	8d a4 24 00 00
	00 00		 npad	 7
$LL23@TCFormatVo:
  00a00	49		 dec	 ecx
  00a01	c6 02 00	 mov	 BYTE PTR [edx], 0
  00a04	42		 inc	 edx
  00a05	85 c9		 test	 ecx, ecx
  00a07	75 f7		 jne	 SHORT $LL23@TCFormatVo

; 575  : 	VirtualUnlock (header, sizeof (header));

  00a09	68 00 02 00 00	 push	 512			; 00000200H
  00a0e	8d 8c 24 20 02
	00 00		 lea	 ecx, DWORD PTR _header$[esp+140856]
  00a15	51		 push	 ecx
  00a16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 576  : 
; 577  : 	if (dev != INVALID_HANDLE_VALUE)

  00a1c	83 ff ff	 cmp	 edi, -1
  00a1f	74 54		 je	 SHORT $LN21@TCFormatVo

; 578  : 	{
; 579  : 		if (!volParams->bDevice && !volParams->hiddenVol && nStatus != 0)

  00a21	8b 16		 mov	 edx, DWORD PTR [esi]
  00a23	85 d2		 test	 edx, edx
  00a25	75 20		 jne	 SHORT $LN19@TCFormatVo
  00a27	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00a2a	85 c0		 test	 eax, eax
  00a2c	75 19		 jne	 SHORT $LN19@TCFormatVo
  00a2e	85 ed		 test	 ebp, ebp
  00a30	74 15		 je	 SHORT $LN19@TCFormatVo

; 580  : 		{
; 581  : 			// Remove preallocated part before closing file handle if format failed
; 582  : 			if (SetFilePointer (dev, 0, NULL, FILE_BEGIN) == 0)

  00a32	50		 push	 eax
  00a33	50		 push	 eax
  00a34	50		 push	 eax
  00a35	57		 push	 edi
  00a36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00a3c	85 c0		 test	 eax, eax
  00a3e	75 07		 jne	 SHORT $LN19@TCFormatVo

; 583  : 				SetEndOfFile (dev);

  00a40	57		 push	 edi
  00a41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4
$LN19@TCFormatVo:

; 584  : 		}
; 585  : 
; 586  : 		FlushFileBuffers (dev);

  00a47	57		 push	 edi
  00a48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4

; 587  : 
; 588  : 		if (bTimeStampValid)

  00a4e	83 7c 24 34 00	 cmp	 DWORD PTR _bTimeStampValid$[esp+140852], 0
  00a53	74 16		 je	 SHORT $LN18@TCFormatVo

; 589  : 			SetFileTime (dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime);

  00a55	8d 4c 24 50	 lea	 ecx, DWORD PTR _ftLastWriteTime$[esp+140852]
  00a59	51		 push	 ecx
  00a5a	8d 54 24 5c	 lea	 edx, DWORD PTR _ftLastAccessTime$[esp+140856]
  00a5e	52		 push	 edx
  00a5f	8d 44 24 68	 lea	 eax, DWORD PTR _ftCreationTime$[esp+140860]
  00a63	50		 push	 eax
  00a64	57		 push	 edi
  00a65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN18@TCFormatVo:

; 590  : 
; 591  : 		CloseHandle (dev);

  00a6b	57		 push	 edi
  00a6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 592  : 		dev = INVALID_HANDLE_VALUE;

  00a72	83 cf ff	 or	 edi, -1
$LN21@TCFormatVo:

; 593  : 	}
; 594  : 
; 595  : 	if (nStatus != 0)

  00a75	85 ed		 test	 ebp, ebp
  00a77	0f 85 5d 01 00
	00		 jne	 $LN160@TCFormatVo

; 598  : 		goto fv_end;
; 599  : 	}
; 600  : 
; 601  : 	if (volParams->fileSystem == FILESYS_NTFS)

  00a7d	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00a80	83 f9 02	 cmp	 ecx, 2
  00a83	0f 85 36 02 00
	00		 jne	 $fv_end$81705

; 602  : 	{
; 603  : 		// Quick-format volume as NTFS
; 604  : 		int driveNo = GetLastAvailableDrive ();

  00a89	e8 00 00 00 00	 call	 _GetLastAvailableDrive

; 605  : 		MountOptions mountOptions;
; 606  : 		int retCode;
; 607  : 
; 608  : 		ZeroMemory (&mountOptions, sizeof (mountOptions));

  00a8e	6a 64		 push	 100			; 00000064H
  00a90	8d 94 24 b8 00
	00 00		 lea	 edx, DWORD PTR _mountOptions$81709[esp+140856]
  00a97	55		 push	 ebp
  00a98	52		 push	 edx
  00a99	8b d8		 mov	 ebx, eax
  00a9b	e8 00 00 00 00	 call	 _memset
  00aa0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 609  : 
; 610  : 		if (driveNo == -1)

  00aa3	83 fb ff	 cmp	 ebx, -1
  00aa6	0f 84 3e 01 00
	00		 je	 $LN161@TCFormatVo

; 616  : 			goto fv_end;
; 617  : 		}
; 618  : 
; 619  : 		mountOptions.ReadOnly = FALSE;
; 620  : 		mountOptions.Removable = FALSE;
; 621  : 		mountOptions.ProtectHiddenVolume = FALSE;
; 622  : 		mountOptions.PreserveTimestamp = bPreserveTimestamp;

  00aac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bPreserveTimestamp
  00ab2	33 c0		 xor	 eax, eax

; 623  : 		mountOptions.PartitionInInactiveSysEncScope = FALSE;
; 624  : 		mountOptions.UseBackupHeader = FALSE;
; 625  : 
; 626  : 		if (MountVolume (volParams->hwndDlg, driveNo, volParams->volumePath, volParams->password, FALSE, TRUE, &mountOptions, FALSE, TRUE) < 1)

  00ab4	6a 01		 push	 1
  00ab6	50		 push	 eax
  00ab7	8d 94 24 bc 00
	00 00		 lea	 edx, DWORD PTR _mountOptions$81709[esp+140860]
  00abe	52		 push	 edx
  00abf	6a 01		 push	 1
  00ac1	50		 push	 eax
  00ac2	89 84 24 c8 00
	00 00		 mov	 DWORD PTR _mountOptions$81709[esp+140872], eax
  00ac9	89 84 24 cc 00
	00 00		 mov	 DWORD PTR _mountOptions$81709[esp+140876], eax
  00ad0	89 84 24 d0 00
	00 00		 mov	 DWORD PTR _mountOptions$81709[esp+140880], eax
  00ad7	89 84 24 d8 00
	00 00		 mov	 DWORD PTR _mountOptions$81709[esp+140888], eax
  00ade	89 84 24 24 01
	00 00		 mov	 DWORD PTR _mountOptions$81709[esp+140964], eax
  00ae5	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00ae8	50		 push	 eax
  00ae9	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR _mountOptions$81709[esp+140888], ecx
  00af0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00af3	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00af6	51		 push	 ecx
  00af7	53		 push	 ebx
  00af8	52		 push	 edx
  00af9	e8 00 00 00 00	 call	 _MountVolume
  00afe	83 c4 24	 add	 esp, 36			; 00000024H
  00b01	83 f8 01	 cmp	 eax, 1
  00b04	0f 8c 2a 01 00
	00		 jl	 $LN162@TCFormatVo

; 631  : 			goto fv_end;
; 632  : 		}
; 633  : 
; 634  : 		if (!IsAdmin () && IsUacSupported ())

  00b0a	e8 00 00 00 00	 call	 _IsAdmin
  00b0f	85 c0		 test	 eax, eax
  00b11	75 1c		 jne	 SHORT $LN10@TCFormatVo
  00b13	e8 00 00 00 00	 call	 _IsUacSupported
  00b18	85 c0		 test	 eax, eax
  00b1a	74 13		 je	 SHORT $LN10@TCFormatVo

; 635  : 			retCode = UacFormatNtfs (volParams->hwndDlg, driveNo, volParams->clusterSize);

  00b1c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00b1f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00b22	50		 push	 eax
  00b23	53		 push	 ebx
  00b24	51		 push	 ecx
  00b25	e8 00 00 00 00	 call	 _UacFormatNtfs
  00b2a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 636  : 		else

  00b2d	eb 0d		 jmp	 SHORT $LN9@TCFormatVo
$LN10@TCFormatVo:

; 637  : 			retCode = FormatNtfs (driveNo, volParams->clusterSize);

  00b2f	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00b32	52		 push	 edx
  00b33	53		 push	 ebx
  00b34	e8 00 00 00 00	 call	 _FormatNtfs
  00b39	83 c4 08	 add	 esp, 8
$LN9@TCFormatVo:

; 638  : 
; 639  : 		if (retCode != TRUE)
; 640  : 		{
; 641  : 			if (!UnmountVolume (volParams->hwndDlg, driveNo, FALSE))

  00b3c	6a 00		 push	 0
  00b3e	53		 push	 ebx
  00b3f	83 f8 01	 cmp	 eax, 1
  00b42	0f 84 46 01 00
	00		 je	 $LN8@TCFormatVo
  00b48	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00b4b	50		 push	 eax
  00b4c	e8 00 00 00 00	 call	 _UnmountVolume
  00b51	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b54	85 c0		 test	 eax, eax
  00b56	75 21		 jne	 SHORT $LN7@TCFormatVo

; 642  : 				MessageBoxW (volParams->hwndDlg, GetString ("CANT_DISMOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00b58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00b5e	6a 10		 push	 16			; 00000010H
  00b60	51		 push	 ecx
  00b61	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
  00b66	e8 00 00 00 00	 call	 _GetString
  00b6b	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00b6e	83 c4 04	 add	 esp, 4
  00b71	50		 push	 eax
  00b72	52		 push	 edx
  00b73	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN7@TCFormatVo:

; 643  : 
; 644  : 			if (dataAreaSize <= TC_MAX_FAT_SECTOR_COUNT * FormatSectorSize)

  00b79	a1 00 00 00 00	 mov	 eax, DWORD PTR _FormatSectorSize
  00b7e	bb 01 00 00 00	 mov	 ebx, 1
  00b83	53		 push	 ebx
  00b84	6a 00		 push	 0
  00b86	6a 00		 push	 0
  00b88	50		 push	 eax
  00b89	e8 00 00 00 00	 call	 __allmul
  00b8e	39 54 24 24	 cmp	 DWORD PTR _dataAreaSize$[esp+140856], edx
  00b92	0f 87 e2 00 00
	00		 ja	 $LN6@TCFormatVo
  00b98	72 0a		 jb	 SHORT $LN188@TCFormatVo
  00b9a	39 44 24 20	 cmp	 DWORD PTR _dataAreaSize$[esp+140852], eax
  00b9e	0f 87 d6 00 00
	00		 ja	 $LN6@TCFormatVo
$LN188@TCFormatVo:

; 645  : 			{
; 646  : 				if (AskErrYesNo ("FORMAT_NTFS_FAILED_ASK_FAT") == IDYES)

  00ba4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GAPIEOII@FORMAT_NTFS_FAILED_ASK_FAT?$AA@
  00ba9	e8 00 00 00 00	 call	 _AskErrYesNo
  00bae	83 c4 04	 add	 esp, 4
  00bb1	83 f8 06	 cmp	 eax, 6
  00bb4	0f 85 cd 00 00
	00		 jne	 $LN4@TCFormatVo

; 647  : 				{
; 648  : 					// NTFS format failed and the user wants to try FAT format immediately
; 649  : 					volParams->fileSystem = FILESYS_FAT;

  00bba	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx

; 650  : 					bInstantRetryOtherFilesys = TRUE;
; 651  : 					volParams->quickFormat = TRUE;		// Volume has already been successfully TC-formatted

  00bbd	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  00bc0	89 5c 24 1c	 mov	 DWORD PTR _bInstantRetryOtherFilesys$[esp+140852], ebx

; 652  : 					volParams->clusterSize = 0;		// Default cluster size

  00bc4	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 653  : 					goto begin_format;

  00bcb	e9 67 f6 ff ff	 jmp	 $LN190@TCFormatVo
$LN159@TCFormatVo:

; 176  : 			return ERR_OS_ERROR;

  00bd0	b8 01 00 00 00	 mov	 eax, 1
  00bd5	e9 44 f6 ff ff	 jmp	 $LN222@TCFormatVo
$LN160@TCFormatVo:

; 596  : 	{
; 597  : 		SetLastError(dwError);

  00bda	8b 4c 24 28	 mov	 ecx, DWORD PTR _dwError$[esp+140852]
  00bde	51		 push	 ecx
  00bdf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00be5	e9 d5 00 00 00	 jmp	 $fv_end$81705
$LN161@TCFormatVo:

; 611  : 		{
; 612  : 			MessageBoxW (volParams->hwndDlg, GetString ("NO_FREE_DRIVES"), lpszTitle, ICON_HAND);

  00bea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00bf0	6a 10		 push	 16			; 00000010H
  00bf2	52		 push	 edx
  00bf3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ECPPAAM@NO_FREE_DRIVES?$AA@
  00bf8	e8 00 00 00 00	 call	 _GetString
  00bfd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MessageBoxW@16
  00c03	83 c4 04	 add	 esp, 4
  00c06	50		 push	 eax
  00c07	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00c0a	50		 push	 eax
  00c0b	ff d7		 call	 edi

; 613  : 			MessageBoxW (volParams->hwndDlg, GetString ("FORMAT_NTFS_STOP"), lpszTitle, ICON_HAND);

  00c0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpszTitle
  00c13	6a 10		 push	 16			; 00000010H
  00c15	51		 push	 ecx
  00c16	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
  00c1b	e8 00 00 00 00	 call	 _GetString
  00c20	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00c23	83 c4 04	 add	 esp, 4
  00c26	50		 push	 eax
  00c27	52		 push	 edx
  00c28	ff d7		 call	 edi

; 614  : 
; 615  : 			nStatus = ERR_NO_FREE_DRIVES;

  00c2a	bd 16 00 00 00	 mov	 ebp, 22			; 00000016H

; 665  : 	}
; 666  : 
; 667  : fv_end:

  00c2f	e9 8b 00 00 00	 jmp	 $fv_end$81705
$LN162@TCFormatVo:

; 627  : 		{
; 628  : 			MessageBoxW (volParams->hwndDlg, GetString ("CANT_MOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00c34	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpszTitle
  00c39	6a 10		 push	 16			; 00000010H
  00c3b	50		 push	 eax
  00c3c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NBGKCIGC@CANT_MOUNT_VOLUME?$AA@
  00c41	e8 00 00 00 00	 call	 _GetString
  00c46	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00c49	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MessageBoxW@16
  00c4f	83 c4 04	 add	 esp, 4
  00c52	50		 push	 eax
  00c53	51		 push	 ecx
  00c54	ff d7		 call	 edi

; 629  : 			MessageBoxW (volParams->hwndDlg, GetString ("FORMAT_NTFS_STOP"), lpszTitle, ICON_HAND);

  00c56	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00c5c	6a 10		 push	 16			; 00000010H
  00c5e	52		 push	 edx
  00c5f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPBIAIE@FORMAT_NTFS_STOP?$AA@
  00c64	e8 00 00 00 00	 call	 _GetString
  00c69	83 c4 04	 add	 esp, 4
  00c6c	50		 push	 eax
  00c6d	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00c70	50		 push	 eax
  00c71	ff d7		 call	 edi

; 630  : 			nStatus = ERR_VOL_MOUNT_FAILED;

  00c73	bd 18 00 00 00	 mov	 ebp, 24			; 00000018H

; 665  : 	}
; 666  : 
; 667  : fv_end:

  00c78	eb 45		 jmp	 SHORT $fv_end$81705
$LN6@TCFormatVo:

; 654  : 				}
; 655  : 			}
; 656  : 			else
; 657  : 				Error ("FORMAT_NTFS_FAILED");

  00c7a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KDGBHLHC@FORMAT_NTFS_FAILED?$AA@
  00c7f	e8 00 00 00 00	 call	 _Error
  00c84	83 c4 04	 add	 esp, 4
$LN4@TCFormatVo:

; 658  : 
; 659  : 			nStatus = ERR_DONT_REPORT;

  00c87	bd 1c 00 00 00	 mov	 ebp, 28			; 0000001cH

; 665  : 	}
; 666  : 
; 667  : fv_end:

  00c8c	eb 31		 jmp	 SHORT $fv_end$81705
$LN8@TCFormatVo:

; 660  : 			goto fv_end;
; 661  : 		}
; 662  : 
; 663  : 		if (!UnmountVolume (volParams->hwndDlg, driveNo, FALSE))

  00c8e	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00c91	51		 push	 ecx
  00c92	e8 00 00 00 00	 call	 _UnmountVolume
  00c97	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c9a	85 c0		 test	 eax, eax
  00c9c	75 21		 jne	 SHORT $fv_end$81705

; 664  : 			MessageBoxW (volParams->hwndDlg, GetString ("CANT_DISMOUNT_VOLUME"), lpszTitle, ICON_HAND);

  00c9e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpszTitle
  00ca4	6a 10		 push	 16			; 00000010H
  00ca6	52		 push	 edx
  00ca7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLCHNIN@CANT_DISMOUNT_VOLUME?$AA@
  00cac	e8 00 00 00 00	 call	 _GetString
  00cb1	83 c4 04	 add	 esp, 4
  00cb4	50		 push	 eax
  00cb5	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00cb8	50		 push	 eax
  00cb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$fv_end$81705:

; 668  : 	dwError = GetLastError();

  00cbf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 669  : 
; 670  : 	if (dosDev[0])

  00cc5	80 bc 24 1c 04
	00 00 00	 cmp	 BYTE PTR _dosDev$[esp+140852], 0
  00ccd	8b f8		 mov	 edi, eax
  00ccf	74 14		 je	 SHORT $LN1@TCFormatVo

; 671  : 		RemoveFakeDosName (volParams->volumePath, dosDev);

  00cd1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00cd4	8d 8c 24 1c 04
	00 00		 lea	 ecx, DWORD PTR _dosDev$[esp+140852]
  00cdb	51		 push	 ecx
  00cdc	52		 push	 edx
  00cdd	e8 00 00 00 00	 call	 _RemoveFakeDosName
  00ce2	83 c4 08	 add	 esp, 8
$LN1@TCFormatVo:

; 672  : 
; 673  : 	crypto_close (cryptoInfo);

  00ce5	8b 44 24 10	 mov	 eax, DWORD PTR _cryptoInfo$[esp+140852]
  00ce9	50		 push	 eax
  00cea	e8 00 00 00 00	 call	 _crypto_close
  00cef	83 c4 04	 add	 esp, 4

; 674  : 
; 675  : 	SetLastError (dwError);

  00cf2	57		 push	 edi
  00cf3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 676  : 	return nStatus;

  00cf9	8b c5		 mov	 eax, ebp
  00cfb	e9 1e f5 ff ff	 jmp	 $LN222@TCFormatVo
$LN125@TCFormatVo:

; 102  : 	{
; 103  : 		Error ("SECTOR_SIZE_UNSUPPORTED");

  00d00	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FCILOPDD@SECTOR_SIZE_UNSUPPORTED?$AA@
  00d05	e8 00 00 00 00	 call	 _Error

; 677  : }

  00d0a	8b 8c 24 30 26
	02 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+140852]
  00d11	83 c4 04	 add	 esp, 4
  00d14	5f		 pop	 edi
  00d15	5e		 pop	 esi
  00d16	5b		 pop	 ebx
  00d17	33 cc		 xor	 ecx, esp
  00d19	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  00d1e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d23	81 c4 24 26 02
	00		 add	 esp, 140836		; 00022624H
  00d29	c3		 ret	 0
_TCFormatVolume ENDP
_TEXT	ENDS
END
