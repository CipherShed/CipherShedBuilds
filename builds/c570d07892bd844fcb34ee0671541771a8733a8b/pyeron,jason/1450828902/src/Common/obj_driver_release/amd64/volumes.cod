; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ReadVolumeHeaderRecoveryMode
ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
PUBLIC	GetHeaderField64
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\common\volumes.c
;	COMDAT GetHeaderField64
_TEXT	SEGMENT
header$ = 8
offset$ = 16
GetHeaderField64 PROC					; COMDAT

; 137  : {

  00000	48 8b c1	 mov	 rax, rcx

; 138  : 	UINT64_STRUCT uint64Struct;
; 139  : 
; 140  : #ifndef TC_NO_COMPILER_INT64
; 141  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00003	48 63 ca	 movsxd	 rcx, edx
  00006	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]

; 142  : #else
; 143  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 144  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 145  : #endif
; 146  : 	return uint64Struct;
; 147  : }

  0000a	e9 00 00 00 00	 jmp	 MirrorBytes64
GetHeaderField64 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField32
; Function compile flags: /Ogspy
;	COMDAT GetHeaderField32
_TEXT	SEGMENT
header$ = 8
offset$ = 16
GetHeaderField32 PROC					; COMDAT

; 132  : 	return BE32 (*(uint32 *) (header + offset));

  00000	48 63 c2	 movsxd	 rax, edx
  00003	44 8b 04 08	 mov	 r8d, DWORD PTR [rax+rcx]
  00007	41 8b c0	 mov	 eax, r8d
  0000a	41 0f b6 c8	 movzx	 ecx, r8b
  0000e	c1 e8 08	 shr	 eax, 8
  00011	c1 e1 08	 shl	 ecx, 8
  00014	0f b6 c0	 movzx	 eax, al
  00017	0b c1		 or	 eax, ecx
  00019	41 8b c8	 mov	 ecx, r8d
  0001c	41 c1 e8 18	 shr	 r8d, 24
  00020	c1 e0 08	 shl	 eax, 8
  00023	c1 e9 10	 shr	 ecx, 16
  00026	0f b6 d1	 movzx	 edx, cl
  00029	0b c2		 or	 eax, edx
  0002b	c1 e0 08	 shl	 eax, 8
  0002e	41 0b c0	 or	 eax, r8d

; 133  : }

  00031	c3		 ret	 0
GetHeaderField32 ENDP
_TEXT	ENDS
PUBLIC	GetHeaderField16
; Function compile flags: /Ogspy
;	COMDAT GetHeaderField16
_TEXT	SEGMENT
header$ = 8
offset$ = 16
GetHeaderField16 PROC					; COMDAT

; 126  : 	return BE16 (*(uint16 *) (header + offset));

  00000	48 63 c2	 movsxd	 rax, edx
  00003	0f b7 14 08	 movzx	 edx, WORD PTR [rax+rcx]
  00007	8b c2		 mov	 eax, edx
  00009	c1 e2 08	 shl	 edx, 8
  0000c	c1 e8 08	 shr	 eax, 8
  0000f	0b c2		 or	 eax, edx

; 127  : }

  00011	c3		 ret	 0
GetHeaderField16 ENDP
PUBLIC	__$ArrayPad$
PUBLIC	ReadVolumeHeader
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$ReadVolumeHeader DD imagerel $LN221
	DD	imagerel $LN221+2947
	DD	imagerel $unwind$ReadVolumeHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadVolumeHeader DD 0a2619H
	DD	0ab0114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	0540H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\common\volumes.c
xdata	ENDS
;	COMDAT ReadVolumeHeader
_TEXT	SEGMENT
retInfo$GSCopy$1$ = 64
retHeaderCryptoInfo$GSCopy$1$ = 72
pkcs5_prf$1$ = 80
outstandingWorkItemCount$ = 84
lrw128InitDone$1$ = 88
bBoot$GSCopy$1$ = 92
lrw64InitDone$1$ = 96
queuedWorkItems$1$ = 104
encryptedHeader$GSCopy$1$ = 112
keyDerivationWorkItems$ = 112
encryptionThreadCount$1$ = 120
noOutstandingWorkItemEvent$ = 128
keyDerivationCompletedEvent$ = 152
keyInfo$ = 176
dk$ = 576
header$ = 832
__$ArrayPad$ = 1344
bBoot$ = 1440
encryptedHeader$ = 1448
password$ = 1456
retInfo$ = 1464
retHeaderCryptoInfo$ = 1472
ReadVolumeHeader PROC					; COMDAT

; 164  : {

$LN221:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec 58 05
	00 00		 sub	 rsp, 1368		; 00000558H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 40
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 165  : 	char header[TC_VOLUME_HEADER_EFFECTIVE_SIZE];
; 166  : 	KEY_INFO keyInfo;
; 167  : 	PCRYPTO_INFO cryptoInfo;
; 168  : 	char dk[MASTER_KEYDATA_SIZE];
; 169  : 	int enqPkcs5Prf, pkcs5_prf;
; 170  : 	uint16 headerVersion;
; 171  : 	int status = ERR_PARAMETER_INCORRECT;
; 172  : 	int primaryKeyOffset;
; 173  : 
; 174  : 	TC_EVENT keyDerivationCompletedEvent;
; 175  : 	TC_EVENT noOutstandingWorkItemEvent;
; 176  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 177  : 	KeyDerivationWorkItem *item;
; 178  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 179  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00026	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ThreadPoolRunning
  0002c	89 4c 24 5c	 mov	 DWORD PTR bBoot$GSCopy$1$[rsp], ecx
  00030	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR retHeaderCryptoInfo$[rsp]
  00038	f7 d8		 neg	 eax
  0003a	4d 8b f1	 mov	 r14, r9
  0003d	4c 89 4c 24 40	 mov	 QWORD PTR retInfo$GSCopy$1$[rsp], r9
  00042	1b c0		 sbb	 eax, eax

; 180  : 	size_t queuedWorkItems = 0;

  00044	33 ed		 xor	 ebp, ebp
  00046	49 8b f0	 mov	 rsi, r8
  00049	23 05 00 00 00
	00		 and	 eax, DWORD PTR ThreadCount

; 181  : 	LONG outstandingWorkItemCount = 0;

  0004f	21 6c 24 54	 and	 DWORD PTR outstandingWorkItemCount$[rsp], ebp
  00053	4c 8b e2	 mov	 r12, rdx
  00056	8b f8		 mov	 edi, eax
  00058	48 89 54 24 70	 mov	 QWORD PTR encryptedHeader$GSCopy$1$[rsp], rdx
  0005d	48 89 4c 24 48	 mov	 QWORD PTR retHeaderCryptoInfo$GSCopy$1$[rsp], rcx
  00062	48 89 6c 24 68	 mov	 QWORD PTR queuedWorkItems$1$[rsp], rbp
  00067	48 89 7c 24 78	 mov	 QWORD PTR encryptionThreadCount$1$[rsp], rdi

; 182  : 	int i;
; 183  : 
; 184  : 	if (retHeaderCryptoInfo != NULL)

  0006c	48 85 c9	 test	 rcx, rcx
  0006f	74 6e		 je	 SHORT $LN92@ReadVolume

; 185  : 	{
; 186  : 		cryptoInfo = retHeaderCryptoInfo;

  00071	48 8b d9	 mov	 rbx, rcx
$LN90@ReadVolume:

; 193  : 	}
; 194  : 
; 195  : 	if (encryptionThreadCount > 1)

  00074	41 bd 04 00 00
	00		 mov	 r13d, 4
  0007a	45 8d 75 fd	 lea	 r14d, QWORD PTR [r13-3]
  0007e	49 3b fe	 cmp	 rdi, r14
  00081	76 76		 jbe	 SHORT $LN208@ReadVolume

; 196  : 	{
; 197  : 		keyDerivationWorkItems = TCalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00083	ba 30 04 00 00	 mov	 edx, 1072		; 00000430H
  00088	33 c9		 xor	 ecx, ecx
  0008a	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00096	4c 8b f8	 mov	 r15, rax

; 198  : 		if (!keyDerivationWorkItems)

  00099	48 85 c0	 test	 rax, rax

; 199  : 			return ERR_OUTOFMEMORY;

  0009c	74 51		 je	 SHORT $LN220@ReadVolume

; 200  : 
; 201  : 		for (i = 0; i < pkcs5PrfCount; ++i)

  0009e	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  000a4	49 8b cd	 mov	 rcx, r13
$LL87@ReadVolume:

; 202  : 			keyDerivationWorkItems[i].Free = TRUE;

  000a7	44 89 30	 mov	 DWORD PTR [rax], r14d
  000aa	48 05 0c 01 00
	00		 add	 rax, 268		; 0000010cH
  000b0	49 2b ce	 sub	 rcx, r14
  000b3	75 f2		 jne	 SHORT $LL87@ReadVolume

; 203  : 
; 204  : #ifdef DEVICE_DRIVER
; 205  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);

  000b5	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  000bd	45 33 c0	 xor	 r8d, r8d
  000c0	41 8b d6	 mov	 edx, r14d
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 206  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  000c9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  000d1	45 8a c6	 mov	 r8b, r14b
  000d4	41 8b d6	 mov	 edx, r14d
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent
  000dd	eb 1f		 jmp	 SHORT $LN89@ReadVolume
$LN92@ReadVolume:

; 187  : 	}
; 188  : 	else
; 189  : 	{
; 190  : 		cryptoInfo = *retInfo = crypto_open ();

  000df	e8 00 00 00 00	 call	 crypto_open
  000e4	48 8b d8	 mov	 rbx, rax
  000e7	49 89 06	 mov	 QWORD PTR [r14], rax

; 191  : 		if (cryptoInfo == NULL)

  000ea	48 85 c0	 test	 rax, rax
  000ed	75 85		 jne	 SHORT $LN90@ReadVolume
$LN220@ReadVolume:

; 192  : 			return ERR_OUTOFMEMORY;

  000ef	b8 02 00 00 00	 mov	 eax, 2
  000f4	e9 66 0a 00 00	 jmp	 $LN93@ReadVolume
$LN208@ReadVolume:

; 206  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);

  000f9	4c 8b 7c 24 70	 mov	 r15, QWORD PTR keyDerivationWorkItems$[rsp]
$LN89@ReadVolume:

; 207  : #else
; 208  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
; 209  : 		if (!keyDerivationCompletedEvent)
; 210  : 		{
; 211  : 			TCfree (keyDerivationWorkItems);
; 212  : 			return ERR_OUTOFMEMORY;
; 213  : 		}
; 214  : 
; 215  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);
; 216  : 		if (!noOutstandingWorkItemEvent)
; 217  : 		{
; 218  : 			CloseHandle (keyDerivationCompletedEvent);
; 219  : 			TCfree (keyDerivationWorkItems);
; 220  : 			return ERR_OUTOFMEMORY;
; 221  : 		}
; 222  : #endif
; 223  : 	}
; 224  : 		
; 225  : #ifndef DEVICE_DRIVER
; 226  : 	VirtualLock (&keyInfo, sizeof (keyInfo));
; 227  : 	VirtualLock (&dk, sizeof (dk));
; 228  : #endif
; 229  : 
; 230  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  000fe	4c 63 0e	 movsxd	 r9, DWORD PTR [rsi]
  00101	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00107	48 8d bc 24 b8
	00 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp+8]
  0010f	33 c0		 xor	 eax, eax
  00111	49 8b c8	 mov	 rcx, r8
  00114	44 89 8c 24 b4
	00 00 00	 mov	 DWORD PTR keyInfo$[rsp+4], r9d
  0011c	f3 aa		 rep stosb
  0011e	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+8]
$LL98@ReadVolume:
  00126	88 02		 mov	 BYTE PTR [rdx], al
  00128	49 03 d6	 add	 rdx, r14
  0012b	45 2b c6	 sub	 r8d, r14d
  0012e	75 f6		 jne	 SHORT $LL98@ReadVolume
  00130	48 8d 56 04	 lea	 rdx, QWORD PTR [rsi+4]
  00134	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  0013c	4d 8b c1	 mov	 r8, r9
  0013f	e8 00 00 00 00	 call	 memcpy

; 231  : 
; 232  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 233  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  00144	be 40 00 00 00	 mov	 esi, 64			; 00000040H
  00149	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+72]
  00151	4c 8b c6	 mov	 r8, rsi
  00154	49 8b d4	 mov	 rdx, r12
  00157	e8 00 00 00 00	 call	 memcpy

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  0015c	45 8b ee	 mov	 r13d, r14d
  0015f	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  00165	44 8d 46 c4	 lea	 r8d, QWORD PTR [rsi-60]
$LL84@ReadVolume:
  00169	45 3b e8	 cmp	 r13d, r8d
  0016c	7e 09		 jle	 SHORT $LN81@ReadVolume
  0016e	48 85 ed	 test	 rbp, rbp
  00171	0f 84 7f 07 00
	00		 je	 $LN82@ReadVolume
$LN81@ReadVolume:

; 237  : 	{
; 238  : 		BOOL lrw64InitDone = FALSE;		// Deprecated/legacy
; 239  : 		BOOL lrw128InitDone = FALSE;	// Deprecated/legacy
; 240  : 
; 241  : 		if (encryptionThreadCount > 1)

  00177	48 8b 44 24 78	 mov	 rax, QWORD PTR encryptionThreadCount$1$[rsp]
  0017c	83 64 24 60 00	 and	 DWORD PTR lrw64InitDone$1$[rsp], 0
  00181	83 64 24 58 00	 and	 DWORD PTR lrw128InitDone$1$[rsp], 0
  00186	49 3b c6	 cmp	 rax, r14
  00189	0f 86 3d 02 00
	00		 jbe	 $LN80@ReadVolume

; 242  : 		{
; 243  : 			// Enqueue key derivation on thread pool
; 244  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  0018f	48 3b e8	 cmp	 rbp, rax
  00192	0f 83 91 01 00
	00		 jae	 $LN79@ReadVolume
  00198	45 3b e8	 cmp	 r13d, r8d
  0019b	0f 8f 88 01 00
	00		 jg	 $LN79@ReadVolume

; 245  : 			{
; 246  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001a1	33 c0		 xor	 eax, eax
  001a3	49 8b f7	 mov	 rsi, r15
$LL78@ReadVolume:

; 247  : 				{
; 248  : 					item = &keyDerivationWorkItems[i];
; 249  : 					if (item->Free)

  001a6	83 be 00 01 00
	00 00		 cmp	 DWORD PTR [rsi+256], 0
  001ad	75 14		 jne	 SHORT $LN185@ReadVolume
  001af	49 03 c6	 add	 rax, r14
  001b2	48 81 c6 0c 01
	00 00		 add	 rsi, 268		; 0000010cH
  001b9	49 3b c0	 cmp	 rax, r8
  001bc	7c e8		 jl	 SHORT $LL78@ReadVolume

; 250  : 					{
; 251  : 						item->Free = FALSE;
; 252  : 						item->KeyReady = FALSE;
; 253  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 254  : 
; 255  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 256  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 257  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  001be	e9 5b 01 00 00	 jmp	 $LN76@ReadVolume
$LN185@ReadVolume:
  001c3	8b 54 24 5c	 mov	 edx, DWORD PTR bBoot$GSCopy$1$[rsp]
  001c7	83 a6 00 01 00
	00 00		 and	 DWORD PTR [rsi+256], 0
  001ce	48 8d ae 04 01
	00 00		 lea	 rbp, QWORD PTR [rsi+260]
  001d5	83 65 00 00	 and	 DWORD PTR [rbp], 0
  001d9	41 8b cd	 mov	 ecx, r13d
  001dc	44 89 ae 08 01
	00 00		 mov	 DWORD PTR [rsi+264], r13d
  001e3	e8 00 00 00 00	 call	 get_pkcs5_iteration_count
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ThreadPoolRunning
  001ee	44 8b b4 24 b4
	00 00 00	 mov	 r14d, DWORD PTR keyInfo$[rsp+4]
  001f6	44 8b e0	 mov	 r12d, eax
  001f9	85 c9		 test	 ecx, ecx
  001fb	0f 84 ff 06 00
	00		 je	 $LN191@ReadVolume
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireFastMutex
  0020e	48 63 3d 00 00
	00 00		 movsxd	 rdi, DWORD PTR EnqueuePosition
  00215	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:WorkItemQueue
  0021c	48 6b ff 78	 imul	 rdi, 120		; 00000078H
  00220	48 03 f8	 add	 rdi, rax
  00223	b8 01 00 00 00	 mov	 eax, 1
  00228	01 05 00 00 00
	00		 add	 DWORD PTR EnqueuePosition, eax
  0022e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR EnqueuePosition
  00234	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00239	7c 0a		 jl	 SHORT $LN177@ReadVolume
  0023b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR EnqueuePosition, 0
$LN177@ReadVolume:
  00245	33 c0		 xor	 eax, eax
  00247	f0 0f c1 07	 lock xadd DWORD PTR [rdi], eax
  0024b	85 c0		 test	 eax, eax
  0024d	74 25		 je	 SHORT $LN106@ReadVolume
$LL107@ReadVolume:
  0024f	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemCompletedEvent
  0025c	45 33 c9	 xor	 r9d, r9d
  0025f	45 33 c0	 xor	 r8d, r8d
  00262	33 d2		 xor	 edx, edx
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  0026a	33 d2		 xor	 edx, edx
  0026c	f0 0f c1 17	 lock xadd DWORD PTR [rdi], edx
  00270	85 d2		 test	 edx, edx
  00272	75 db		 jne	 SHORT $LL107@ReadVolume
$LN106@ReadVolume:
  00274	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR keyDerivationCompletedEvent$[rsp]
  0027c	44 89 77 68	 mov	 DWORD PTR [rdi+104], r14d
  00280	c7 47 04 02 00
	00 00		 mov	 DWORD PTR [rdi+4], 2
  00287	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  0028b	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00293	48 89 6f 38	 mov	 QWORD PTR [rdi+56], rbp
  00297	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  0029b	48 8d 44 24 54	 lea	 rax, QWORD PTR outstandingWorkItemCount$[rsp]
  002a0	48 89 77 40	 mov	 QWORD PTR [rdi+64], rsi
  002a4	48 89 47 58	 mov	 QWORD PTR [rdi+88], rax
  002a8	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+8]
  002b0	44 89 67 48	 mov	 DWORD PTR [rdi+72], r12d
  002b4	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  002b8	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR keyInfo$[rsp+72]
  002c0	44 89 6f 6c	 mov	 DWORD PTR [rdi+108], r13d
  002c4	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  002c8	41 be 01 00 00
	00		 mov	 r14d, 1
  002ce	f0 44 01 74 24
	54		 lock add DWORD PTR outstandingWorkItemCount$[rsp], r14d
  002d4	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent
  002e2	41 8b d6	 mov	 edx, r14d
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:WorkItemReadyEvent
  002ec	87 17		 xchg	 DWORD PTR [rdi], edx
  002ee	41 8b d6	 mov	 edx, r14d
  002f1	45 33 c0	 xor	 r8d, r8d
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeSetEvent
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EnqueueMutex
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseFastMutex

; 258  : 						
; 259  : 						++queuedWorkItems;

  00307	48 8b 6c 24 68	 mov	 rbp, QWORD PTR queuedWorkItems$1$[rsp]
  0030c	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  00312	49 03 ee	 add	 rbp, r14
  00315	45 8d 46 03	 lea	 r8d, QWORD PTR [r14+3]
  00319	48 89 6c 24 68	 mov	 QWORD PTR queuedWorkItems$1$[rsp], rbp
$LN76@ReadVolume:

; 260  : 						break;
; 261  : 					}
; 262  : 				}
; 263  : 
; 264  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  0031e	45 3b e8	 cmp	 r13d, r8d
  00321	0f 8c bd 05 00
	00		 jl	 $LN83@ReadVolume

; 265  : 					continue;
; 266  : 			}
; 267  : 			else

  00327	eb 03		 jmp	 SHORT $LN178@ReadVolume
$LN79@ReadVolume:

; 268  : 				--enqPkcs5Prf;

  00329	45 2b ee	 sub	 r13d, r14d
$LN178@ReadVolume:

; 269  : 
; 270  : 			// Wait for completion of a key derivation
; 271  : 			while (queuedWorkItems > 0)

  0032c	48 85 ed	 test	 rbp, rbp
  0032f	0f 84 af 05 00
	00		 je	 $LN83@ReadVolume
$LL72@ReadVolume:

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00335	33 d2		 xor	 edx, edx
  00337	49 8d 8f 04 01
	00 00		 lea	 rcx, QWORD PTR [r15+260]
$LL70@ReadVolume:

; 274  : 				{
; 275  : 					item = &keyDerivationWorkItems[i];
; 276  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  0033e	83 79 fc 00	 cmp	 DWORD PTR [rcx-4], 0
  00342	48 8d b9 fc fe
	ff ff		 lea	 rdi, QWORD PTR [rcx-260]
  00349	75 0b		 jne	 SHORT $LN69@ReadVolume
  0034b	33 c0		 xor	 eax, eax
  0034d	f0 0f c1 01	 lock xadd DWORD PTR [rcx], eax
  00351	41 3b c6	 cmp	 eax, r14d
  00354	74 33		 je	 SHORT $LN186@ReadVolume
$LN69@ReadVolume:

; 272  : 			{
; 273  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00356	49 03 d6	 add	 rdx, r14
  00359	48 81 c1 0c 01
	00 00		 add	 rcx, 268		; 0000010cH
  00360	49 3b d0	 cmp	 rdx, r8
  00363	7c d9		 jl	 SHORT $LL70@ReadVolume

; 284  : 						goto KeyReady;
; 285  : 					}
; 286  : 				}
; 287  : 
; 288  : 				if (queuedWorkItems > 0)
; 289  : 					TC_WAIT_EVENT (keyDerivationCompletedEvent);

  00365	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0036b	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR keyDerivationCompletedEvent$[rsp]
  00373	45 33 c9	 xor	 r9d, r9d
  00376	45 33 c0	 xor	 r8d, r8d
  00379	33 d2		 xor	 edx, edx
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject
  00381	41 b8 04 00 00
	00		 mov	 r8d, 4
  00387	eb ac		 jmp	 SHORT $LL72@ReadVolume
$LN186@ReadVolume:

; 277  : 					{
; 278  : 						pkcs5_prf = item->Pkcs5Prf;

  00389	8b b7 08 01 00
	00		 mov	 esi, DWORD PTR [rdi+264]

; 279  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  0038f	8b 54 24 5c	 mov	 edx, DWORD PTR bBoot$GSCopy$1$[rsp]
  00393	8b ce		 mov	 ecx, esi
  00395	89 74 24 50	 mov	 DWORD PTR pkcs5_prf$1$[rsp], esi
  00399	e8 00 00 00 00	 call	 get_pkcs5_iteration_count

; 280  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  0039e	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR dk$[rsp]
  003a6	48 8b d7	 mov	 rdx, rdi
  003a9	4d 8b c4	 mov	 r8, r12
  003ac	89 84 24 b0 00
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax
  003b3	e8 00 00 00 00	 call	 memcpy

; 281  : 
; 282  : 						item->Free = TRUE;
; 283  : 						--queuedWorkItems;

  003b8	49 2b ee	 sub	 rbp, r14
  003bb	44 89 b7 00 01
	00 00		 mov	 DWORD PTR [rdi+256], r14d
  003c2	48 89 6c 24 68	 mov	 QWORD PTR queuedWorkItems$1$[rsp], rbp
$KeyReady$29734:

; 290  : 			}
; 291  : 			continue;
; 292  : KeyReady:	;
; 293  : 		}
; 294  : 		else

  003c7	e9 2a 01 00 00	 jmp	 $LN63@ReadVolume
$LN80@ReadVolume:

; 295  : 		{
; 296  : 			pkcs5_prf = enqPkcs5Prf;
; 297  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  003cc	8b 54 24 5c	 mov	 edx, DWORD PTR bBoot$GSCopy$1$[rsp]
  003d0	41 8b cd	 mov	 ecx, r13d
  003d3	44 89 6c 24 50	 mov	 DWORD PTR pkcs5_prf$1$[rsp], r13d
  003d8	e8 00 00 00 00	 call	 get_pkcs5_iteration_count

; 298  : 
; 299  : 			switch (pkcs5_prf)

  003dd	41 8b d5	 mov	 edx, r13d
  003e0	41 2b d6	 sub	 edx, r14d
  003e3	8b f8		 mov	 edi, eax
  003e5	89 84 24 b0 00
	00 00		 mov	 DWORD PTR keyInfo$[rsp], eax
  003ec	0f 84 cb 00 00
	00		 je	 $LN62@ReadVolume
  003f2	41 2b d6	 sub	 edx, r14d
  003f5	0f 84 87 00 00
	00		 je	 $LN61@ReadVolume
  003fb	41 2b d6	 sub	 edx, r14d
  003fe	74 47		 je	 SHORT $LN59@ReadVolume
  00400	41 3b d6	 cmp	 edx, r14d
  00403	0f 85 16 05 00
	00		 jne	 $LN207@ReadVolume

; 310  : 
; 311  : 			case SHA1:
; 312  : 				// Deprecated/legacy
; 313  : 				derive_key_sha1 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 314  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00409	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0040e	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  00415	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  0041d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00421	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  00429	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  00431	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00436	44 8b ce	 mov	 r9d, esi
  00439	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0043d	e8 00 00 00 00	 call	 derive_key_sha1

; 315  : 				break;

  00442	e9 af 00 00 00	 jmp	 $LN63@ReadVolume
$LN59@ReadVolume:

; 316  : 
; 317  : 			case WHIRLPOOL:
; 318  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 319  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00447	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  0044c	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  00453	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  0045b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0045f	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  00467	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  0046f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00474	44 8b ce	 mov	 r9d, esi
  00477	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0047b	e8 00 00 00 00	 call	 derive_key_whirlpool

; 320  : 				break;

  00480	eb 74		 jmp	 SHORT $LN63@ReadVolume
$LN61@ReadVolume:

; 304  : 				break;
; 305  : 
; 306  : 			case SHA512:
; 307  : 				derive_key_sha512 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 308  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  00482	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  00487	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  0048e	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  00496	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0049a	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  004a2	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  004aa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004af	44 8b ce	 mov	 r9d, esi
  004b2	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  004b6	e8 00 00 00 00	 call	 derive_key_sha512

; 309  : 				break;

  004bb	eb 39		 jmp	 SHORT $LN63@ReadVolume
$LN62@ReadVolume:

; 300  : 			{
; 301  : 			case RIPEMD160:
; 302  : 				derive_key_ripemd160 (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,
; 303  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());

  004bd	e8 00 00 00 00	 call	 GetMaxPkcs5OutSize
  004c2	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR keyInfo$[rsp+4]
  004c9	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp+72]
  004d1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  004d5	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR dk$[rsp]
  004dd	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+8]
  004e5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004ea	44 8b ce	 mov	 r9d, esi
  004ed	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  004f1	e8 00 00 00 00	 call	 derive_key_ripemd160
$LN63@ReadVolume:

; 325  : 			} 
; 326  : 		}
; 327  : 
; 328  : 		// Test all available modes of operation
; 329  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;
; 330  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 331  : 			cryptoInfo->mode++)

  004f6	44 89 73 04	 mov	 DWORD PTR [rbx+4], r14d
$LL57@ReadVolume:

; 332  : 		{
; 333  : 			switch (cryptoInfo->mode)

  004fa	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  004fd	83 c0 fe	 add	 eax, -2			; fffffffeH
  00500	83 f8 03	 cmp	 eax, 3
  00503	77 21		 ja	 SHORT $LN51@ReadVolume

; 334  : 			{
; 335  : 			case LRW:
; 336  : 			case CBC:
; 337  : 			case INNER_CBC:
; 338  : 			case OUTER_CBC:
; 339  : 
; 340  : 				// For LRW (deprecated/legacy), copy the tweak key 
; 341  : 				// For CBC (deprecated/legacy), copy the IV/whitening seed 
; 342  : 				memcpy (cryptoInfo->k2, dk, LEGACY_VOL_IV_SIZE);

  00505	bf 20 00 00 00	 mov	 edi, 32			; 00000020H
  0050a	48 8d 8b a8 42
	00 00		 lea	 rcx, QWORD PTR [rbx+17064]
  00511	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR dk$[rsp]
  00519	4c 8b c7	 mov	 r8, rdi
  0051c	e8 00 00 00 00	 call	 memcpy

; 343  : 				primaryKeyOffset = LEGACY_VOL_IV_SIZE;

  00521	44 8b f7	 mov	 r14d, edi

; 344  : 				break;

  00524	eb 03		 jmp	 SHORT $LN53@ReadVolume
$LN51@ReadVolume:

; 345  : 
; 346  : 			default:
; 347  : 				primaryKeyOffset = 0;

  00526	45 33 f6	 xor	 r14d, r14d
$LN53@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00529	bd 01 00 00 00	 mov	 ebp, 1
  0052e	89 2b		 mov	 DWORD PTR [rbx], ebp
$LL50@ReadVolume:

; 354  : 			{
; 355  : 				int blockSize;
; 356  : 
; 357  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  00530	8b 53 04	 mov	 edx, DWORD PTR [rbx+4]
  00533	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00535	e8 00 00 00 00	 call	 EAIsModeSupported
  0053a	85 c0		 test	 eax, eax
  0053c	0f 84 64 03 00
	00		 je	 $LN49@ReadVolume

; 358  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 359  : 
; 360  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  00542	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  00545	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  0054c	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  00550	8b 0c 08	 mov	 ecx, DWORD PTR [rax+rcx]
  00553	e8 00 00 00 00	 call	 CipherGet

; 361  : 
; 362  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  00558	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0055a	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  0055e	8b 78 10	 mov	 edi, DWORD PTR [rax+16]
  00561	49 63 c6	 movsxd	 rax, r14d
  00564	48 8d 94 04 40
	02 00 00	 lea	 rdx, QWORD PTR dk$[rsp+rax]
  0056c	e8 00 00 00 00	 call	 EAInit
  00571	8b f0		 mov	 esi, eax

; 363  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00573	83 f8 11	 cmp	 eax, 17
  00576	0f 84 31 05 00
	00		 je	 $LN213@ReadVolume

; 364  : 					goto err;
; 365  : 
; 366  : 				// Init objects related to the mode of operation
; 367  : 
; 368  : 				if (cryptoInfo->mode == XTS)

  0057c	39 6b 04	 cmp	 DWORD PTR [rbx+4], ebp
  0057f	75 41		 jne	 SHORT $LN45@ReadVolume

; 369  : 				{
; 370  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 371  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00581	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00583	e8 00 00 00 00	 call	 EAGetKeySize
  00588	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0058a	48 63 f8	 movsxd	 rdi, eax
  0058d	e8 00 00 00 00	 call	 EAGetKeySize
  00592	4c 8b c7	 mov	 r8, rdi
  00595	48 63 c8	 movsxd	 rcx, eax
  00598	48 8d 94 0c 40
	02 00 00	 lea	 rdx, QWORD PTR dk$[rsp+rcx]
  005a0	48 8d 8b a8 42
	00 00		 lea	 rcx, QWORD PTR [rbx+17064]
  005a7	e8 00 00 00 00	 call	 memcpy

; 372  : 
; 373  : 					// Secondary key schedule
; 374  : 					if (!EAInitMode (cryptoInfo))

  005ac	48 8b cb	 mov	 rcx, rbx
  005af	e8 00 00 00 00	 call	 EAInitMode
  005b4	85 c0		 test	 eax, eax
  005b6	75 34		 jne	 SHORT $LN36@ReadVolume
$LN188@ReadVolume:

; 375  : 					{
; 376  : 						status = ERR_MODE_INIT_FAILED;

  005b8	be 1b 00 00 00	 mov	 esi, 27

; 377  : 						goto err;

  005bd	e9 eb 04 00 00	 jmp	 $LN213@ReadVolume
$LN45@ReadVolume:

; 378  : 					}
; 379  : 				}
; 380  : 				else if (cryptoInfo->mode == LRW
; 381  : 					&& (blockSize == 8 && !lrw64InitDone || blockSize == 16 && !lrw128InitDone))

  005c2	83 7b 04 02	 cmp	 DWORD PTR [rbx+4], 2
  005c6	75 24		 jne	 SHORT $LN36@ReadVolume
  005c8	83 ff 08	 cmp	 edi, 8
  005cb	75 0b		 jne	 SHORT $LN40@ReadVolume
  005cd	83 7c 24 60 00	 cmp	 DWORD PTR lrw64InitDone$1$[rsp], 0
  005d2	0f 84 87 02 00
	00		 je	 $LN214@ReadVolume
$LN40@ReadVolume:
  005d8	83 ff 10	 cmp	 edi, 16
  005db	75 0f		 jne	 SHORT $LN36@ReadVolume
  005dd	8b 6c 24 58	 mov	 ebp, DWORD PTR lrw128InitDone$1$[rsp]
  005e1	85 ed		 test	 ebp, ebp
  005e3	0f 84 7a 02 00
	00		 je	 $LN41@ReadVolume

; 164  : {

  005e9	8d 6f f1	 lea	 ebp, QWORD PTR [rdi-15]
$LN36@ReadVolume:

; 394  : 						lrw128InitDone = TRUE;
; 395  : 				}
; 396  : 
; 397  : 				// Copy the header for decryption
; 398  : 				memcpy (header, encryptedHeader, sizeof (header));

  005ec	48 8b 54 24 70	 mov	 rdx, QWORD PTR encryptedHeader$GSCopy$1$[rsp]
  005f1	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp]
  005f9	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  005ff	e8 00 00 00 00	 call	 memcpy

; 399  : 
; 400  : 				// Try to decrypt header 
; 401  : 
; 402  : 				DecryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  00604	48 8d 8c 24 80
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  0060c	4c 8b c3	 mov	 r8, rbx
  0060f	ba c0 01 00 00	 mov	 edx, 448		; 000001c0H
  00614	e8 00 00 00 00	 call	 DecryptBuffer

; 403  : 
; 404  : 				// Magic 'TRUE'
; 405  : 				/* Modifying 'TRUE' can introduce incompatibility with previous versions. */
; 406  : 				if (GetHeaderField32 (header, TC_HEADER_OFFSET_MAGIC) != 0x54525545)

  00619	8b bc 24 80 03
	00 00		 mov	 edi, DWORD PTR header$[rsp+64]
  00620	8b c7		 mov	 eax, edi
  00622	c1 e8 08	 shr	 eax, 8
  00625	0f b6 d0	 movzx	 edx, al
  00628	40 0f b6 c7	 movzx	 eax, dil
  0062c	c1 e0 08	 shl	 eax, 8
  0062f	0b d0		 or	 edx, eax
  00631	8b c7		 mov	 eax, edi
  00633	c1 ef 18	 shr	 edi, 24
  00636	c1 e2 08	 shl	 edx, 8
  00639	c1 e8 10	 shr	 eax, 16
  0063c	0f b6 c8	 movzx	 ecx, al
  0063f	0b d1		 or	 edx, ecx
  00641	c1 e2 08	 shl	 edx, 8
  00644	0b d7		 or	 edx, edi
  00646	81 fa 45 55 52
	54		 cmp	 edx, 1414681925		; 54525545H
  0064c	0f 85 54 02 00
	00		 jne	 $LN49@ReadVolume

; 407  : 					continue;
; 408  : 
; 409  : 				// Header version
; 410  : 				headerVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_VERSION);

  00652	0f b7 ac 24 84
	03 00 00	 movzx	 ebp, WORD PTR header$[rsp+68]

; 411  : 				
; 412  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  0065a	b8 05 00 00 00	 mov	 eax, 5
  0065f	66 c1 c5 08	 rol	 bp, 8
  00663	66 3b e8	 cmp	 bp, ax
  00666	0f 87 3c 04 00
	00		 ja	 $LN190@ReadVolume

; 415  : 					goto err;
; 416  : 				}
; 417  : 
; 418  : 				// Check CRC of the header fields
; 419  : 				if (!ReadVolumeHeaderRecoveryMode
; 420  : 					&& headerVersion >= 4
; 421  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + TC_HEADER_OFFSET_MAGIC, TC_HEADER_OFFSET_HEADER_CRC - TC_HEADER_OFFSET_MAGIC))

  0066c	44 8b 25 00 00
	00 00		 mov	 r12d, DWORD PTR ReadVolumeHeaderRecoveryMode
  00673	45 85 e4	 test	 r12d, r12d
  00676	75 55		 jne	 SHORT $LN33@ReadVolume
  00678	41 8d 44 24 04	 lea	 eax, QWORD PTR [r12+4]
  0067d	66 3b e8	 cmp	 bp, ax
  00680	72 4b		 jb	 SHORT $LN33@ReadVolume
  00682	48 8d 8c 24 80
	03 00 00	 lea	 rcx, QWORD PTR header$[rsp+64]
  0068a	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  0068f	e8 00 00 00 00	 call	 GetCrc32
  00694	8b bc 24 3c 04
	00 00		 mov	 edi, DWORD PTR header$[rsp+252]
  0069b	44 8b d8	 mov	 r11d, eax
  0069e	8b cf		 mov	 ecx, edi
  006a0	c1 e9 08	 shr	 ecx, 8
  006a3	0f b6 c1	 movzx	 eax, cl
  006a6	40 0f b6 cf	 movzx	 ecx, dil
  006aa	c1 e1 08	 shl	 ecx, 8
  006ad	0b c1		 or	 eax, ecx
  006af	8b cf		 mov	 ecx, edi
  006b1	c1 ef 18	 shr	 edi, 24
  006b4	c1 e0 08	 shl	 eax, 8
  006b7	c1 e9 10	 shr	 ecx, 16
  006ba	0f b6 d1	 movzx	 edx, cl
  006bd	0b c2		 or	 eax, edx
  006bf	c1 e0 08	 shl	 eax, 8
  006c2	0b c7		 or	 eax, edi
  006c4	41 3b c3	 cmp	 eax, r11d
  006c7	0f 85 ce 01 00
	00		 jne	 $LN212@ReadVolume
$LN33@ReadVolume:

; 422  : 					continue;
; 423  : 
; 424  : 				// Required program version
; 425  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, TC_HEADER_OFFSET_REQUIRED_VERSION);

  006cd	0f b7 8c 24 86
	03 00 00	 movzx	 ecx, WORD PTR header$[rsp+70]

; 426  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  006d5	33 c0		 xor	 eax, eax
  006d7	ba 00 06 00 00	 mov	 edx, 1536		; 00000600H
  006dc	66 c1 c1 08	 rol	 cx, 8
  006e0	66 3b ca	 cmp	 cx, dx
  006e3	66 89 8b 38 44
	00 00		 mov	 WORD PTR [rbx+17464], cx
  006ea	0f 92 c0	 setb	 al

; 427  : 
; 428  : 				// Check CRC of the key set
; 429  : 				if (!ReadVolumeHeaderRecoveryMode
; 430  : 					&& GetHeaderField32 (header, TC_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  006ed	45 85 e4	 test	 r12d, r12d
  006f0	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  006f6	89 83 3c 44 00
	00		 mov	 DWORD PTR [rbx+17468], eax
  006fc	75 49		 jne	 SHORT $LN32@ReadVolume
  006fe	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR header$[rsp+256]
  00706	41 8b d4	 mov	 edx, r12d
  00709	e8 00 00 00 00	 call	 GetCrc32
  0070e	8b bc 24 88 03
	00 00		 mov	 edi, DWORD PTR header$[rsp+72]
  00715	44 8b d8	 mov	 r11d, eax
  00718	8b cf		 mov	 ecx, edi
  0071a	c1 e9 08	 shr	 ecx, 8
  0071d	0f b6 c1	 movzx	 eax, cl
  00720	40 0f b6 cf	 movzx	 ecx, dil
  00724	c1 e1 08	 shl	 ecx, 8
  00727	0b c1		 or	 eax, ecx
  00729	8b cf		 mov	 ecx, edi
  0072b	c1 ef 18	 shr	 edi, 24
  0072e	c1 e0 08	 shl	 eax, 8
  00731	c1 e9 10	 shr	 ecx, 16
  00734	0f b6 d1	 movzx	 edx, cl
  00737	0b c2		 or	 eax, edx
  00739	c1 e0 08	 shl	 eax, 8
  0073c	0b c7		 or	 eax, edi
  0073e	41 3b c3	 cmp	 eax, r11d
  00741	0f 85 5a 01 00
	00		 jne	 $LN216@ReadVolume
$LN32@ReadVolume:

; 431  : 					continue;
; 432  : 
; 433  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 434  : 
; 435  : 				// Check the version required to handle this volume
; 436  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  00747	b8 30 07 00 00	 mov	 eax, 1840		; 00000730H
  0074c	66 39 83 38 44
	00 00		 cmp	 WORD PTR [rbx+17464], ax

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;
; 439  : 					goto err;

  00753	0f 87 4f 03 00
	00		 ja	 $LN190@ReadVolume

; 440  : 				}
; 441  : 
; 442  : 				// Header version
; 443  : 				cryptoInfo->HeaderVersion = headerVersion;

  00759	66 89 ab a4 29
	00 00		 mov	 WORD PTR [rbx+10660], bp

; 444  : 
; 445  : 				// Volume creation time (legacy)
; 446  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  00760	48 8b 8c 24 8c
	03 00 00	 mov	 rcx, QWORD PTR header$[rsp+76]
  00768	e8 00 00 00 00	 call	 MirrorBytes64
  0076d	48 89 83 f0 43
	00 00		 mov	 QWORD PTR [rbx+17392], rax

; 447  : 
; 448  : 				// Header creation time (legacy)
; 449  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, TC_HEADER_OFFSET_MODIFICATION_TIME).Value;

  00774	48 8b 8c 24 94
	03 00 00	 mov	 rcx, QWORD PTR header$[rsp+84]
  0077c	e8 00 00 00 00	 call	 MirrorBytes64
  00781	48 89 83 f8 43
	00 00		 mov	 QWORD PTR [rbx+17400], rax

; 450  : 
; 451  : 				// Hidden volume size (if any)
; 452  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  00788	48 8b 8c 24 9c
	03 00 00	 mov	 rcx, QWORD PTR header$[rsp+92]
  00790	e8 00 00 00 00	 call	 MirrorBytes64

; 453  : 
; 454  : 				// Hidden volume status
; 455  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  00795	33 c9		 xor	 ecx, ecx
  00797	48 85 c0	 test	 rax, rax
  0079a	48 89 83 10 44
	00 00		 mov	 QWORD PTR [rbx+17424], rax
  007a1	0f 95 c1	 setne	 cl
  007a4	89 8b a0 29 00
	00		 mov	 DWORD PTR [rbx+10656], ecx

; 456  : 
; 457  : 				// Volume size
; 458  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, TC_HEADER_OFFSET_VOLUME_SIZE);

  007aa	48 8b 8c 24 a4
	03 00 00	 mov	 rcx, QWORD PTR header$[rsp+100]
  007b2	e8 00 00 00 00	 call	 MirrorBytes64
  007b7	48 89 83 48 44
	00 00		 mov	 QWORD PTR [rbx+17480], rax

; 459  : 				
; 460  : 				// Encrypted area size and length
; 461  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_START);

  007be	48 8b 8c 24 ac
	03 00 00	 mov	 rcx, QWORD PTR header$[rsp+108]
  007c6	e8 00 00 00 00	 call	 MirrorBytes64
  007cb	48 89 83 50 44
	00 00		 mov	 QWORD PTR [rbx+17488], rax

; 462  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, TC_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  007d2	48 8b 8c 24 b4
	03 00 00	 mov	 rcx, QWORD PTR header$[rsp+116]
  007da	e8 00 00 00 00	 call	 MirrorBytes64
  007df	48 89 83 58 44
	00 00		 mov	 QWORD PTR [rbx+17496], rax

; 463  : 
; 464  : 				// Flags
; 465  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, TC_HEADER_OFFSET_FLAGS);

  007e6	8b bc 24 bc 03
	00 00		 mov	 edi, DWORD PTR header$[rsp+124]
  007ed	8b c7		 mov	 eax, edi
  007ef	c1 e8 08	 shr	 eax, 8
  007f2	0f b6 d0	 movzx	 edx, al
  007f5	40 0f b6 c7	 movzx	 eax, dil
  007f9	c1 e0 08	 shl	 eax, 8
  007fc	0b d0		 or	 edx, eax
  007fe	8b c7		 mov	 eax, edi
  00800	c1 ef 18	 shr	 edi, 24
  00803	c1 e2 08	 shl	 edx, 8
  00806	c1 e8 10	 shr	 eax, 16
  00809	0f b6 c8	 movzx	 ecx, al

; 466  : 
; 467  : 				// Sector size
; 468  : 				if (headerVersion >= 5)

  0080c	b8 05 00 00 00	 mov	 eax, 5
  00811	0b d1		 or	 edx, ecx
  00813	c1 e2 08	 shl	 edx, 8
  00816	0b d7		 or	 edx, edi
  00818	89 93 60 44 00
	00		 mov	 DWORD PTR [rbx+17504], edx
  0081e	66 3b e8	 cmp	 bp, ax
  00821	0f 82 17 01 00
	00		 jb	 $LN30@ReadVolume

; 469  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, TC_HEADER_OFFSET_SECTOR_SIZE);

  00827	8b bc 24 c0 03
	00 00		 mov	 edi, DWORD PTR header$[rsp+128]
  0082e	8b c7		 mov	 eax, edi
  00830	c1 e8 08	 shr	 eax, 8
  00833	0f b6 d0	 movzx	 edx, al
  00836	40 0f b6 c7	 movzx	 eax, dil
  0083a	c1 e0 08	 shl	 eax, 8
  0083d	0b d0		 or	 edx, eax
  0083f	8b c7		 mov	 eax, edi
  00841	c1 ef 18	 shr	 edi, 24
  00844	c1 e2 08	 shl	 edx, 8
  00847	c1 e8 10	 shr	 eax, 16
  0084a	0f b6 c8	 movzx	 ecx, al
  0084d	0b d1		 or	 edx, ecx
  0084f	c1 e2 08	 shl	 edx, 8
  00852	0b d7		 or	 edx, edi
  00854	89 93 40 44 00
	00		 mov	 DWORD PTR [rbx+17472], edx

; 470  : 				else

  0085a	e9 e9 00 00 00	 jmp	 $LN29@ReadVolume
$LN214@ReadVolume:

; 393  : 					else if (blockSize == 16)

  0085f	8b 6c 24 58	 mov	 ebp, DWORD PTR lrw128InitDone$1$[rsp]
$LN41@ReadVolume:

; 382  : 				{
; 383  : 					// Deprecated/legacy
; 384  : 
; 385  : 					if (!EAInitMode (cryptoInfo))

  00863	48 8b cb	 mov	 rcx, rbx
  00866	e8 00 00 00 00	 call	 EAInitMode
  0086b	85 c0		 test	 eax, eax
  0086d	0f 84 45 fd ff
	ff		 je	 $LN188@ReadVolume

; 386  : 					{
; 387  : 						status = ERR_MODE_INIT_FAILED;
; 388  : 						goto err;
; 389  : 					}
; 390  : 
; 391  : 					if (blockSize == 8)

  00873	83 ff 08	 cmp	 edi, 8
  00876	75 0c		 jne	 SHORT $LN38@ReadVolume

; 392  : 						lrw64InitDone = TRUE;

  00878	8d 6f f9	 lea	 ebp, QWORD PTR [rdi-7]
  0087b	89 6c 24 60	 mov	 DWORD PTR lrw64InitDone$1$[rsp], ebp
  0087f	e9 68 fd ff ff	 jmp	 $LN36@ReadVolume
$LN38@ReadVolume:

; 393  : 					else if (blockSize == 16)

  00884	b8 01 00 00 00	 mov	 eax, 1
  00889	83 ff 10	 cmp	 edi, 16
  0088c	0f 44 e8	 cmove	 ebp, eax
  0088f	89 6c 24 58	 mov	 DWORD PTR lrw128InitDone$1$[rsp], ebp
  00893	48 8b e8	 mov	 rbp, rax
  00896	e9 51 fd ff ff	 jmp	 $LN36@ReadVolume
$LN212@ReadVolume:

; 277  : 					{
; 278  : 						pkcs5_prf = item->Pkcs5Prf;

  0089b	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
$LN216@ReadVolume:

; 164  : {

  008a1	bd 01 00 00 00	 mov	 ebp, 1
$LN49@ReadVolume:

; 348  : 			}
; 349  : 
; 350  : 			// Test all available encryption algorithms
; 351  : 			for (cryptoInfo->ea = EAGetFirst ();
; 352  : 				cryptoInfo->ea != 0;
; 353  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  008a6	8b 13		 mov	 edx, DWORD PTR [rbx]
  008a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncryptionAlgorithms
  008af	03 d5		 add	 edx, ebp
  008b1	48 63 c2	 movsxd	 rax, edx
  008b4	48 6b c0 2c	 imul	 rax, 44			; 0000002cH
  008b8	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  008bb	f7 d8		 neg	 eax
  008bd	1b c9		 sbb	 ecx, ecx
  008bf	23 ca		 and	 ecx, edx
  008c1	89 0b		 mov	 DWORD PTR [rbx], ecx
  008c3	0f 85 67 fc ff
	ff		 jne	 $LL50@ReadVolume
  008c9	41 be 01 00 00
	00		 mov	 r14d, 1
  008cf	44 01 73 04	 add	 DWORD PTR [rbx+4], r14d
  008d3	41 8d 46 04	 lea	 eax, QWORD PTR [r14+4]
  008d7	39 43 04	 cmp	 DWORD PTR [rbx+4], eax
  008da	0f 8e 1a fc ff
	ff		 jle	 $LL57@ReadVolume
  008e0	45 8d 46 03	 lea	 r8d, QWORD PTR [r14+3]
$LN83@ReadVolume:

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  008e4	48 8b 6c 24 68	 mov	 rbp, QWORD PTR queuedWorkItems$1$[rsp]
  008e9	45 03 ee	 add	 r13d, r14d
  008ec	be 40 00 00 00	 mov	 esi, 64			; 00000040H
  008f1	e9 73 f8 ff ff	 jmp	 $LL84@ReadVolume
$LN82@ReadVolume:

; 541  : 			}
; 542  : 		}
; 543  : 	}
; 544  : 	status = ERR_PASSWORD_WRONG;

  008f6	be 03 00 00 00	 mov	 esi, 3
  008fb	e9 ad 01 00 00	 jmp	 $LN213@ReadVolume
$LN191@ReadVolume:

; 250  : 					{
; 251  : 						item->Free = FALSE;
; 252  : 						item->KeyReady = FALSE;
; 253  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 254  : 
; 255  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,
; 256  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 257  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);

  00900	45 33 c9	 xor	 r9d, r9d
  00903	45 33 c0	 xor	 r8d, r8d
  00906	ba 62 01 00 00	 mov	 edx, 354		; 00000162H
  0090b	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0090f	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0091e	cc		 int	 3
$LN207@ReadVolume:

; 321  : 
; 322  : 			default:		
; 323  : 				// Unknown/wrong ID
; 324  : 				TC_THROW_FATAL_EXCEPTION;

  0091f	45 33 c9	 xor	 r9d, r9d
  00922	45 33 c0	 xor	 r8d, r8d
  00925	ba 44 01 00 00	 mov	 edx, 324		; 00000144H
  0092a	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0092e	48 c7 44 24 20
	43 54 00 00	 mov	 QWORD PTR [rsp+32], 21571 ; 00005443H
  00937	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0093d	cc		 int	 3
$LN30@ReadVolume:

; 471  : 					cryptoInfo->SectorSize = TC_SECTOR_SIZE_LEGACY;

  0093e	c7 83 40 44 00
	00 00 02 00 00	 mov	 DWORD PTR [rbx+17472], 512 ; 00000200H
$LN29@ReadVolume:

; 472  : 
; 473  : 				if (cryptoInfo->SectorSize < TC_MIN_VOLUME_SECTOR_SIZE
; 474  : 					|| cryptoInfo->SectorSize > TC_MAX_VOLUME_SECTOR_SIZE
; 475  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00948	8b 83 40 44 00
	00		 mov	 eax, DWORD PTR [rbx+17472]
  0094e	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00953	0f 82 48 01 00
	00		 jb	 $LN27@ReadVolume
  00959	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0095e	0f 87 3d 01 00
	00		 ja	 $LN27@ReadVolume
  00964	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  00969	0f 85 32 01 00
	00		 jne	 $LN27@ReadVolume

; 478  : 					goto err;
; 479  : 				}
; 480  : 
; 481  : 				// Preserve scheduled header keys if requested			
; 482  : 				if (retHeaderCryptoInfo)

  0096f	48 8b 6c 24 48	 mov	 rbp, QWORD PTR retHeaderCryptoInfo$GSCopy$1$[rsp]

; 483  : 				{
; 484  : 					if (retInfo == NULL)

  00974	4c 8b 6c 24 40	 mov	 r13, QWORD PTR retInfo$GSCopy$1$[rsp]
  00979	48 85 ed	 test	 rbp, rbp
  0097c	74 4b		 je	 SHORT $LN26@ReadVolume
  0097e	4d 85 ed	 test	 r13, r13
  00981	75 1c		 jne	 SHORT $LN25@ReadVolume

; 485  : 					{
; 486  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  00983	8b 44 24 50	 mov	 eax, DWORD PTR pkcs5_prf$1$[rsp]
  00987	89 83 ec 43 00
	00		 mov	 DWORD PTR [rbx+17388], eax

; 487  : 						cryptoInfo->noIterations = keyInfo.noIterations;

  0098d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00994	89 83 e8 43 00
	00		 mov	 DWORD PTR [rbx+17384], eax

; 488  : 						goto ret;

  0099a	e9 2a 01 00 00	 jmp	 $ret$29786
$LN25@ReadVolume:

; 489  : 					}
; 490  : 
; 491  : 					cryptoInfo = *retInfo = crypto_open ();

  0099f	e8 00 00 00 00	 call	 crypto_open
  009a4	48 8b d8	 mov	 rbx, rax
  009a7	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 492  : 					if (cryptoInfo == NULL)

  009ab	48 85 c0	 test	 rax, rax
  009ae	75 08		 jne	 SHORT $LN24@ReadVolume

; 493  : 					{
; 494  : 						status = ERR_OUTOFMEMORY;

  009b0	8d 70 02	 lea	 esi, QWORD PTR [rax+2]

; 495  : 						goto err;

  009b3	e9 ff 00 00 00	 jmp	 $err$29763
$LN24@ReadVolume:

; 496  : 					}
; 497  : 
; 498  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  009b8	41 b8 68 44 00
	00		 mov	 r8d, 17512		; 00004468H
  009be	48 8b d5	 mov	 rdx, rbp
  009c1	48 8b c8	 mov	 rcx, rax
  009c4	e8 00 00 00 00	 call	 memcpy
$LN26@ReadVolume:

; 499  : 				}
; 500  : 
; 501  : 				// Master key data
; 502  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);

  009c9	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR keyInfo$[rsp+136]
  009d1	48 8d 94 24 40
	04 00 00	 lea	 rdx, QWORD PTR header$[rsp+256]
  009d9	4d 8b c4	 mov	 r8, r12
  009dc	e8 00 00 00 00	 call	 memcpy

; 503  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  009e1	48 8d 8b a8 41
	00 00		 lea	 rcx, QWORD PTR [rbx+16808]
  009e8	48 8d 94 24 38
	01 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+136]
  009f0	4d 8b c4	 mov	 r8, r12
  009f3	e8 00 00 00 00	 call	 memcpy

; 504  : 
; 505  : 				// PKCS #5
; 506  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);

  009f8	48 8d 8b a8 43
	00 00		 lea	 rcx, QWORD PTR [rbx+17320]
  009ff	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+72]
  00a07	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00a0d	e8 00 00 00 00	 call	 memcpy

; 507  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  00a12	8b 44 24 50	 mov	 eax, DWORD PTR pkcs5_prf$1$[rsp]

; 508  : 				cryptoInfo->noIterations = keyInfo.noIterations;
; 509  : 
; 510  : 				// Init the cipher with the decrypted master key
; 511  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  00a16	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00a18	89 83 ec 43 00
	00		 mov	 DWORD PTR [rbx+17388], eax
  00a1e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR keyInfo$[rsp]
  00a25	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  00a29	89 83 e8 43 00
	00		 mov	 DWORD PTR [rbx+17384], eax
  00a2f	49 63 c6	 movsxd	 rax, r14d
  00a32	48 8d 94 04 38
	01 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+rax+136]
  00a3a	e8 00 00 00 00	 call	 EAInit
  00a3f	8b f0		 mov	 esi, eax

; 512  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00a41	83 f8 11	 cmp	 eax, 17
  00a44	74 71		 je	 SHORT $err$29763

; 513  : 					goto err;
; 514  : 
; 515  : 				switch (cryptoInfo->mode)

  00a46	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  00a49	83 c0 fe	 add	 eax, -2			; fffffffeH
  00a4c	83 f8 03	 cmp	 eax, 3
  00a4f	77 10		 ja	 SHORT $LN19@ReadVolume

; 516  : 				{
; 517  : 				case LRW:
; 518  : 				case CBC:
; 519  : 				case INNER_CBC:
; 520  : 				case OUTER_CBC:
; 521  : 
; 522  : 					// For LRW (deprecated/legacy), the tweak key
; 523  : 					// For CBC (deprecated/legacy), the IV/whitening seed
; 524  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata, LEGACY_VOL_IV_SIZE);

  00a51	48 8d 94 24 38
	01 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+136]
  00a59	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H

; 525  : 					break;

  00a5f	eb 1f		 jmp	 SHORT $LN219@ReadVolume
$LN19@ReadVolume:

; 526  : 
; 527  : 				default:
; 528  : 					// The secondary master key (if cascade, multiple concatenated)
; 529  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00a61	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00a63	e8 00 00 00 00	 call	 EAGetKeySize
  00a68	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00a6a	48 63 f8	 movsxd	 rdi, eax
  00a6d	e8 00 00 00 00	 call	 EAGetKeySize
  00a72	4c 8b c7	 mov	 r8, rdi
  00a75	48 63 c8	 movsxd	 rcx, eax
  00a78	48 8d 94 0c 38
	01 00 00	 lea	 rdx, QWORD PTR keyInfo$[rsp+rcx+136]
$LN219@ReadVolume:
  00a80	48 8d 8b a8 42
	00 00		 lea	 rcx, QWORD PTR [rbx+17064]
  00a87	e8 00 00 00 00	 call	 memcpy

; 530  : 
; 531  : 				}
; 532  : 
; 533  : 				if (!EAInitMode (cryptoInfo))

  00a8c	48 8b cb	 mov	 rcx, rbx
  00a8f	e8 00 00 00 00	 call	 EAInitMode
  00a94	85 c0		 test	 eax, eax
  00a96	75 05		 jne	 SHORT $LN18@ReadVolume

; 534  : 				{
; 535  : 					status = ERR_MODE_INIT_FAILED;

  00a98	8d 70 1b	 lea	 esi, QWORD PTR [rax+27]

; 536  : 					goto err;

  00a9b	eb 1a		 jmp	 SHORT $err$29763
$LN18@ReadVolume:

; 537  : 				}
; 538  : 
; 539  : 				status = ERR_SUCCESS;

  00a9d	33 f6		 xor	 esi, esi

; 540  : 				goto ret;

  00a9f	eb 28		 jmp	 SHORT $ret$29786
$LN27@ReadVolume:

; 476  : 				{
; 477  : 					status = ERR_PARAMETER_INCORRECT;

  00aa1	be 1e 00 00 00	 mov	 esi, 30
  00aa6	eb 05		 jmp	 SHORT $LN213@ReadVolume
$LN190@ReadVolume:

; 413  : 				{
; 414  : 					status = ERR_NEW_VERSION_REQUIRED;

  00aa8	be 10 00 00 00	 mov	 esi, 16
$LN213@ReadVolume:

; 234  : 
; 235  : 	// Test all available PKCS5 PRFs
; 236  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  00aad	48 8b 6c 24 48	 mov	 rbp, QWORD PTR retHeaderCryptoInfo$GSCopy$1$[rsp]
  00ab2	4c 8b 6c 24 40	 mov	 r13, QWORD PTR retInfo$GSCopy$1$[rsp]
$err$29763:

; 545  : 
; 546  : err:
; 547  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00ab7	48 3b dd	 cmp	 rbx, rbp
  00aba	74 0d		 je	 SHORT $ret$29786

; 548  : 	{
; 549  : 		crypto_close(cryptoInfo);

  00abc	48 8b cb	 mov	 rcx, rbx
  00abf	e8 00 00 00 00	 call	 crypto_close

; 550  : 		*retInfo = NULL; 

  00ac4	49 83 65 00 00	 and	 QWORD PTR [r13], 0
$ret$29786:

; 551  : 	}
; 552  : 
; 553  : ret:
; 554  : 	burn (&keyInfo, sizeof (keyInfo));

  00ac9	33 c0		 xor	 eax, eax
  00acb	ba 88 01 00 00	 mov	 edx, 392		; 00000188H
  00ad0	48 8d bc 24 b0
	00 00 00	 lea	 rdi, QWORD PTR keyInfo$[rsp]
  00ad8	48 8b ca	 mov	 rcx, rdx
  00adb	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR keyInfo$[rsp]
  00ae3	8d 58 01	 lea	 ebx, QWORD PTR [rax+1]
  00ae6	f3 aa		 rep stosb
$LL13@ReadVolume:
  00ae8	41 88 00	 mov	 BYTE PTR [r8], al
  00aeb	4c 03 c3	 add	 r8, rbx
  00aee	2b d3		 sub	 edx, ebx
  00af0	75 f6		 jne	 SHORT $LL13@ReadVolume

; 555  : 	burn (dk, sizeof(dk));

  00af2	48 8d bc 24 40
	02 00 00	 lea	 rdi, QWORD PTR dk$[rsp]
  00afa	49 8b cc	 mov	 rcx, r12
  00afd	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR dk$[rsp]
  00b05	f3 aa		 rep stosb
$LL8@ReadVolume:
  00b07	88 02		 mov	 BYTE PTR [rdx], al
  00b09	48 03 d3	 add	 rdx, rbx
  00b0c	44 2b e3	 sub	 r12d, ebx
  00b0f	75 f6		 jne	 SHORT $LL8@ReadVolume

; 556  : 
; 557  : #ifndef DEVICE_DRIVER
; 558  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));
; 559  : 	VirtualUnlock (&dk, sizeof (dk));
; 560  : #endif
; 561  : 
; 562  : 	if (encryptionThreadCount > 1)

  00b11	48 39 5c 24 78	 cmp	 QWORD PTR encryptionThreadCount$1$[rsp], rbx
  00b16	76 45		 jbe	 SHORT $LN6@ReadVolume

; 563  : 	{
; 564  : 		TC_WAIT_EVENT (noOutstandingWorkItemEvent);

  00b18	48 21 44 24 20	 and	 QWORD PTR [rsp+32], rax
  00b1d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR noOutstandingWorkItemEvent$[rsp]
  00b25	45 33 c9	 xor	 r9d, r9d
  00b28	45 33 c0	 xor	 r8d, r8d
  00b2b	33 d2		 xor	 edx, edx
  00b2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 565  : 
; 566  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00b33	ba 30 04 00 00	 mov	 edx, 1072		; 00000430H
  00b38	49 8b ff	 mov	 rdi, r15
  00b3b	33 c0		 xor	 eax, eax
  00b3d	48 8b ca	 mov	 rcx, rdx
  00b40	4d 8b df	 mov	 r11, r15
  00b43	f3 aa		 rep stosb
$LL2@ReadVolume:
  00b45	41 88 03	 mov	 BYTE PTR [r11], al
  00b48	4c 03 db	 add	 r11, rbx
  00b4b	2b d3		 sub	 edx, ebx
  00b4d	75 f6		 jne	 SHORT $LL2@ReadVolume

; 567  : 		TCfree (keyDerivationWorkItems);

  00b4f	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00b54	49 8b cf	 mov	 rcx, r15
  00b57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN6@ReadVolume:

; 568  : 
; 569  : #ifndef DEVICE_DRIVER
; 570  : 		CloseHandle (keyDerivationCompletedEvent);
; 571  : 		CloseHandle (noOutstandingWorkItemEvent);
; 572  : #endif
; 573  : 	}
; 574  : 
; 575  : 	return status;

  00b5d	8b c6		 mov	 eax, esi
$LN93@ReadVolume:

; 576  : }

  00b5f	48 8b 8c 24 40
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b67	48 33 cc	 xor	 rcx, rsp
  00b6a	e8 00 00 00 00	 call	 __security_check_cookie
  00b6f	48 81 c4 58 05
	00 00		 add	 rsp, 1368		; 00000558H
  00b76	41 5f		 pop	 r15
  00b78	41 5e		 pop	 r14
  00b7a	41 5d		 pop	 r13
  00b7c	41 5c		 pop	 r12
  00b7e	5f		 pop	 rdi
  00b7f	5e		 pop	 rsi
  00b80	5d		 pop	 rbp
  00b81	5b		 pop	 rbx
  00b82	c3		 ret	 0
$LN218@ReadVolume:
ReadVolumeHeader ENDP
END
