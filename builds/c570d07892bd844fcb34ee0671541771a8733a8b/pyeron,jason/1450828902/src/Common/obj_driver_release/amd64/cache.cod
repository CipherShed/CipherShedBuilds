; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	cacheEmpty
COMM	CachedPasswords:BYTE:0120H
nPasswordIdx DD	01H DUP (?)
cacheEmpty DD	01H
PUBLIC	AddPasswordToCache
EXTRN	memcmp:PROC
;	COMDAT pdata
; File c:\users\public\desktop\projects\ciphershed\src\common\cache.c
pdata	SEGMENT
$pdata$AddPasswordToCache DD imagerel $LN10
	DD	imagerel $LN10+137
	DD	imagerel $unwind$AddPasswordToCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddPasswordToCache DD 060f01H
	DD	07540fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT AddPasswordToCache
_TEXT	SEGMENT
password$ = 48
AddPasswordToCache PROC					; COMDAT

; 75   : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 76   : 	int i;
; 77   : 	for (i = 0; i < CACHE_SIZE; i++)

  00012	33 db		 xor	 ebx, ebx
  00014	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:CachedPasswords
$LL4@AddPasswor:

; 78   : 	{
; 79   : 		if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  0001b	48 63 c3	 movsxd	 rax, ebx
  0001e	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00024	48 8d 14 c0	 lea	 rdx, QWORD PTR [rax+rax*8]
  00028	48 8d 4c d5 00	 lea	 rcx, QWORD PTR [rbp+rdx*8]
  0002d	48 8b d7	 mov	 rdx, rdi
  00030	e8 00 00 00 00	 call	 memcmp
  00035	85 c0		 test	 eax, eax
  00037	74 40		 je	 SHORT $LN5@AddPasswor
  00039	ff c3		 inc	 ebx
  0003b	83 fb 04	 cmp	 ebx, 4
  0003e	7c db		 jl	 SHORT $LL4@AddPasswor

; 80   : 			return;
; 81   : 	}
; 82   : 
; 83   : 	CachedPasswords[nPasswordIdx] = *password;

  00040	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR nPasswordIdx
  00047	48 8b d7	 mov	 rdx, rdi
  0004a	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00050	48 8d 0c db	 lea	 rcx, QWORD PTR [rbx+rbx*8]
  00054	48 8d 4c cd 00	 lea	 rcx, QWORD PTR [rbp+rcx*8]
  00059	e8 00 00 00 00	 call	 memcpy

; 84   : 	nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  0005e	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  00061	99		 cdq
  00062	83 e2 03	 and	 edx, 3
  00065	03 c2		 add	 eax, edx
  00067	83 e0 03	 and	 eax, 3
  0006a	2b c2		 sub	 eax, edx

; 85   : 	cacheEmpty = 0;

  0006c	83 25 00 00 00
	00 00		 and	 DWORD PTR cacheEmpty, 0
  00073	89 05 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, eax
$LN5@AddPasswor:

; 86   : }

  00079	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
AddPasswordToCache ENDP
PUBLIC	WipeCache
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$WipeCache DD imagerel $LN13
	DD	imagerel $LN13+61
	DD	imagerel $unwind$WipeCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WipeCache DD 020501H
	DD	017405H
; Function compile flags: /Ogspy
; File c:\users\public\desktop\projects\ciphershed\src\common\cache.c
xdata	ENDS
;	COMDAT WipeCache
_TEXT	SEGMENT
WipeCache PROC						; COMDAT

; 90   : {

$LN13:
  00000	48 89 7c 24 08	 mov	 QWORD PTR [rsp+8], rdi

; 91   : 	burn (CachedPasswords, sizeof (CachedPasswords));

  00005	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CachedPasswords
  0000c	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  00012	33 c0		 xor	 eax, eax
  00014	48 8b fa	 mov	 rdi, rdx
  00017	49 8b c8	 mov	 rcx, r8
  0001a	f3 aa		 rep stosb
$LL2@WipeCache:
  0001c	88 02		 mov	 BYTE PTR [rdx], al
  0001e	48 ff c2	 inc	 rdx
  00021	41 83 e8 01	 sub	 r8d, 1
  00025	75 f5		 jne	 SHORT $LL2@WipeCache

; 92   : 	nPasswordIdx = 0;

  00027	21 05 00 00 00
	00		 and	 DWORD PTR nPasswordIdx, eax

; 93   : 	cacheEmpty = 1;
; 94   : }

  0002d	48 8b 7c 24 08	 mov	 rdi, QWORD PTR [rsp+8]
  00032	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR cacheEmpty, 1
  0003c	c3		 ret	 0
WipeCache ENDP
PUBLIC	ReadVolumeHeaderWCache
;	COMDAT pdata
pdata	SEGMENT
$pdata$ReadVolumeHeaderWCache DD imagerel $LN25
	DD	imagerel $LN25+313
	DD	imagerel $unwind$ReadVolumeHeaderWCache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ReadVolumeHeaderWCache DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ReadVolumeHeaderWCache
_TEXT	SEGMENT
bBoot$ = 80
bCache$ = 88
header$ = 96
password$ = 104
retInfo$ = 112
ReadVolumeHeaderWCache PROC				; COMDAT

; 25   : {

$LN25:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 26   : 	int nReturnCode = ERR_PASSWORD_WRONG;
; 27   : 	int i;
; 28   : 
; 29   : 	/* Attempt to recognize volume using mount password */
; 30   : 	if (password->Length > 0)

  00018	41 83 39 00	 cmp	 DWORD PTR [r9], 0
  0001c	49 8b f1	 mov	 rsi, r9
  0001f	4d 8b e0	 mov	 r12, r8
  00022	8b da		 mov	 ebx, edx
  00024	44 8b e9	 mov	 r13d, ecx
  00027	bf 03 00 00 00	 mov	 edi, 3
  0002c	0f 86 9e 00 00
	00		 jbe	 $LN15@ReadVolume@2

; 31   : 	{
; 32   : 		nReturnCode = ReadVolumeHeader (bBoot, header, password, retInfo, NULL);

  00032	4c 8b 4c 24 70	 mov	 r9, QWORD PTR retInfo$[rsp]
  00037	48 83 60 d8 00	 and	 QWORD PTR [rax-40], 0
  0003c	4c 8b c6	 mov	 r8, rsi
  0003f	49 8b d4	 mov	 rdx, r12
  00042	e8 00 00 00 00	 call	 ReadVolumeHeader
  00047	8b f8		 mov	 edi, eax

; 33   : 
; 34   : 		/* Save mount passwords back into cache if asked to do so */
; 35   : 		if (bCache && (nReturnCode == 0 || nReturnCode == ERR_CIPHER_INIT_WEAK_KEY))

  00049	85 db		 test	 ebx, ebx
  0004b	0f 84 cd 00 00
	00		 je	 $LN21@ReadVolume@2
  00051	85 c0		 test	 eax, eax
  00053	74 09		 je	 SHORT $LN13@ReadVolume@2
  00055	83 f8 12	 cmp	 eax, 18
  00058	0f 85 c0 00 00
	00		 jne	 $LN21@ReadVolume@2
$LN13@ReadVolume@2:

; 36   : 		{
; 37   : 			for (i = 0; i < CACHE_SIZE; i++)

  0005e	33 db		 xor	 ebx, ebx
  00060	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:CachedPasswords
$LL12@ReadVolume@2:

; 38   : 			{
; 39   : 				if (memcmp (&CachedPasswords[i], password, sizeof (Password)) == 0)

  00067	48 63 c3	 movsxd	 rax, ebx
  0006a	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00070	48 8b d6	 mov	 rdx, rsi
  00073	48 8d 0c c0	 lea	 rcx, QWORD PTR [rax+rax*8]
  00077	48 8d 4c cd 00	 lea	 rcx, QWORD PTR [rbp+rcx*8]
  0007c	e8 00 00 00 00	 call	 memcmp
  00081	85 c0		 test	 eax, eax
  00083	74 07		 je	 SHORT $LN20@ReadVolume@2
  00085	ff c3		 inc	 ebx
  00087	83 fb 04	 cmp	 ebx, 4
  0008a	7c db		 jl	 SHORT $LL12@ReadVolume@2
$LN20@ReadVolume@2:

; 40   : 					break;
; 41   : 			}
; 42   : 
; 43   : 			if (i == CACHE_SIZE)

  0008c	83 fb 04	 cmp	 ebx, 4
  0008f	0f 85 89 00 00
	00		 jne	 $LN21@ReadVolume@2

; 44   : 			{
; 45   : 				/* Store the password */
; 46   : 				CachedPasswords[nPasswordIdx] = *password;

  00095	48 63 1d 00 00
	00 00		 movsxd	 rbx, DWORD PTR nPasswordIdx
  0009c	48 8b d6	 mov	 rdx, rsi
  0009f	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  000a5	48 8d 0c db	 lea	 rcx, QWORD PTR [rbx+rbx*8]
  000a9	48 8d 4c cd 00	 lea	 rcx, QWORD PTR [rbp+rcx*8]
  000ae	e8 00 00 00 00	 call	 memcpy

; 47   : 
; 48   : 				/* Try another slot */
; 49   : 				nPasswordIdx = (nPasswordIdx + 1) % CACHE_SIZE;

  000b3	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  000b6	99		 cdq
  000b7	83 e2 03	 and	 edx, 3
  000ba	03 c2		 add	 eax, edx
  000bc	83 e0 03	 and	 eax, 3
  000bf	2b c2		 sub	 eax, edx

; 50   : 
; 51   : 				cacheEmpty = 0;

  000c1	83 25 00 00 00
	00 00		 and	 DWORD PTR cacheEmpty, 0
  000c8	89 05 00 00 00
	00		 mov	 DWORD PTR nPasswordIdx, eax

; 52   : 			}
; 53   : 		}

  000ce	eb 4e		 jmp	 SHORT $LN21@ReadVolume@2
$LN15@ReadVolume@2:

; 54   : 	}
; 55   : 	else if (!cacheEmpty)

  000d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cacheEmpty, 0
  000d7	75 45		 jne	 SHORT $LN21@ReadVolume@2

; 56   : 	{
; 57   : 		/* Attempt to recognize volume using cached passwords */
; 58   : 		for (i = 0; i < CACHE_SIZE; i++)

  000d9	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:CachedPasswords
  000e0	33 db		 xor	 ebx, ebx
  000e2	48 8b f5	 mov	 rsi, rbp
$LL5@ReadVolume@2:

; 59   : 		{
; 60   : 			if (CachedPasswords[i].Length > 0)

  000e5	83 3e 00	 cmp	 DWORD PTR [rsi], 0
  000e8	76 29		 jbe	 SHORT $LN4@ReadVolume@2

; 61   : 			{
; 62   : 				nReturnCode = ReadVolumeHeader (bBoot, header, &CachedPasswords[i], retInfo, NULL);

  000ea	4c 8b 4c 24 70	 mov	 r9, QWORD PTR retInfo$[rsp]
  000ef	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000f5	48 63 c3	 movsxd	 rax, ebx
  000f8	48 8d 0c c0	 lea	 rcx, QWORD PTR [rax+rax*8]
  000fc	49 8b d4	 mov	 rdx, r12
  000ff	4c 8d 44 cd 00	 lea	 r8, QWORD PTR [rbp+rcx*8]
  00104	41 8b cd	 mov	 ecx, r13d
  00107	e8 00 00 00 00	 call	 ReadVolumeHeader
  0010c	8b f8		 mov	 edi, eax

; 63   : 
; 64   : 				if (nReturnCode != ERR_PASSWORD_WRONG)

  0010e	83 f8 03	 cmp	 eax, 3
  00111	75 0b		 jne	 SHORT $LN21@ReadVolume@2
$LN4@ReadVolume@2:

; 56   : 	{
; 57   : 		/* Attempt to recognize volume using cached passwords */
; 58   : 		for (i = 0; i < CACHE_SIZE; i++)

  00113	ff c3		 inc	 ebx
  00115	48 83 c6 48	 add	 rsi, 72			; 00000048H
  00119	83 fb 04	 cmp	 ebx, 4
  0011c	7c c7		 jl	 SHORT $LL5@ReadVolume@2
$LN21@ReadVolume@2:

; 65   : 					break;
; 66   : 			}
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	return nReturnCode;
; 71   : }

  0011e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00123	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00128	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0012d	8b c7		 mov	 eax, edi
  0012f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00133	41 5d		 pop	 r13
  00135	41 5c		 pop	 r12
  00137	5f		 pop	 rdi
  00138	c3		 ret	 0
ReadVolumeHeaderWCache ENDP
END
