; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\fsutil\fsutil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_ResolveSymbolicLink
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	_hDriver:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\fsutil\fsutil.cpp
;	COMDAT _ResolveSymbolicLink
_TEXT	SEGMENT
_dwResult$ = -1048					; size = 4
_resolve$ = -1044					; size = 1040
__$ArrayPad$ = -4					; size = 4
_symLinkName$ = 8					; size = 4
_targetName$ = 12					; size = 4
_ResolveSymbolicLink PROC				; COMDAT

; 8    : {

  00000	81 ec 18 04 00
	00		 sub	 esp, 1048		; 00000418H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 14 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1048], eax
  00014	56		 push	 esi
  00015	8b b4 24 24 04
	00 00		 mov	 esi, DWORD PTR _targetName$[esp+1048]

; 9    : 	BOOL bResult;
; 10   : 	DWORD dwResult;
; 11   : 	RESOLVE_SYMLINK_STRUCT resolve;
; 12   : 
; 13   : 	memset (&resolve, 0, sizeof(resolve));

  0001c	68 10 04 00 00	 push	 1040			; 00000410H
  00021	8d 44 24 0c	 lea	 eax, DWORD PTR _resolve$[esp+1056]
  00025	6a 00		 push	 0
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _memset

; 14   : 	wcscpy ((PWSTR) &resolve.symLinkName, symLinkName);

  0002d	8b 84 24 2c 04
	00 00		 mov	 eax, DWORD PTR _symLinkName$[esp+1060]
  00034	8d 54 24 14	 lea	 edx, DWORD PTR _resolve$[esp+1064]
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	2b d0		 sub	 edx, eax
  0003d	8d 49 00	 npad	 3
$LL3@ResolveSym:
  00040	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00043	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  00047	83 c0 02	 add	 eax, 2
  0004a	66 85 c9	 test	 cx, cx
  0004d	75 f1		 jne	 SHORT $LL3@ResolveSym

; 15   : 
; 16   : 	bResult = DeviceIoControl (hDriver, TC_IOCTL_GET_RESOLVED_SYMLINK, &resolve,
; 17   : 		sizeof (resolve), &resolve, sizeof (resolve), &dwResult,
; 18   : 		NULL);

  0004f	6a 00		 push	 0
  00051	8d 4c 24 08	 lea	 ecx, DWORD PTR _dwResult$[esp+1056]
  00055	51		 push	 ecx
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hDriver
  0005c	68 10 04 00 00	 push	 1040			; 00000410H
  00061	8d 54 24 14	 lea	 edx, DWORD PTR _resolve$[esp+1064]
  00065	52		 push	 edx
  00066	68 10 04 00 00	 push	 1040			; 00000410H
  0006b	8b c2		 mov	 eax, edx
  0006d	50		 push	 eax
  0006e	68 44 20 22 00	 push	 2236484			; 00222044H
  00073	51		 push	 ecx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 19   : 
; 20   : 	wcscpy (targetName, (PWSTR) &resolve.targetName);

  0007a	8d 8c 24 10 02
	00 00		 lea	 ecx, DWORD PTR _resolve$[esp+1572]
  00081	8b d1		 mov	 edx, ecx
  00083	2b f2		 sub	 esi, edx
$LL4@ResolveSym:
  00085	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00088	66 89 14 0e	 mov	 WORD PTR [esi+ecx], dx
  0008c	83 c1 02	 add	 ecx, 2
  0008f	66 85 d2	 test	 dx, dx
  00092	75 f1		 jne	 SHORT $LL4@ResolveSym

; 21   : 
; 22   : 	return bResult;
; 23   : }

  00094	8b 8c 24 18 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1052]
  0009b	5e		 pop	 esi
  0009c	33 cc		 xor	 ecx, esp
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	81 c4 18 04 00
	00		 add	 esp, 1048		; 00000418H
  000a9	c3		 ret	 0
_ResolveSymbolicLink ENDP
_TEXT	ENDS
PUBLIC	__real@42b00000
PUBLIC	__real@4058ff5c28f5c28f
PUBLIC	__real@00000000
PUBLIC	_FileSystemAppearsEmpty
EXTRN	_GetStatsFreeSpaceOnPartition:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@42b00000
CONST	SEGMENT
__real@42b00000 DD 042b00000r			; 88
CONST	ENDS
;	COMDAT __real@4058ff5c28f5c28f
CONST	SEGMENT
__real@4058ff5c28f5c28f DQ 04058ff5c28f5c28fr	; 99.99
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _FileSystemAppearsEmpty
_TEXT	SEGMENT
_percentFreeSpace$ = -12				; size = 4
_occupiedBytes$ = -8					; size = 8
_devicePath$ = 8					; size = 4
_FileSystemAppearsEmpty PROC				; COMDAT

; 28   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 29   : 	float percentFreeSpace = 0.0;
; 30   : 	__int64 occupiedBytes = 0;
; 31   : 
; 32   : 	if (GetStatsFreeSpaceOnPartition (devicePath, &percentFreeSpace, &occupiedBytes, TRUE) != -1)

  00003	8b 54 24 10	 mov	 edx, DWORD PTR _devicePath$[esp+8]
  00007	d9 ee		 fldz
  00009	6a 01		 push	 1
  0000b	d9 5c 24 04	 fstp	 DWORD PTR _percentFreeSpace$[esp+16]
  0000f	8d 44 24 08	 lea	 eax, DWORD PTR _occupiedBytes$[esp+16]
  00013	50		 push	 eax
  00014	8d 4c 24 08	 lea	 ecx, DWORD PTR _percentFreeSpace$[esp+20]
  00018	51		 push	 ecx
  00019	52		 push	 edx
  0001a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _occupiedBytes$[esp+28], 0
  00022	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _occupiedBytes$[esp+32], 0
  0002a	e8 00 00 00 00	 call	 _GetStatsFreeSpaceOnPartition
  0002f	23 c2		 and	 eax, edx
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	83 f8 ff	 cmp	 eax, -1
  00037	74 41		 je	 SHORT $LN6@FileSystem

; 33   : 	{
; 34   : 		if (occupiedBytes > BYTES_PER_GB && percentFreeSpace < 99.99	// "percentFreeSpace < 99.99" is needed because an NTFS filesystem larger than several terabytes can have more than 1GB of data in use, even if there are no files stored on it.
; 35   : 			|| percentFreeSpace < 88)		// A 24-MB NTFS filesystem has 11.5% of space in use even if there are no files stored on it.

  00039	83 7c 24 08 00	 cmp	 DWORD PTR _occupiedBytes$[esp+16], 0
  0003e	d9 04 24	 fld	 DWORD PTR _percentFreeSpace$[esp+12]
  00041	7c 19		 jl	 SHORT $LN3@FileSystem
  00043	7f 0a		 jg	 SHORT $LN9@FileSystem
  00045	81 7c 24 04 00
	00 00 40	 cmp	 DWORD PTR _occupiedBytes$[esp+12], 1073741824 ; 40000000H
  0004d	76 0d		 jbe	 SHORT $LN3@FileSystem
$LN9@FileSystem:
  0004f	dc 15 00 00 00
	00		 fcom	 QWORD PTR __real@4058ff5c28f5c28f
  00055	df e0		 fnstsw	 ax
  00057	f6 c4 05	 test	 ah, 5
  0005a	7b 16		 jnp	 SHORT $LN16@FileSystem
$LN3@FileSystem:
  0005c	d8 1d 00 00 00
	00		 fcomp	 DWORD PTR __real@42b00000
  00062	df e0		 fnstsw	 ax
  00064	f6 c4 05	 test	 ah, 5
  00067	7b 0b		 jnp	 SHORT $LN4@FileSystem

; 38   : 		}
; 39   : 		else
; 40   : 			return 1;

  00069	b8 01 00 00 00	 mov	 eax, 1

; 44   : }

  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	c3		 ret	 0
$LN16@FileSystem:

; 33   : 	{
; 34   : 		if (occupiedBytes > BYTES_PER_GB && percentFreeSpace < 99.99	// "percentFreeSpace < 99.99" is needed because an NTFS filesystem larger than several terabytes can have more than 1GB of data in use, even if there are no files stored on it.
; 35   : 			|| percentFreeSpace < 88)		// A 24-MB NTFS filesystem has 11.5% of space in use even if there are no files stored on it.

  00072	dd d8		 fstp	 ST(0)
$LN4@FileSystem:

; 36   : 		{
; 37   : 			return 0;

  00074	33 c0		 xor	 eax, eax

; 44   : }

  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	c3		 ret	 0
$LN6@FileSystem:

; 41   : 	}
; 42   : 	else
; 43   : 		return -1;

  0007a	83 c8 ff	 or	 eax, -1

; 44   : }

  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	c3		 ret	 0
_FileSystemAppearsEmpty ENDP
_TEXT	ENDS
END
