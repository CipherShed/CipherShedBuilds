; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Public\Desktop\projects\ciphershed\src\Common\GfMul.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_gft_le	DW	00H
	DW	0c201H
	DW	08403H
	DW	04602H
	DW	0807H
	DW	0ca06H
	DW	08c04H
	DW	04e05H
	DW	0100eH
	DW	0d20fH
	DW	0940dH
	DW	0560cH
	DW	01809H
	DW	0da08H
	DW	09c0aH
	DW	05e0bH
	DW	0201cH
	DW	0e21dH
	DW	0a41fH
	DW	0661eH
	DW	0281bH
	DW	0ea1aH
	DW	0ac18H
	DW	06e19H
	DW	03012H
	DW	0f213H
	DW	0b411H
	DW	07610H
	DW	03815H
	DW	0fa14H
	DW	0bc16H
	DW	07e17H
	DW	04038H
	DW	08239H
	DW	0c43bH
	DW	063aH
	DW	0483fH
	DW	08a3eH
	DW	0cc3cH
	DW	0e3dH
	DW	05036H
	DW	09237H
	DW	0d435H
	DW	01634H
	DW	05831H
	DW	09a30H
	DW	0dc32H
	DW	01e33H
	DW	06024H
	DW	0a225H
	DW	0e427H
	DW	02626H
	DW	06823H
	DW	0aa22H
	DW	0ec20H
	DW	02e21H
	DW	0702aH
	DW	0b22bH
	DW	0f429H
	DW	03628H
	DW	0782dH
	DW	0ba2cH
	DW	0fc2eH
	DW	03e2fH
	DW	08070H
	DW	04271H
	DW	0473H
	DW	0c672H
	DW	08877H
	DW	04a76H
	DW	0c74H
	DW	0ce75H
	DW	0907eH
	DW	0527fH
	DW	0147dH
	DW	0d67cH
	DW	09879H
	DW	05a78H
	DW	01c7aH
	DW	0de7bH
	DW	0a06cH
	DW	0626dH
	DW	0246fH
	DW	0e66eH
	DW	0a86bH
	DW	06a6aH
	DW	02c68H
	DW	0ee69H
	DW	0b062H
	DW	07263H
	DW	03461H
	DW	0f660H
	DW	0b865H
	DW	07a64H
	DW	03c66H
	DW	0fe67H
	DW	0c048H
	DW	0249H
	DW	0444bH
	DW	0864aH
	DW	0c84fH
	DW	0a4eH
	DW	04c4cH
	DW	08e4dH
	DW	0d046H
	DW	01247H
	DW	05445H
	DW	09644H
	DW	0d841H
	DW	01a40H
	DW	05c42H
	DW	09e43H
	DW	0e054H
	DW	02255H
	DW	06457H
	DW	0a656H
	DW	0e853H
	DW	02a52H
	DW	06c50H
	DW	0ae51H
	DW	0f05aH
	DW	0325bH
	DW	07459H
	DW	0b658H
	DW	0f85dH
	DW	03a5cH
	DW	07c5eH
	DW	0be5fH
	DW	0e1H
	DW	0c2e0H
	DW	084e2H
	DW	046e3H
	DW	08e6H
	DW	0cae7H
	DW	08ce5H
	DW	04ee4H
	DW	010efH
	DW	0d2eeH
	DW	094ecH
	DW	056edH
	DW	018e8H
	DW	0dae9H
	DW	09cebH
	DW	05eeaH
	DW	020fdH
	DW	0e2fcH
	DW	0a4feH
	DW	066ffH
	DW	028faH
	DW	0eafbH
	DW	0acf9H
	DW	06ef8H
	DW	030f3H
	DW	0f2f2H
	DW	0b4f0H
	DW	076f1H
	DW	038f4H
	DW	0faf5H
	DW	0bcf7H
	DW	07ef6H
	DW	040d9H
	DW	082d8H
	DW	0c4daH
	DW	06dbH
	DW	048deH
	DW	08adfH
	DW	0ccddH
	DW	0edcH
	DW	050d7H
	DW	092d6H
	DW	0d4d4H
	DW	016d5H
	DW	058d0H
	DW	09ad1H
	DW	0dcd3H
	DW	01ed2H
	DW	060c5H
	DW	0a2c4H
	DW	0e4c6H
	DW	026c7H
	DW	068c2H
	DW	0aac3H
	DW	0ecc1H
	DW	02ec0H
	DW	070cbH
	DW	0b2caH
	DW	0f4c8H
	DW	036c9H
	DW	078ccH
	DW	0bacdH
	DW	0fccfH
	DW	03eceH
	DW	08091H
	DW	04290H
	DW	0492H
	DW	0c693H
	DW	08896H
	DW	04a97H
	DW	0c95H
	DW	0ce94H
	DW	0909fH
	DW	0529eH
	DW	0149cH
	DW	0d69dH
	DW	09898H
	DW	05a99H
	DW	01c9bH
	DW	0de9aH
	DW	0a08dH
	DW	0628cH
	DW	0248eH
	DW	0e68fH
	DW	0a88aH
	DW	06a8bH
	DW	02c89H
	DW	0ee88H
	DW	0b083H
	DW	07282H
	DW	03480H
	DW	0f681H
	DW	0b884H
	DW	07a85H
	DW	03c87H
	DW	0fe86H
	DW	0c0a9H
	DW	02a8H
	DW	044aaH
	DW	086abH
	DW	0c8aeH
	DW	0aafH
	DW	04cadH
	DW	08eacH
	DW	0d0a7H
	DW	012a6H
	DW	054a4H
	DW	096a5H
	DW	0d8a0H
	DW	01aa1H
	DW	05ca3H
	DW	09ea2H
	DW	0e0b5H
	DW	022b4H
	DW	064b6H
	DW	0a6b7H
	DW	0e8b2H
	DW	02ab3H
	DW	06cb1H
	DW	0aeb0H
	DW	0f0bbH
	DW	032baH
	DW	074b8H
	DW	0b6b9H
	DW	0f8bcH
	DW	03abdH
	DW	07cbfH
	DW	0bebeH
_gft_le64 DW	00H
	DW	0b001H
	DW	06003H
	DW	0d002H
	DW	0c006H
	DW	07007H
	DW	0a005H
	DW	01004H
	DW	0800dH
	DW	0300cH
	DW	0e00eH
	DW	0500fH
	DW	0400bH
	DW	0f00aH
	DW	02008H
	DW	09009H
	DW	01bH
	DW	0b01aH
	DW	06018H
	DW	0d019H
	DW	0c01dH
	DW	0701cH
	DW	0a01eH
	DW	0101fH
	DW	08016H
	DW	03017H
	DW	0e015H
	DW	05014H
	DW	04010H
	DW	0f011H
	DW	02013H
	DW	09012H
	DW	036H
	DW	0b037H
	DW	06035H
	DW	0d034H
	DW	0c030H
	DW	07031H
	DW	0a033H
	DW	01032H
	DW	0803bH
	DW	0303aH
	DW	0e038H
	DW	05039H
	DW	0403dH
	DW	0f03cH
	DW	0203eH
	DW	0903fH
	DW	02dH
	DW	0b02cH
	DW	0602eH
	DW	0d02fH
	DW	0c02bH
	DW	0702aH
	DW	0a028H
	DW	01029H
	DW	08020H
	DW	03021H
	DW	0e023H
	DW	05022H
	DW	04026H
	DW	0f027H
	DW	02025H
	DW	09024H
	DW	06cH
	DW	0b06dH
	DW	0606fH
	DW	0d06eH
	DW	0c06aH
	DW	0706bH
	DW	0a069H
	DW	01068H
	DW	08061H
	DW	03060H
	DW	0e062H
	DW	05063H
	DW	04067H
	DW	0f066H
	DW	02064H
	DW	09065H
	DW	077H
	DW	0b076H
	DW	06074H
	DW	0d075H
	DW	0c071H
	DW	07070H
	DW	0a072H
	DW	01073H
	DW	0807aH
	DW	0307bH
	DW	0e079H
	DW	05078H
	DW	0407cH
	DW	0f07dH
	DW	0207fH
	DW	0907eH
	DW	05aH
	DW	0b05bH
	DW	06059H
	DW	0d058H
	DW	0c05cH
	DW	0705dH
	DW	0a05fH
	DW	0105eH
	DW	08057H
	DW	03056H
	DW	0e054H
	DW	05055H
	DW	04051H
	DW	0f050H
	DW	02052H
	DW	09053H
	DW	041H
	DW	0b040H
	DW	06042H
	DW	0d043H
	DW	0c047H
	DW	07046H
	DW	0a044H
	DW	01045H
	DW	0804cH
	DW	0304dH
	DW	0e04fH
	DW	0504eH
	DW	0404aH
	DW	0f04bH
	DW	02049H
	DW	09048H
	DW	0d8H
	DW	0b0d9H
	DW	060dbH
	DW	0d0daH
	DW	0c0deH
	DW	070dfH
	DW	0a0ddH
	DW	010dcH
	DW	080d5H
	DW	030d4H
	DW	0e0d6H
	DW	050d7H
	DW	040d3H
	DW	0f0d2H
	DW	020d0H
	DW	090d1H
	DW	0c3H
	DW	0b0c2H
	DW	060c0H
	DW	0d0c1H
	DW	0c0c5H
	DW	070c4H
	DW	0a0c6H
	DW	010c7H
	DW	080ceH
	DW	030cfH
	DW	0e0cdH
	DW	050ccH
	DW	040c8H
	DW	0f0c9H
	DW	020cbH
	DW	090caH
	DW	0eeH
	DW	0b0efH
	DW	060edH
	DW	0d0ecH
	DW	0c0e8H
	DW	070e9H
	DW	0a0ebH
	DW	010eaH
	DW	080e3H
	DW	030e2H
	DW	0e0e0H
	DW	050e1H
	DW	040e5H
	DW	0f0e4H
	DW	020e6H
	DW	090e7H
	DW	0f5H
	DW	0b0f4H
	DW	060f6H
	DW	0d0f7H
	DW	0c0f3H
	DW	070f2H
	DW	0a0f0H
	DW	010f1H
	DW	080f8H
	DW	030f9H
	DW	0e0fbH
	DW	050faH
	DW	040feH
	DW	0f0ffH
	DW	020fdH
	DW	090fcH
	DW	0b4H
	DW	0b0b5H
	DW	060b7H
	DW	0d0b6H
	DW	0c0b2H
	DW	070b3H
	DW	0a0b1H
	DW	010b0H
	DW	080b9H
	DW	030b8H
	DW	0e0baH
	DW	050bbH
	DW	040bfH
	DW	0f0beH
	DW	020bcH
	DW	090bdH
	DW	0afH
	DW	0b0aeH
	DW	060acH
	DW	0d0adH
	DW	0c0a9H
	DW	070a8H
	DW	0a0aaH
	DW	010abH
	DW	080a2H
	DW	030a3H
	DW	0e0a1H
	DW	050a0H
	DW	040a4H
	DW	0f0a5H
	DW	020a7H
	DW	090a6H
	DW	082H
	DW	0b083H
	DW	06081H
	DW	0d080H
	DW	0c084H
	DW	07085H
	DW	0a087H
	DW	01086H
	DW	0808fH
	DW	0308eH
	DW	0e08cH
	DW	0508dH
	DW	04089H
	DW	0f088H
	DW	0208aH
	DW	0908bH
	DW	099H
	DW	0b098H
	DW	0609aH
	DW	0d09bH
	DW	0c09fH
	DW	0709eH
	DW	0a09cH
	DW	0109dH
	DW	08094H
	DW	03095H
	DW	0e097H
	DW	05096H
	DW	04092H
	DW	0f093H
	DW	02091H
	DW	09090H
_gft_be	DW	00H
	DW	01c2H
	DW	0384H
	DW	0246H
	DW	0708H
	DW	06caH
	DW	048cH
	DW	054eH
	DW	0e10H
	DW	0fd2H
	DW	0d94H
	DW	0c56H
	DW	0918H
	DW	08daH
	DW	0a9cH
	DW	0b5eH
	DW	01c20H
	DW	01de2H
	DW	01fa4H
	DW	01e66H
	DW	01b28H
	DW	01aeaH
	DW	018acH
	DW	0196eH
	DW	01230H
	DW	013f2H
	DW	011b4H
	DW	01076H
	DW	01538H
	DW	014faH
	DW	016bcH
	DW	0177eH
	DW	03840H
	DW	03982H
	DW	03bc4H
	DW	03a06H
	DW	03f48H
	DW	03e8aH
	DW	03cccH
	DW	03d0eH
	DW	03650H
	DW	03792H
	DW	035d4H
	DW	03416H
	DW	03158H
	DW	0309aH
	DW	032dcH
	DW	0331eH
	DW	02460H
	DW	025a2H
	DW	027e4H
	DW	02626H
	DW	02368H
	DW	022aaH
	DW	020ecH
	DW	0212eH
	DW	02a70H
	DW	02bb2H
	DW	029f4H
	DW	02836H
	DW	02d78H
	DW	02cbaH
	DW	02efcH
	DW	02f3eH
	DW	07080H
	DW	07142H
	DW	07304H
	DW	072c6H
	DW	07788H
	DW	0764aH
	DW	0740cH
	DW	075ceH
	DW	07e90H
	DW	07f52H
	DW	07d14H
	DW	07cd6H
	DW	07998H
	DW	0785aH
	DW	07a1cH
	DW	07bdeH
	DW	06ca0H
	DW	06d62H
	DW	06f24H
	DW	06ee6H
	DW	06ba8H
	DW	06a6aH
	DW	0682cH
	DW	069eeH
	DW	062b0H
	DW	06372H
	DW	06134H
	DW	060f6H
	DW	065b8H
	DW	0647aH
	DW	0663cH
	DW	067feH
	DW	048c0H
	DW	04902H
	DW	04b44H
	DW	04a86H
	DW	04fc8H
	DW	04e0aH
	DW	04c4cH
	DW	04d8eH
	DW	046d0H
	DW	04712H
	DW	04554H
	DW	04496H
	DW	041d8H
	DW	0401aH
	DW	0425cH
	DW	0439eH
	DW	054e0H
	DW	05522H
	DW	05764H
	DW	056a6H
	DW	053e8H
	DW	0522aH
	DW	0506cH
	DW	051aeH
	DW	05af0H
	DW	05b32H
	DW	05974H
	DW	058b6H
	DW	05df8H
	DW	05c3aH
	DW	05e7cH
	DW	05fbeH
	DW	0e100H
	DW	0e0c2H
	DW	0e284H
	DW	0e346H
	DW	0e608H
	DW	0e7caH
	DW	0e58cH
	DW	0e44eH
	DW	0ef10H
	DW	0eed2H
	DW	0ec94H
	DW	0ed56H
	DW	0e818H
	DW	0e9daH
	DW	0eb9cH
	DW	0ea5eH
	DW	0fd20H
	DW	0fce2H
	DW	0fea4H
	DW	0ff66H
	DW	0fa28H
	DW	0fbeaH
	DW	0f9acH
	DW	0f86eH
	DW	0f330H
	DW	0f2f2H
	DW	0f0b4H
	DW	0f176H
	DW	0f438H
	DW	0f5faH
	DW	0f7bcH
	DW	0f67eH
	DW	0d940H
	DW	0d882H
	DW	0dac4H
	DW	0db06H
	DW	0de48H
	DW	0df8aH
	DW	0ddccH
	DW	0dc0eH
	DW	0d750H
	DW	0d692H
	DW	0d4d4H
	DW	0d516H
	DW	0d058H
	DW	0d19aH
	DW	0d3dcH
	DW	0d21eH
	DW	0c560H
	DW	0c4a2H
	DW	0c6e4H
	DW	0c726H
	DW	0c268H
	DW	0c3aaH
	DW	0c1ecH
	DW	0c02eH
	DW	0cb70H
	DW	0cab2H
	DW	0c8f4H
	DW	0c936H
	DW	0cc78H
	DW	0cdbaH
	DW	0cffcH
	DW	0ce3eH
	DW	09180H
	DW	09042H
	DW	09204H
	DW	093c6H
	DW	09688H
	DW	0974aH
	DW	0950cH
	DW	094ceH
	DW	09f90H
	DW	09e52H
	DW	09c14H
	DW	09dd6H
	DW	09898H
	DW	0995aH
	DW	09b1cH
	DW	09adeH
	DW	08da0H
	DW	08c62H
	DW	08e24H
	DW	08fe6H
	DW	08aa8H
	DW	08b6aH
	DW	0892cH
	DW	088eeH
	DW	083b0H
	DW	08272H
	DW	08034H
	DW	081f6H
	DW	084b8H
	DW	0857aH
	DW	0873cH
	DW	086feH
	DW	0a9c0H
	DW	0a802H
	DW	0aa44H
	DW	0ab86H
	DW	0aec8H
	DW	0af0aH
	DW	0ad4cH
	DW	0ac8eH
	DW	0a7d0H
	DW	0a612H
	DW	0a454H
	DW	0a596H
	DW	0a0d8H
	DW	0a11aH
	DW	0a35cH
	DW	0a29eH
	DW	0b5e0H
	DW	0b422H
	DW	0b664H
	DW	0b7a6H
	DW	0b2e8H
	DW	0b32aH
	DW	0b16cH
	DW	0b0aeH
	DW	0bbf0H
	DW	0ba32H
	DW	0b874H
	DW	0b9b6H
	DW	0bcf8H
	DW	0bd3aH
	DW	0bf7cH
	DW	0bebeH
_gft_be64 DW	00H
	DW	01b0H
	DW	0360H
	DW	02d0H
	DW	06c0H
	DW	0770H
	DW	05a0H
	DW	0410H
	DW	0d80H
	DW	0c30H
	DW	0ee0H
	DW	0f50H
	DW	0b40H
	DW	0af0H
	DW	0820H
	DW	0990H
	DW	01b00H
	DW	01ab0H
	DW	01860H
	DW	019d0H
	DW	01dc0H
	DW	01c70H
	DW	01ea0H
	DW	01f10H
	DW	01680H
	DW	01730H
	DW	015e0H
	DW	01450H
	DW	01040H
	DW	011f0H
	DW	01320H
	DW	01290H
	DW	03600H
	DW	037b0H
	DW	03560H
	DW	034d0H
	DW	030c0H
	DW	03170H
	DW	033a0H
	DW	03210H
	DW	03b80H
	DW	03a30H
	DW	038e0H
	DW	03950H
	DW	03d40H
	DW	03cf0H
	DW	03e20H
	DW	03f90H
	DW	02d00H
	DW	02cb0H
	DW	02e60H
	DW	02fd0H
	DW	02bc0H
	DW	02a70H
	DW	028a0H
	DW	02910H
	DW	02080H
	DW	02130H
	DW	023e0H
	DW	02250H
	DW	02640H
	DW	027f0H
	DW	02520H
	DW	02490H
	DW	06c00H
	DW	06db0H
	DW	06f60H
	DW	06ed0H
	DW	06ac0H
	DW	06b70H
	DW	069a0H
	DW	06810H
	DW	06180H
	DW	06030H
	DW	062e0H
	DW	06350H
	DW	06740H
	DW	066f0H
	DW	06420H
	DW	06590H
	DW	07700H
	DW	076b0H
	DW	07460H
	DW	075d0H
	DW	071c0H
	DW	07070H
	DW	072a0H
	DW	07310H
	DW	07a80H
	DW	07b30H
	DW	079e0H
	DW	07850H
	DW	07c40H
	DW	07df0H
	DW	07f20H
	DW	07e90H
	DW	05a00H
	DW	05bb0H
	DW	05960H
	DW	058d0H
	DW	05cc0H
	DW	05d70H
	DW	05fa0H
	DW	05e10H
	DW	05780H
	DW	05630H
	DW	054e0H
	DW	05550H
	DW	05140H
	DW	050f0H
	DW	05220H
	DW	05390H
	DW	04100H
	DW	040b0H
	DW	04260H
	DW	043d0H
	DW	047c0H
	DW	04670H
	DW	044a0H
	DW	04510H
	DW	04c80H
	DW	04d30H
	DW	04fe0H
	DW	04e50H
	DW	04a40H
	DW	04bf0H
	DW	04920H
	DW	04890H
	DW	0d800H
	DW	0d9b0H
	DW	0db60H
	DW	0dad0H
	DW	0dec0H
	DW	0df70H
	DW	0dda0H
	DW	0dc10H
	DW	0d580H
	DW	0d430H
	DW	0d6e0H
	DW	0d750H
	DW	0d340H
	DW	0d2f0H
	DW	0d020H
	DW	0d190H
	DW	0c300H
	DW	0c2b0H
	DW	0c060H
	DW	0c1d0H
	DW	0c5c0H
	DW	0c470H
	DW	0c6a0H
	DW	0c710H
	DW	0ce80H
	DW	0cf30H
	DW	0cde0H
	DW	0cc50H
	DW	0c840H
	DW	0c9f0H
	DW	0cb20H
	DW	0ca90H
	DW	0ee00H
	DW	0efb0H
	DW	0ed60H
	DW	0ecd0H
	DW	0e8c0H
	DW	0e970H
	DW	0eba0H
	DW	0ea10H
	DW	0e380H
	DW	0e230H
	DW	0e0e0H
	DW	0e150H
	DW	0e540H
	DW	0e4f0H
	DW	0e620H
	DW	0e790H
	DW	0f500H
	DW	0f4b0H
	DW	0f660H
	DW	0f7d0H
	DW	0f3c0H
	DW	0f270H
	DW	0f0a0H
	DW	0f110H
	DW	0f880H
	DW	0f930H
	DW	0fbe0H
	DW	0fa50H
	DW	0fe40H
	DW	0fff0H
	DW	0fd20H
	DW	0fc90H
	DW	0b400H
	DW	0b5b0H
	DW	0b760H
	DW	0b6d0H
	DW	0b2c0H
	DW	0b370H
	DW	0b1a0H
	DW	0b010H
	DW	0b980H
	DW	0b830H
	DW	0bae0H
	DW	0bb50H
	DW	0bf40H
	DW	0bef0H
	DW	0bc20H
	DW	0bd90H
	DW	0af00H
	DW	0aeb0H
	DW	0ac60H
	DW	0add0H
	DW	0a9c0H
	DW	0a870H
	DW	0aaa0H
	DW	0ab10H
	DW	0a280H
	DW	0a330H
	DW	0a1e0H
	DW	0a050H
	DW	0a440H
	DW	0a5f0H
	DW	0a720H
	DW	0a690H
	DW	08200H
	DW	083b0H
	DW	08160H
	DW	080d0H
	DW	084c0H
	DW	08570H
	DW	087a0H
	DW	08610H
	DW	08f80H
	DW	08e30H
	DW	08ce0H
	DW	08d50H
	DW	08940H
	DW	088f0H
	DW	08a20H
	DW	08b90H
	DW	09900H
	DW	098b0H
	DW	09a60H
	DW	09bd0H
	DW	09fc0H
	DW	09e70H
	DW	09ca0H
	DW	09d10H
	DW	09480H
	DW	09530H
	DW	097e0H
	DW	09650H
	DW	09240H
	DW	093f0H
	DW	09120H
	DW	09090H
CONST	ENDS
_DATA	SEGMENT
_gf_poly DD	00H
	DD	0e1000000H
_gf_poly64 DD	00H
	DD	0d8000000H
_DATA	ENDS
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 13070:     volatile char *vptr = (volatile char *)ptr;
; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _cnt$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	85 d2		 test	 edx, edx
  0000c	74 0b		 je	 SHORT $LN1@RtlSecureZ
  0000e	8b ff		 npad	 2
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 13080:         vptr++;

  00013	41		 inc	 ecx

; 13081:         cnt--;

  00014	83 ea 01	 sub	 edx, 1
  00017	75 f7		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;
; 13087: }

  00019	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
PUBLIC	_bsw_32
; Function compile flags: /Ogtpy
; File c:\users\public\desktop\projects\ciphershed\src\common\gfmul.c
;	COMDAT _bsw_32
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 4
_bsw_32	PROC						; COMDAT

; 116  : {   unsigned int i = n;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _n$[esp-4]

; 117  :     while(i--)

  00004	85 c9		 test	 ecx, ecx
  00006	74 2a		 je	 SHORT $LN6@bsw_32
  00008	8b 54 24 04	 mov	 edx, DWORD PTR _p$[esp-4]
  0000c	56		 push	 esi
  0000d	8d 49 00	 npad	 3
$LL2@bsw_32:

; 118  :         ((mode(32t)*)p)[i] = bswap_32(((mode(32t)*)p)[i]);

  00010	8b 44 8a fc	 mov	 eax, DWORD PTR [edx+ecx*4-4]
  00014	49		 dec	 ecx
  00015	8b f0		 mov	 esi, eax
  00017	c1 ce 08	 ror	 esi, 8
  0001a	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  00020	c1 c0 08	 rol	 eax, 8
  00023	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00028	0b f0		 or	 esi, eax
  0002a	89 34 8a	 mov	 DWORD PTR [edx+ecx*4], esi
  0002d	85 c9		 test	 ecx, ecx
  0002f	75 df		 jne	 SHORT $LL2@bsw_32
  00031	5e		 pop	 esi
$LN6@bsw_32:

; 119  : }

  00032	c3		 ret	 0
_bsw_32	ENDP
_TEXT	ENDS
PUBLIC	_move_block_aligned
; Function compile flags: /Ogtpy
;	COMDAT _move_block_aligned
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned PROC				; COMDAT

; 156  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1],
; 157  :     lp32(p)[2] = lp32(q)[2], lp32(p)[3] = lp32(q)[3];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _q$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _p$[esp-4]
  0000a	89 11		 mov	 DWORD PTR [ecx], edx
  0000c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0000f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00018	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 158  : }

  0001e	c3		 ret	 0
_move_block_aligned ENDP
_TEXT	ENDS
PUBLIC	_move_block_aligned64
; Function compile flags: /Ogtpy
;	COMDAT _move_block_aligned64
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_move_block_aligned64 PROC				; COMDAT

; 162  :     lp32(p)[0] = lp32(q)[0], lp32(p)[1] = lp32(q)[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _q$[esp-4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _p$[esp-4]
  0000a	89 11		 mov	 DWORD PTR [ecx], edx
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 163  : }

  00012	c3		 ret	 0
_move_block_aligned64 ENDP
_TEXT	ENDS
PUBLIC	_xor_block_aligned
; Function compile flags: /Ogtpy
;	COMDAT _xor_block_aligned
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned PROC					; COMDAT

; 167  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1],
; 168  :     lp32(p)[2] ^= lp32(q)[2], lp32(p)[3] ^= lp32(q)[3];

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _q$[esp-4]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR _p$[esp-4]
  0000a	31 10		 xor	 DWORD PTR [eax], edx
  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	31 50 04	 xor	 DWORD PTR [eax+4], edx
  00012	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00015	31 50 08	 xor	 DWORD PTR [eax+8], edx
  00018	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0001b	31 48 0c	 xor	 DWORD PTR [eax+12], ecx

; 169  : }

  0001e	c3		 ret	 0
_xor_block_aligned ENDP
_TEXT	ENDS
PUBLIC	_xor_block_aligned64
; Function compile flags: /Ogtpy
;	COMDAT _xor_block_aligned64
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_xor_block_aligned64 PROC				; COMDAT

; 173  :     lp32(p)[0] ^= lp32(q)[0], lp32(p)[1] ^= lp32(q)[1];

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _q$[esp-4]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR _p$[esp-4]
  0000a	31 10		 xor	 DWORD PTR [eax], edx
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 174  : }

  00012	c3		 ret	 0
_xor_block_aligned64 ENDP
_TEXT	ENDS
PUBLIC	_mul_x
; Function compile flags: /Ogtpy
;	COMDAT _mul_x
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_x	PROC						; COMDAT

; 295  : 
; 296  :     bsw_32(x, 4);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _x$[esp-4]
  00004	ba 04 00 00 00	 mov	 edx, 4
  00009	56		 push	 esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@mul_x:
  00010	8b 4c 90 fc	 mov	 ecx, DWORD PTR [eax+edx*4-4]
  00014	4a		 dec	 edx
  00015	8b f1		 mov	 esi, ecx
  00017	c1 ce 08	 ror	 esi, 8
  0001a	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  00020	c1 c1 08	 rol	 ecx, 8
  00023	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  00029	0b f1		 or	 esi, ecx
  0002b	89 34 90	 mov	 DWORD PTR [eax+edx*4], esi
  0002e	85 d2		 test	 edx, edx
  00030	75 de		 jne	 SHORT $LL4@mul_x

; 297  : 
; 298  :     /* at this point the filed element bits 0..127 are set out  */
; 299  :     /* as follows in 32-bit words (where the most significant   */
; 300  :     /* (ms) numeric bits are to the left)                       */
; 301  :     /*                                                          */
; 302  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 303  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 304  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 305  : 
; 306  :     t = gf_poly[x[3] & 1];          /* bit 127 of the element   */

  00032	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00035	8b d1		 mov	 edx, ecx
  00037	83 e2 01	 and	 edx, 1
  0003a	57		 push	 edi
  0003b	8b 3c 95 00 00
	00 00		 mov	 edi, DWORD PTR _gf_poly[edx*4]

; 307  :     x[3] = (x[3] >> 1) | (x[2] << 31);  /* shift bits up by one */

  00042	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00045	8b f2		 mov	 esi, edx
  00047	d1 e9		 shr	 ecx, 1
  00049	c1 e6 1f	 shl	 esi, 31			; 0000001fH
  0004c	0b f1		 or	 esi, ecx
  0004e	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 308  :     x[2] = (x[2] >> 1) | (x[1] << 31);  /* position             */

  00051	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00054	d1 ea		 shr	 edx, 1
  00056	8b ce		 mov	 ecx, esi
  00058	c1 e1 1f	 shl	 ecx, 31			; 0000001fH
  0005b	0b ca		 or	 ecx, edx
  0005d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 309  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b d1		 mov	 edx, ecx
  00064	c1 e2 1f	 shl	 edx, 31			; 0000001fH
  00067	d1 ee		 shr	 esi, 1
  00069	0b d6		 or	 edx, esi

; 310  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0006b	d1 e9		 shr	 ecx, 1
  0006d	33 cf		 xor	 ecx, edi
  0006f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00072	89 08		 mov	 DWORD PTR [eax], ecx

; 311  :     bsw_32(x, 4);

  00074	ba 04 00 00 00	 mov	 edx, 4
  00079	5f		 pop	 edi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL8@mul_x:
  00080	8b 4c 90 fc	 mov	 ecx, DWORD PTR [eax+edx*4-4]
  00084	4a		 dec	 edx
  00085	8b f1		 mov	 esi, ecx
  00087	c1 ce 08	 ror	 esi, 8
  0008a	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  00090	c1 c1 08	 rol	 ecx, 8
  00093	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  00099	0b f1		 or	 esi, ecx
  0009b	89 34 90	 mov	 DWORD PTR [eax+edx*4], esi
  0009e	85 d2		 test	 edx, edx
  000a0	75 de		 jne	 SHORT $LL8@mul_x
  000a2	5e		 pop	 esi

; 312  : }

  000a3	c3		 ret	 0
_mul_x	ENDP
_TEXT	ENDS
PUBLIC	_mul_x64
; Function compile flags: /Ogtpy
;	COMDAT _mul_x64
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_x64 PROC						; COMDAT

; 316  : 
; 317  :     bsw_32(x, 2);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _x$[esp-4]
  00004	ba 02 00 00 00	 mov	 edx, 2
  00009	56		 push	 esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@mul_x64:
  00010	8b 44 91 fc	 mov	 eax, DWORD PTR [ecx+edx*4-4]
  00014	4a		 dec	 edx
  00015	8b f0		 mov	 esi, eax
  00017	c1 ce 08	 ror	 esi, 8
  0001a	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  00020	c1 c0 08	 rol	 eax, 8
  00023	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00028	0b f0		 or	 esi, eax
  0002a	89 34 91	 mov	 DWORD PTR [ecx+edx*4], esi
  0002d	85 d2		 test	 edx, edx
  0002f	75 df		 jne	 SHORT $LL4@mul_x64

; 318  : 
; 319  :     /* at this point the filed element bits 0..127 are set out  */
; 320  :     /* as follows in 32-bit words (where the most significant   */
; 321  :     /* (ms) numeric bits are to the left)                       */
; 322  :     /*                                                          */
; 323  :     /*            x[0]      x[1]      x[2]      x[3]            */
; 324  :     /*          ms    ls  ms    ls  ms    ls  ms     ls         */
; 325  :     /* field:   0 ... 31  32 .. 63  64 .. 95  96 .. 127         */
; 326  : 
; 327  :     t = gf_poly64[x[1] & 1];          /* bit 127 of the element   */

  00031	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00034	8b c2		 mov	 eax, edx
  00036	83 e0 01	 and	 eax, 1
  00039	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _gf_poly64[eax*4]

; 328  : 										/* shift bits up by one */
; 329  : 										/* position             */
; 330  :     x[1] = (x[1] >> 1) | (x[0] << 31);  /* if bit 7 is 1 xor in */

  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	57		 push	 edi
  00043	8b f8		 mov	 edi, eax
  00045	c1 e7 1f	 shl	 edi, 31			; 0000001fH
  00048	d1 ea		 shr	 edx, 1
  0004a	0b fa		 or	 edi, edx

; 331  :     x[0] = (x[0] >> 1) ^ t;             /* the field polynomial */

  0004c	d1 e8		 shr	 eax, 1
  0004e	33 c6		 xor	 eax, esi
  00050	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00053	89 01		 mov	 DWORD PTR [ecx], eax

; 332  :     bsw_32(x, 2);

  00055	ba 02 00 00 00	 mov	 edx, 2
  0005a	5f		 pop	 edi
  0005b	eb 03 8d 49 00	 npad	 5
$LL8@mul_x64:
  00060	8b 44 91 fc	 mov	 eax, DWORD PTR [ecx+edx*4-4]
  00064	4a		 dec	 edx
  00065	8b f0		 mov	 esi, eax
  00067	c1 ce 08	 ror	 esi, 8
  0006a	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  00070	c1 c0 08	 rol	 eax, 8
  00073	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00078	0b f0		 or	 esi, eax
  0007a	89 34 91	 mov	 DWORD PTR [ecx+edx*4], esi
  0007d	85 d2		 test	 edx, edx
  0007f	75 df		 jne	 SHORT $LL8@mul_x64
  00081	5e		 pop	 esi

; 333  : }

  00082	c3		 ret	 0
_mul_x64 ENDP
_TEXT	ENDS
PUBLIC	_mul_lex8
; Function compile flags: /Ogtpy
;	COMDAT _mul_lex8
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_lex8 PROC						; COMDAT

; 345  : {   mode(32t)   t = (x[3] >> 24);       /* in little endian format  */

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _x$[esp-4]

; 346  :     x[3] = (x[3] << 8) | (x[2] >> 24);

  00004	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00007	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	8b fa		 mov	 edi, edx
  00010	c1 ef 18	 shr	 edi, 24			; 00000018H
  00013	c1 e1 08	 shl	 ecx, 8
  00016	0b f9		 or	 edi, ecx

; 347  :     x[2] = (x[2] << 8) | (x[1] >> 24);

  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  0001e	8b f9		 mov	 edi, ecx
  00020	c1 ef 18	 shr	 edi, 24			; 00000018H
  00023	c1 e2 08	 shl	 edx, 8
  00026	0b fa		 or	 edi, edx

; 348  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  00028	8b 10		 mov	 edx, DWORD PTR [eax]
  0002a	89 78 08	 mov	 DWORD PTR [eax+8], edi
  0002d	8b fa		 mov	 edi, edx
  0002f	c1 e1 08	 shl	 ecx, 8
  00032	c1 ef 18	 shr	 edi, 24			; 00000018H
  00035	0b f9		 or	 edi, ecx
  00037	c1 ee 18	 shr	 esi, 24			; 00000018H
  0003a	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 349  :     x[0] = (x[0] << 8) ^ gft_le[t];

  0003d	0f b7 0c 75 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_le[esi*2]
  00045	c1 e2 08	 shl	 edx, 8
  00048	33 ca		 xor	 ecx, edx
  0004a	5f		 pop	 edi
  0004b	89 08		 mov	 DWORD PTR [eax], ecx
  0004d	5e		 pop	 esi

; 350  : }

  0004e	c3		 ret	 0
_mul_lex8 ENDP
_TEXT	ENDS
PUBLIC	_mul_lex8_64
; Function compile flags: /Ogtpy
;	COMDAT _mul_lex8_64
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_lex8_64 PROC					; COMDAT

; 353  : {   mode(32t)   t = (x[1] >> 24);       /* in little endian format  */

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _x$[esp-4]

; 354  :     x[1] = (x[1] << 8) | (x[0] >> 24);

  00004	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f0		 mov	 esi, eax
  0000d	8b f9		 mov	 edi, ecx
  0000f	c1 e0 08	 shl	 eax, 8
  00012	c1 ef 18	 shr	 edi, 24			; 00000018H
  00015	0b f8		 or	 edi, eax
  00017	c1 ee 18	 shr	 esi, 24			; 00000018H
  0001a	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 355  :     x[0] = (x[0] << 8) ^ gft_le64[t];

  0001d	0f b7 04 75 00
	00 00 00	 movzx	 eax, WORD PTR _gft_le64[esi*2]
  00025	c1 e1 08	 shl	 ecx, 8
  00028	33 c1		 xor	 eax, ecx
  0002a	5f		 pop	 edi
  0002b	89 02		 mov	 DWORD PTR [edx], eax
  0002d	5e		 pop	 esi

; 356  : }

  0002e	c3		 ret	 0
_mul_lex8_64 ENDP
_TEXT	ENDS
PUBLIC	_mul_bex8
; Function compile flags: /Ogtpy
;	COMDAT _mul_bex8
_TEXT	SEGMENT
_x$ = 8							; size = 4
_mul_bex8 PROC						; COMDAT

; 368  : {   mode(32t)   t = (x[3] & 0xff);      /* in big endian format     */

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _x$[esp-4]

; 369  :     x[3] = (x[3] >> 8) | (x[2] << 24);

  00004	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00007	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	0f b6 f1	 movzx	 esi, cl
  0000f	8b fa		 mov	 edi, edx
  00011	c1 e7 18	 shl	 edi, 24			; 00000018H
  00014	c1 e9 08	 shr	 ecx, 8
  00017	0b f9		 or	 edi, ecx

; 370  :     x[2] = (x[2] >> 8) | (x[1] << 24);

  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  0001f	8b f9		 mov	 edi, ecx
  00021	c1 e7 18	 shl	 edi, 24			; 00000018H
  00024	c1 ea 08	 shr	 edx, 8
  00027	0b fa		 or	 edi, edx

; 371  :     x[1] = (x[1] >> 8) | (x[0] << 24);

  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	89 78 08	 mov	 DWORD PTR [eax+8], edi
  0002e	8b fa		 mov	 edi, edx
  00030	c1 e9 08	 shr	 ecx, 8
  00033	c1 e7 18	 shl	 edi, 24			; 00000018H
  00036	0b f9		 or	 edi, ecx
  00038	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 372  :     x[0] = (x[0] >> 8) ^ (((mode(32t))gft_be[t]) << 16);

  0003b	0f b7 0c 75 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_be[esi*2]
  00043	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00046	c1 ea 08	 shr	 edx, 8
  00049	33 ca		 xor	 ecx, edx
  0004b	5f		 pop	 edi
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
  0004e	5e		 pop	 esi

; 373  : }

  0004f	c3		 ret	 0
_mul_bex8 ENDP
_TEXT	ENDS
PUBLIC	_GfMul128
; Function compile flags: /Ogtpy
;	COMDAT _GfMul128
_TEXT	SEGMENT
tv1317 = -152						; size = 4
_r$ = -148						; size = 16
_i$ = -132						; size = 4
_p$ = -128						; size = 128
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_GfMul128 PROC						; COMDAT

; 397  : {   mode(32t) r[CBLK_LEN >> 2], p[8][CBLK_LEN >> 2];

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H

; 398  :     int i;
; 399  : 
; 400  :     move_block_aligned(p[0], b);

  00006	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _b$[esp+148]
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	89 4c 24 18	 mov	 DWORD PTR _p$[esp+152], ecx
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	89 54 24 1c	 mov	 DWORD PTR _p$[esp+156], edx
  0001d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00020	89 4c 24 20	 mov	 DWORD PTR _p$[esp+160], ecx
  00024	89 54 24 24	 mov	 DWORD PTR _p$[esp+164], edx

; 401  :     bsw_32(p[0], 4);

  00028	b9 04 00 00 00	 mov	 ecx, 4
  0002d	8d 49 00	 npad	 3
$LL21@GfMul128:
  00030	8b 44 8c 14	 mov	 eax, DWORD PTR _p$[esp+ecx*4+148]
  00034	49		 dec	 ecx
  00035	8b d0		 mov	 edx, eax
  00037	c1 ca 08	 ror	 edx, 8
  0003a	81 e2 00 ff 00
	ff		 and	 edx, -16711936		; ff00ff00H
  00040	c1 c0 08	 rol	 eax, 8
  00043	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00048	0b d0		 or	 edx, eax
  0004a	89 54 8c 18	 mov	 DWORD PTR _p$[esp+ecx*4+152], edx
  0004e	85 c9		 test	 ecx, ecx
  00050	75 de		 jne	 SHORT $LL21@GfMul128
  00052	53		 push	 ebx
  00053	55		 push	 ebp
  00054	56		 push	 esi
  00055	57		 push	 edi

; 402  :     for(i = 0; i < 7; ++i)

  00056	8d 44 24 30	 lea	 eax, DWORD PTR _p$[esp+176]
  0005a	8d 79 07	 lea	 edi, DWORD PTR [ecx+7]
  0005d	8d 49 00	 npad	 3
$LL15@GfMul128:

; 403  :     {
; 404  :         p[i + 1][3] = (p[i][3] >> 1) | (p[i][2] << 31);

  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00065	8b d9		 mov	 ebx, ecx
  00067	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  0006a	8b f2		 mov	 esi, edx
  0006c	d1 ee		 shr	 esi, 1
  0006e	0b f3		 or	 esi, ebx
  00070	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 405  :         p[i + 1][2] = (p[i][2] >> 1) | (p[i][1] << 31);

  00073	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00076	d1 e9		 shr	 ecx, 1
  00078	8b de		 mov	 ebx, esi
  0007a	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  0007d	0b d9		 or	 ebx, ecx

; 406  :         p[i + 1][1] = (p[i][1] >> 1) | (p[i][0] << 31);

  0007f	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00082	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  00085	8b d9		 mov	 ebx, ecx

; 407  :         p[i + 1][0] = (p[i][0] >> 1) ^ gf_poly[p[i][3] & 1];

  00087	83 e2 01	 and	 edx, 1
  0008a	d1 e9		 shr	 ecx, 1
  0008c	33 0c 95 00 00
	00 00		 xor	 ecx, DWORD PTR _gf_poly[edx*4]
  00093	c1 e3 1f	 shl	 ebx, 31			; 0000001fH
  00096	d1 ee		 shr	 esi, 1
  00098	0b de		 or	 ebx, esi
  0009a	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  0009d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a0	83 c0 10	 add	 eax, 16			; 00000010H
  000a3	83 ef 01	 sub	 edi, 1
  000a6	75 b8		 jne	 SHORT $LL15@GfMul128

; 408  :     }
; 409  : 
; 410  :     memset(r, 0, CBLK_LEN);

  000a8	8b 9c 24 ac 00
	00 00		 mov	 ebx, DWORD PTR _a$[esp+164]
  000af	8b ac 24 a4 00
	00 00		 mov	 ebp, DWORD PTR _p$[esp+292]
  000b6	33 c0		 xor	 eax, eax
  000b8	8b c8		 mov	 ecx, eax
  000ba	8b f0		 mov	 esi, eax
  000bc	8b d0		 mov	 edx, eax
  000be	83 c3 0f	 add	 ebx, 15			; 0000000fH
  000c1	89 44 24 14	 mov	 DWORD PTR _r$[esp+168], eax
  000c5	89 4c 24 18	 mov	 DWORD PTR _r$[esp+172], ecx
  000c9	89 74 24 1c	 mov	 DWORD PTR _r$[esp+176], esi
  000cd	89 54 24 20	 mov	 DWORD PTR _r$[esp+180], edx

; 411  :     for(i = 0; i < 16; ++i)

  000d1	89 7c 24 24	 mov	 DWORD PTR _i$[esp+168], edi
  000d5	89 5c 24 10	 mov	 DWORD PTR tv1317[esp+168], ebx
  000d9	8d a4 24 00 00
	00 00		 npad	 7
$LL58@GfMul128:

; 412  :     {
; 413  :         if(i) mul_bex8(r);  /* order is always big endian here */

  000e0	85 ff		 test	 edi, edi
  000e2	74 31		 je	 SHORT $LN24@GfMul128
  000e4	8b de		 mov	 ebx, esi
  000e6	c1 e3 18	 shl	 ebx, 24			; 00000018H
  000e9	0f b6 fa	 movzx	 edi, dl
  000ec	0f b7 3c 7d 00
	00 00 00	 movzx	 edi, WORD PTR _gft_be[edi*2]
  000f4	c1 ea 08	 shr	 edx, 8
  000f7	0b d3		 or	 edx, ebx
  000f9	8b d9		 mov	 ebx, ecx
  000fb	c1 e3 18	 shl	 ebx, 24			; 00000018H
  000fe	c1 ee 08	 shr	 esi, 8
  00101	0b f3		 or	 esi, ebx
  00103	8b d8		 mov	 ebx, eax
  00105	c1 e9 08	 shr	 ecx, 8
  00108	c1 e3 18	 shl	 ebx, 24			; 00000018H
  0010b	c1 e7 10	 shl	 edi, 16			; 00000010H
  0010e	c1 e8 08	 shr	 eax, 8
  00111	0b cb		 or	 ecx, ebx
  00113	33 c7		 xor	 eax, edi
$LN24@GfMul128:

; 414  : 
; 415  :         if(((unsigned char*)a)[15 - i] & 0x80)

  00115	8b 7c 24 10	 mov	 edi, DWORD PTR tv1317[esp+168]
  00119	8a 1f		 mov	 bl, BYTE PTR [edi]
  0011b	84 db		 test	 bl, bl
  0011d	79 10		 jns	 SHORT $LN26@GfMul128

; 416  :             xor_block_aligned(r, p[0]);

  0011f	33 44 24 28	 xor	 eax, DWORD PTR _p$[esp+168]
  00123	33 4c 24 2c	 xor	 ecx, DWORD PTR _p$[esp+172]
  00127	33 74 24 30	 xor	 esi, DWORD PTR _p$[esp+176]
  0012b	33 54 24 34	 xor	 edx, DWORD PTR _p$[esp+180]
$LN26@GfMul128:

; 417  :         if(((unsigned char*)a)[15 - i] & 0x40)

  0012f	f6 c3 40	 test	 bl, 64			; 00000040H
  00132	74 10		 je	 SHORT $LN28@GfMul128

; 418  :             xor_block_aligned(r, p[1]);

  00134	33 44 24 38	 xor	 eax, DWORD PTR _p$[esp+184]
  00138	33 4c 24 3c	 xor	 ecx, DWORD PTR _p$[esp+188]
  0013c	33 74 24 40	 xor	 esi, DWORD PTR _p$[esp+192]
  00140	33 54 24 44	 xor	 edx, DWORD PTR _p$[esp+196]
$LN28@GfMul128:

; 419  :         if(((unsigned char*)a)[15 - i] & 0x20)

  00144	f6 c3 20	 test	 bl, 32			; 00000020H
  00147	74 10		 je	 SHORT $LN30@GfMul128

; 420  :             xor_block_aligned(r, p[2]);

  00149	33 44 24 48	 xor	 eax, DWORD PTR _p$[esp+200]
  0014d	33 4c 24 4c	 xor	 ecx, DWORD PTR _p$[esp+204]
  00151	33 74 24 50	 xor	 esi, DWORD PTR _p$[esp+208]
  00155	33 54 24 54	 xor	 edx, DWORD PTR _p$[esp+212]
$LN30@GfMul128:

; 421  :         if(((unsigned char*)a)[15 - i] & 0x10)

  00159	f6 c3 10	 test	 bl, 16			; 00000010H
  0015c	74 10		 je	 SHORT $LN32@GfMul128

; 422  :             xor_block_aligned(r, p[3]);

  0015e	33 44 24 58	 xor	 eax, DWORD PTR _p$[esp+216]
  00162	33 4c 24 5c	 xor	 ecx, DWORD PTR _p$[esp+220]
  00166	33 74 24 60	 xor	 esi, DWORD PTR _p$[esp+224]
  0016a	33 54 24 64	 xor	 edx, DWORD PTR _p$[esp+228]
$LN32@GfMul128:

; 423  :         if(((unsigned char*)a)[15 - i] & 0x08)

  0016e	f6 c3 08	 test	 bl, 8
  00171	74 10		 je	 SHORT $LN34@GfMul128

; 424  :             xor_block_aligned(r, p[4]);

  00173	33 44 24 68	 xor	 eax, DWORD PTR _p$[esp+232]
  00177	33 4c 24 6c	 xor	 ecx, DWORD PTR _p$[esp+236]
  0017b	33 74 24 70	 xor	 esi, DWORD PTR _p$[esp+240]
  0017f	33 54 24 74	 xor	 edx, DWORD PTR _p$[esp+244]
$LN34@GfMul128:

; 425  :         if(((unsigned char*)a)[15 - i] & 0x04)

  00183	f6 c3 04	 test	 bl, 4
  00186	74 16		 je	 SHORT $LN36@GfMul128

; 426  :             xor_block_aligned(r, p[5]);

  00188	33 44 24 78	 xor	 eax, DWORD PTR _p$[esp+248]
  0018c	33 4c 24 7c	 xor	 ecx, DWORD PTR _p$[esp+252]
  00190	33 b4 24 80 00
	00 00		 xor	 esi, DWORD PTR _p$[esp+256]
  00197	33 94 24 84 00
	00 00		 xor	 edx, DWORD PTR _p$[esp+260]
$LN36@GfMul128:

; 427  :         if(((unsigned char*)a)[15 - i] & 0x02)

  0019e	f6 c3 02	 test	 bl, 2
  001a1	74 1c		 je	 SHORT $LN38@GfMul128

; 428  :             xor_block_aligned(r, p[6]);

  001a3	33 84 24 88 00
	00 00		 xor	 eax, DWORD PTR _p$[esp+264]
  001aa	33 8c 24 8c 00
	00 00		 xor	 ecx, DWORD PTR _p$[esp+268]
  001b1	33 b4 24 90 00
	00 00		 xor	 esi, DWORD PTR _p$[esp+272]
  001b8	33 94 24 94 00
	00 00		 xor	 edx, DWORD PTR _p$[esp+276]
$LN38@GfMul128:

; 429  :         if(((unsigned char*)a)[15 - i] & 0x01)

  001bf	f6 c3 01	 test	 bl, 1
  001c2	74 17		 je	 SHORT $LN11@GfMul128

; 430  :             xor_block_aligned(r, p[7]);

  001c4	33 84 24 98 00
	00 00		 xor	 eax, DWORD PTR _p$[esp+280]
  001cb	33 8c 24 9c 00
	00 00		 xor	 ecx, DWORD PTR _p$[esp+284]
  001d2	33 b4 24 a0 00
	00 00		 xor	 esi, DWORD PTR _p$[esp+288]
  001d9	33 d5		 xor	 edx, ebp
$LN11@GfMul128:
  001db	8b 7c 24 24	 mov	 edi, DWORD PTR _i$[esp+168]
  001df	ff 4c 24 10	 dec	 DWORD PTR tv1317[esp+168]
  001e3	47		 inc	 edi
  001e4	83 ff 10	 cmp	 edi, 16			; 00000010H
  001e7	89 7c 24 24	 mov	 DWORD PTR _i$[esp+168], edi
  001eb	0f 8c ef fe ff
	ff		 jl	 $LL58@GfMul128
  001f1	5f		 pop	 edi
  001f2	89 74 24 18	 mov	 DWORD PTR _r$[esp+172], esi
  001f6	5e		 pop	 esi
  001f7	5d		 pop	 ebp
  001f8	89 4c 24 0c	 mov	 DWORD PTR _r$[esp+160], ecx
  001fc	89 44 24 08	 mov	 DWORD PTR _r$[esp+156], eax
  00200	89 54 24 14	 mov	 DWORD PTR _r$[esp+168], edx

; 431  :     }
; 432  :     bsw_32(r, 4);

  00204	b9 04 00 00 00	 mov	 ecx, 4
  00209	5b		 pop	 ebx
  0020a	8d 9b 00 00 00
	00		 npad	 6
$LL43@GfMul128:
  00210	8b 04 8c	 mov	 eax, DWORD PTR _r$[esp+ecx*4+148]
  00213	49		 dec	 ecx
  00214	8b d0		 mov	 edx, eax
  00216	c1 ca 08	 ror	 edx, 8
  00219	81 e2 00 ff 00
	ff		 and	 edx, -16711936		; ff00ff00H
  0021f	c1 c0 08	 rol	 eax, 8
  00222	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00227	0b d0		 or	 edx, eax
  00229	89 54 8c 04	 mov	 DWORD PTR _r$[esp+ecx*4+152], edx
  0022d	85 c9		 test	 ecx, ecx
  0022f	75 df		 jne	 SHORT $LL43@GfMul128

; 433  :     move_block_aligned(a, r);

  00231	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _a$[esp+148]
  00238	8b 4c 24 04	 mov	 ecx, DWORD PTR _r$[esp+152]
  0023c	8b 54 24 08	 mov	 edx, DWORD PTR _r$[esp+156]
  00240	89 08		 mov	 DWORD PTR [eax], ecx
  00242	8b 4c 24 0c	 mov	 ecx, DWORD PTR _r$[esp+160]
  00246	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00249	8b 54 24 10	 mov	 edx, DWORD PTR _r$[esp+164]
  0024d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00250	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 434  : }

  00253	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00259	c3		 ret	 0
_GfMul128 ENDP
_TEXT	ENDS
PUBLIC	_GfMul128Tab
; Function compile flags: /Ogtpy
;	COMDAT _GfMul128Tab
_TEXT	SEGMENT
tv1619 = 8						; size = 4
tv1577 = 8						; size = 4
tv1535 = 8						; size = 4
tv1493 = 8						; size = 4
tv1451 = 8						; size = 4
tv1409 = 8						; size = 4
tv1367 = 8						; size = 4
tv1325 = 8						; size = 4
tv1283 = 8						; size = 4
tv1241 = 8						; size = 4
tv1199 = 8						; size = 4
tv1157 = 8						; size = 4
tv1115 = 8						; size = 4
tv1073 = 8						; size = 4
tv1031 = 8						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_GfMul128Tab PROC					; COMDAT

; 444  : {   unsigned __int32 r[CBLK_LEN >> 2];

  00000	53		 push	 ebx

; 445  : 
; 446  :     move_block_aligned(r, ctx->gf_t8k[0][a[0] & 15]);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _a$[esp]
  00005	55		 push	 ebp
  00006	0f b6 2b	 movzx	 ebp, BYTE PTR [ebx]
  00009	56		 push	 esi
  0000a	8b f5		 mov	 esi, ebp

; 447  :     xor_block_aligned(r, ctx->gf_t8k[1][a[0] >> 4]);

  0000c	c1 ed 04	 shr	 ebp, 4
  0000f	83 c5 10	 add	 ebp, 16			; 00000010H
  00012	c1 e5 04	 shl	 ebp, 4
  00015	83 e6 0f	 and	 esi, 15			; 0000000fH
  00018	c1 e6 04	 shl	 esi, 4
  0001b	57		 push	 edi
  0001c	8b 7c 24 18	 mov	 edi, DWORD PTR _ctx$[esp+12]
  00020	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  00023	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00027	8b 4c 3e 04	 mov	 ecx, DWORD PTR [esi+edi+4]
  0002b	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0002f	8b 54 3e 08	 mov	 edx, DWORD PTR [esi+edi+8]
  00033	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00037	03 ef		 add	 ebp, edi
  00039	03 f7		 add	 esi, edi
  0003b	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  0003e	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]

; 448  :                 xor_8k( 1); xor_8k( 2); xor_8k( 3);

  00041	0f b6 6b 01	 movzx	 ebp, BYTE PTR [ebx+1]
  00045	89 6c 24 14	 mov	 DWORD PTR tv1031[esp+12], ebp
  00049	83 e5 0f	 and	 ebp, 15			; 0000000fH
  0004c	83 c5 20	 add	 ebp, 32			; 00000020H
  0004f	c1 e5 04	 shl	 ebp, 4
  00052	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00056	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0005a	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0005e	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00062	03 ef		 add	 ebp, edi
  00064	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1031[esp+12]
  00068	c1 ed 04	 shr	 ebp, 4
  0006b	83 c5 30	 add	 ebp, 48			; 00000030H
  0006e	c1 e5 04	 shl	 ebp, 4
  00071	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00075	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00079	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0007d	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00081	03 ef		 add	 ebp, edi
  00083	0f b6 6b 02	 movzx	 ebp, BYTE PTR [ebx+2]
  00087	89 6c 24 14	 mov	 DWORD PTR tv1073[esp+12], ebp
  0008b	83 e5 0f	 and	 ebp, 15			; 0000000fH
  0008e	83 c5 40	 add	 ebp, 64			; 00000040H
  00091	c1 e5 04	 shl	 ebp, 4
  00094	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00098	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0009c	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  000a0	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  000a4	03 ef		 add	 ebp, edi
  000a6	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1073[esp+12]
  000aa	c1 ed 04	 shr	 ebp, 4
  000ad	83 c5 50	 add	 ebp, 80			; 00000050H
  000b0	c1 e5 04	 shl	 ebp, 4
  000b3	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  000b7	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  000bb	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  000bf	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  000c3	03 ef		 add	 ebp, edi
  000c5	0f b6 6b 03	 movzx	 ebp, BYTE PTR [ebx+3]
  000c9	89 6c 24 14	 mov	 DWORD PTR tv1115[esp+12], ebp
  000cd	83 e5 0f	 and	 ebp, 15			; 0000000fH
  000d0	83 c5 60	 add	 ebp, 96			; 00000060H
  000d3	c1 e5 04	 shl	 ebp, 4
  000d6	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  000da	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  000de	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  000e2	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  000e6	03 ef		 add	 ebp, edi
  000e8	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1115[esp+12]
  000ec	c1 ed 04	 shr	 ebp, 4
  000ef	83 c5 70	 add	 ebp, 112		; 00000070H
  000f2	c1 e5 04	 shl	 ebp, 4
  000f5	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  000f9	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  000fd	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00101	03 ef		 add	 ebp, edi
  00103	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]

; 449  :     xor_8k( 4); xor_8k( 5); xor_8k( 6); xor_8k( 7);

  00106	0f b6 6b 04	 movzx	 ebp, BYTE PTR [ebx+4]
  0010a	89 6c 24 14	 mov	 DWORD PTR tv1157[esp+12], ebp
  0010e	83 e5 0f	 and	 ebp, 15			; 0000000fH
  00111	83 ed 80	 sub	 ebp, -128		; ffffff80H
  00114	c1 e5 04	 shl	 ebp, 4
  00117	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  0011b	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0011f	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00123	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00127	03 ef		 add	 ebp, edi
  00129	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1157[esp+12]
  0012d	c1 ed 04	 shr	 ebp, 4
  00130	81 c5 90 00 00
	00		 add	 ebp, 144		; 00000090H
  00136	c1 e5 04	 shl	 ebp, 4
  00139	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  0013d	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00141	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00145	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00149	03 ef		 add	 ebp, edi
  0014b	0f b6 6b 05	 movzx	 ebp, BYTE PTR [ebx+5]
  0014f	89 6c 24 14	 mov	 DWORD PTR tv1199[esp+12], ebp
  00153	83 e5 0f	 and	 ebp, 15			; 0000000fH
  00156	81 c5 a0 00 00
	00		 add	 ebp, 160		; 000000a0H
  0015c	c1 e5 04	 shl	 ebp, 4
  0015f	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00163	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00167	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0016b	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0016f	03 ef		 add	 ebp, edi
  00171	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1199[esp+12]
  00175	c1 ed 04	 shr	 ebp, 4
  00178	81 c5 b0 00 00
	00		 add	 ebp, 176		; 000000b0H
  0017e	c1 e5 04	 shl	 ebp, 4
  00181	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00185	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00189	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0018d	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00191	03 ef		 add	 ebp, edi
  00193	0f b6 6b 06	 movzx	 ebp, BYTE PTR [ebx+6]
  00197	89 6c 24 14	 mov	 DWORD PTR tv1241[esp+12], ebp
  0019b	83 e5 0f	 and	 ebp, 15			; 0000000fH
  0019e	81 c5 c0 00 00
	00		 add	 ebp, 192		; 000000c0H
  001a4	c1 e5 04	 shl	 ebp, 4
  001a7	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  001ab	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  001af	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  001b3	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  001b7	03 ef		 add	 ebp, edi
  001b9	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1241[esp+12]
  001bd	c1 ed 04	 shr	 ebp, 4
  001c0	81 c5 d0 00 00
	00		 add	 ebp, 208		; 000000d0H
  001c6	c1 e5 04	 shl	 ebp, 4
  001c9	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  001cd	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  001d1	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  001d5	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  001d9	03 ef		 add	 ebp, edi
  001db	0f b6 6b 07	 movzx	 ebp, BYTE PTR [ebx+7]
  001df	89 6c 24 14	 mov	 DWORD PTR tv1283[esp+12], ebp
  001e3	83 e5 0f	 and	 ebp, 15			; 0000000fH
  001e6	81 c5 e0 00 00
	00		 add	 ebp, 224		; 000000e0H
  001ec	c1 e5 04	 shl	 ebp, 4
  001ef	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  001f3	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  001f7	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  001fb	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  001ff	03 ef		 add	 ebp, edi
  00201	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1283[esp+12]
  00205	c1 ed 04	 shr	 ebp, 4
  00208	81 c5 f0 00 00
	00		 add	 ebp, 240		; 000000f0H
  0020e	c1 e5 04	 shl	 ebp, 4
  00211	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00215	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00219	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0021d	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00221	03 ef		 add	 ebp, edi

; 450  :     xor_8k( 8); xor_8k( 9); xor_8k(10); xor_8k(11);

  00223	0f b6 6b 08	 movzx	 ebp, BYTE PTR [ebx+8]
  00227	89 6c 24 14	 mov	 DWORD PTR tv1325[esp+12], ebp
  0022b	83 e5 0f	 and	 ebp, 15			; 0000000fH
  0022e	81 c5 00 01 00
	00		 add	 ebp, 256		; 00000100H
  00234	c1 e5 04	 shl	 ebp, 4
  00237	03 ef		 add	 ebp, edi
  00239	33 45 00	 xor	 eax, DWORD PTR [ebp]
  0023c	33 4d 04	 xor	 ecx, DWORD PTR [ebp+4]
  0023f	33 55 08	 xor	 edx, DWORD PTR [ebp+8]
  00242	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]
  00245	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1325[esp+12]
  00249	c1 ed 04	 shr	 ebp, 4
  0024c	81 c5 10 01 00
	00		 add	 ebp, 272		; 00000110H
  00252	c1 e5 04	 shl	 ebp, 4
  00255	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00259	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0025d	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00261	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00265	03 ef		 add	 ebp, edi
  00267	0f b6 6b 09	 movzx	 ebp, BYTE PTR [ebx+9]
  0026b	89 6c 24 14	 mov	 DWORD PTR tv1367[esp+12], ebp
  0026f	83 e5 0f	 and	 ebp, 15			; 0000000fH
  00272	81 c5 20 01 00
	00		 add	 ebp, 288		; 00000120H
  00278	c1 e5 04	 shl	 ebp, 4
  0027b	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  0027f	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00283	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00287	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0028b	03 ef		 add	 ebp, edi
  0028d	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1367[esp+12]
  00291	c1 ed 04	 shr	 ebp, 4
  00294	81 c5 30 01 00
	00		 add	 ebp, 304		; 00000130H
  0029a	c1 e5 04	 shl	 ebp, 4
  0029d	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  002a1	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  002a5	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  002a9	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  002ad	03 ef		 add	 ebp, edi
  002af	0f b6 6b 0a	 movzx	 ebp, BYTE PTR [ebx+10]
  002b3	89 6c 24 14	 mov	 DWORD PTR tv1409[esp+12], ebp
  002b7	83 e5 0f	 and	 ebp, 15			; 0000000fH
  002ba	81 c5 40 01 00
	00		 add	 ebp, 320		; 00000140H
  002c0	c1 e5 04	 shl	 ebp, 4
  002c3	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  002c7	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  002cb	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  002cf	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  002d3	03 ef		 add	 ebp, edi
  002d5	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1409[esp+12]
  002d9	c1 ed 04	 shr	 ebp, 4
  002dc	81 c5 50 01 00
	00		 add	 ebp, 336		; 00000150H
  002e2	c1 e5 04	 shl	 ebp, 4
  002e5	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  002e9	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  002ed	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  002f1	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  002f5	03 ef		 add	 ebp, edi
  002f7	0f b6 6b 0b	 movzx	 ebp, BYTE PTR [ebx+11]
  002fb	89 6c 24 14	 mov	 DWORD PTR tv1451[esp+12], ebp
  002ff	83 e5 0f	 and	 ebp, 15			; 0000000fH
  00302	81 c5 60 01 00
	00		 add	 ebp, 352		; 00000160H
  00308	c1 e5 04	 shl	 ebp, 4
  0030b	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  0030f	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00313	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00317	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0031b	03 ef		 add	 ebp, edi
  0031d	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1451[esp+12]
  00321	c1 ed 04	 shr	 ebp, 4
  00324	81 c5 70 01 00
	00		 add	 ebp, 368		; 00000170H
  0032a	c1 e5 04	 shl	 ebp, 4
  0032d	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00331	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00335	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00339	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0033d	03 ef		 add	 ebp, edi

; 451  :     xor_8k(12); xor_8k(13); xor_8k(14); xor_8k(15);

  0033f	0f b6 6b 0c	 movzx	 ebp, BYTE PTR [ebx+12]
  00343	89 6c 24 14	 mov	 DWORD PTR tv1493[esp+12], ebp
  00347	83 e5 0f	 and	 ebp, 15			; 0000000fH
  0034a	81 c5 80 01 00
	00		 add	 ebp, 384		; 00000180H
  00350	c1 e5 04	 shl	 ebp, 4
  00353	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00357	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0035b	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0035f	03 ef		 add	 ebp, edi
  00361	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]
  00364	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1493[esp+12]
  00368	c1 ed 04	 shr	 ebp, 4
  0036b	81 c5 90 01 00
	00		 add	 ebp, 400		; 00000190H
  00371	c1 e5 04	 shl	 ebp, 4
  00374	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00378	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  0037c	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00380	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00384	03 ef		 add	 ebp, edi
  00386	0f b6 6b 0d	 movzx	 ebp, BYTE PTR [ebx+13]
  0038a	89 6c 24 14	 mov	 DWORD PTR tv1535[esp+12], ebp
  0038e	83 e5 0f	 and	 ebp, 15			; 0000000fH
  00391	81 c5 a0 01 00
	00		 add	 ebp, 416		; 000001a0H
  00397	c1 e5 04	 shl	 ebp, 4
  0039a	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0039e	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  003a2	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  003a6	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  003aa	03 ef		 add	 ebp, edi
  003ac	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1535[esp+12]
  003b0	c1 ed 04	 shr	 ebp, 4
  003b3	81 c5 b0 01 00
	00		 add	 ebp, 432		; 000001b0H
  003b9	c1 e5 04	 shl	 ebp, 4
  003bc	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  003c0	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  003c4	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  003c8	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  003cc	03 ef		 add	 ebp, edi
  003ce	0f b6 6b 0e	 movzx	 ebp, BYTE PTR [ebx+14]
  003d2	89 6c 24 14	 mov	 DWORD PTR tv1577[esp+12], ebp
  003d6	83 e5 0f	 and	 ebp, 15			; 0000000fH
  003d9	81 c5 c0 01 00
	00		 add	 ebp, 448		; 000001c0H
  003df	c1 e5 04	 shl	 ebp, 4
  003e2	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  003e6	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  003ea	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  003ee	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  003f2	03 ef		 add	 ebp, edi
  003f4	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1577[esp+12]
  003f8	c1 ed 04	 shr	 ebp, 4
  003fb	81 c5 d0 01 00
	00		 add	 ebp, 464		; 000001d0H
  00401	c1 e5 04	 shl	 ebp, 4
  00404	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00408	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  0040c	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00410	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00414	03 ef		 add	 ebp, edi
  00416	0f b6 6b 0f	 movzx	 ebp, BYTE PTR [ebx+15]
  0041a	89 6c 24 14	 mov	 DWORD PTR tv1619[esp+12], ebp
  0041e	83 e5 0f	 and	 ebp, 15			; 0000000fH
  00421	81 c5 e0 01 00
	00		 add	 ebp, 480		; 000001e0H
  00427	c1 e5 04	 shl	 ebp, 4
  0042a	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0042e	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00432	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00436	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0043a	03 ef		 add	 ebp, edi
  0043c	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1619[esp+12]
  00440	c1 ed 04	 shr	 ebp, 4
  00443	81 c5 f0 01 00
	00		 add	 ebp, 496		; 000001f0H
  00449	c1 e5 04	 shl	 ebp, 4
  0044c	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  00450	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00454	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00458	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0045c	03 ef		 add	 ebp, edi
  0045e	5f		 pop	 edi

; 452  :     move_block_aligned(a, r);

  0045f	89 73 0c	 mov	 DWORD PTR [ebx+12], esi
  00462	5e		 pop	 esi
  00463	5d		 pop	 ebp
  00464	89 03		 mov	 DWORD PTR [ebx], eax
  00466	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00469	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  0046c	5b		 pop	 ebx

; 453  : }

  0046d	c3		 ret	 0
_GfMul128Tab ENDP
_TEXT	ENDS
PUBLIC	_compile_8k_table
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT _compile_8k_table
_TEXT	SEGMENT
tv288 = -12						; size = 4
_i$ = -8						; size = 4
tv325 = -4						; size = 4
tv284 = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_compile_8k_table PROC					; COMDAT

; 476  : {   int i, j, k;

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 477  : 
; 478  :     memset(ctx->gf_t8k, 0, 32 * 16 * 16);

  00006	8b 74 24 20	 mov	 esi, DWORD PTR _ctx$[esp+20]
  0000a	57		 push	 edi
  0000b	68 00 20 00 00	 push	 8192			; 00002000H
  00010	6a 00		 push	 0
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memset
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 479  :     for(i = 0; i < 2 * CBLK_LEN; ++i)

  0001b	33 ed		 xor	 ebp, ebp
  0001d	89 6c 24 14	 mov	 DWORD PTR _i$[esp+28], ebp
$LL39@compile_8k:

; 480  :     {
; 481  :         if(i == 0)

  00021	85 ed		 test	 ebp, ebp
  00023	0f 85 d4 00 00
	00		 jne	 $LN18@compile_8k

; 482  :         {
; 483  :             memcpy(ctx->gf_t8k[1][8], a, CBLK_LEN);

  00029	8b 44 24 20	 mov	 eax, DWORD PTR _a$[esp+24]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 8e 80 01 00
	00		 mov	 DWORD PTR [esi+384], ecx
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 96 84 01 00
	00		 mov	 DWORD PTR [esi+388], edx
  0003e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00041	89 8e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ecx
  00047	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0004a	89 96 8c 01 00
	00		 mov	 DWORD PTR [esi+396], edx

; 484  :             for(j = 4; j > 0; j >>= 1)

  00050	bf 04 00 00 00	 mov	 edi, 4
$LL17@compile_8k:

; 485  :             {
; 486  :                 memcpy(ctx->gf_t8k[1][j], ctx->gf_t8k[1][j + j], CBLK_LEN);

  00055	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00058	c1 e0 04	 shl	 eax, 4
  0005b	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0005e	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00061	c1 e0 05	 shl	 eax, 5
  00064	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  00067	03 c6		 add	 eax, esi
  00069	89 11		 mov	 DWORD PTR [ecx], edx
  0006b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00071	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00074	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00077	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 487  :                 mul_x(ctx->gf_t8k[1][j]);

  0007a	51		 push	 ecx
  0007b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0007e	e8 00 00 00 00	 call	 _mul_x
  00083	d1 ff		 sar	 edi, 1
  00085	83 c4 04	 add	 esp, 4
  00088	85 ff		 test	 edi, edi
  0008a	7f c9		 jg	 SHORT $LL17@compile_8k

; 488  :             }
; 489  :             memcpy(ctx->gf_t8k[0][8], ctx->gf_t8k[1][1], CBLK_LEN);

  0008c	8b 8e 10 01 00
	00		 mov	 ecx, DWORD PTR [esi+272]
  00092	8b 96 14 01 00
	00		 mov	 edx, DWORD PTR [esi+276]
  00098	8d 86 80 00 00
	00		 lea	 eax, DWORD PTR [esi+128]
  0009e	89 08		 mov	 DWORD PTR [eax], ecx
  000a0	8b 8e 18 01 00
	00		 mov	 ecx, DWORD PTR [esi+280]
  000a6	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a9	8b 96 1c 01 00
	00		 mov	 edx, DWORD PTR [esi+284]
  000af	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 490  :             mul_x(ctx->gf_t8k[0][8]);

  000b2	50		 push	 eax
  000b3	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000b6	e8 00 00 00 00	 call	 _mul_x
  000bb	83 c4 04	 add	 esp, 4

; 491  :             for(j = 4; j > 0; j >>= 1)

  000be	bf 04 00 00 00	 mov	 edi, 4
$LL14@compile_8k:

; 492  :             {
; 493  :                 memcpy(ctx->gf_t8k[0][j], ctx->gf_t8k[0][j + j], CBLK_LEN);

  000c3	8b c7		 mov	 eax, edi
  000c5	c1 e0 04	 shl	 eax, 4
  000c8	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000cb	8b c7		 mov	 eax, edi
  000cd	c1 e0 05	 shl	 eax, 5
  000d0	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  000d3	03 c6		 add	 eax, esi
  000d5	89 11		 mov	 DWORD PTR [ecx], edx
  000d7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000da	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000dd	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000e0	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000e3	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 494  :                 mul_x(ctx->gf_t8k[0][j]);

  000e6	51		 push	 ecx
  000e7	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000ea	e8 00 00 00 00	 call	 _mul_x
  000ef	d1 ff		 sar	 edi, 1
  000f1	83 c4 04	 add	 esp, 4
  000f4	85 ff		 test	 edi, edi
  000f6	7f cb		 jg	 SHORT $LL14@compile_8k

; 495  :             }
; 496  :         }
; 497  :         else if(i > 1)

  000f8	e9 9e 00 00 00	 jmp	 $LN7@compile_8k
$LN18@compile_8k:
  000fd	83 fd 01	 cmp	 ebp, 1
  00100	0f 8e 95 00 00
	00		 jle	 $LN7@compile_8k

; 498  :             for(j = 8; j > 0; j >>= 1)

  00106	8d 4d fe	 lea	 ecx, DWORD PTR [ebp-2]
  00109	c1 e1 04	 shl	 ecx, 4
  0010c	8b c5		 mov	 eax, ebp
  0010e	c1 e0 04	 shl	 eax, 4
  00111	bf 08 00 00 00	 mov	 edi, 8
  00116	89 4c 24 18	 mov	 DWORD PTR tv284[esp+28], ecx
  0011a	89 44 24 10	 mov	 DWORD PTR tv288[esp+28], eax
  0011e	eb 08		 jmp	 SHORT $LN9@compile_8k
$LL38@compile_8k:
  00120	8b 44 24 10	 mov	 eax, DWORD PTR tv288[esp+28]
  00124	8b 4c 24 18	 mov	 ecx, DWORD PTR tv284[esp+28]
$LN9@compile_8k:

; 499  :             {
; 500  :                 memcpy(ctx->gf_t8k[i][j], ctx->gf_t8k[i - 2][j], CBLK_LEN);

  00128	03 cf		 add	 ecx, edi
  0012a	c1 e1 04	 shl	 ecx, 4
  0012d	8b 14 31	 mov	 edx, DWORD PTR [ecx+esi]
  00130	03 ce		 add	 ecx, esi
  00132	03 c7		 add	 eax, edi
  00134	c1 e0 04	 shl	 eax, 4
  00137	89 14 30	 mov	 DWORD PTR [eax+esi], edx
  0013a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013d	03 c6		 add	 eax, esi
  0013f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00142	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00145	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00148	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0014b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 501  :                 mul_x8(ctx->gf_t8k[i][j]);

  0014e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00151	8b d9		 mov	 ebx, ecx
  00153	8b ea		 mov	 ebp, edx
  00155	c1 ed 18	 shr	 ebp, 24			; 00000018H
  00158	c1 e1 08	 shl	 ecx, 8
  0015b	0b e9		 or	 ebp, ecx
  0015d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00160	89 68 0c	 mov	 DWORD PTR [eax+12], ebp
  00163	8b e9		 mov	 ebp, ecx
  00165	c1 ed 18	 shr	 ebp, 24			; 00000018H
  00168	c1 e2 08	 shl	 edx, 8
  0016b	0b ea		 or	 ebp, edx
  0016d	8b 10		 mov	 edx, DWORD PTR [eax]
  0016f	89 68 08	 mov	 DWORD PTR [eax+8], ebp
  00172	8b ea		 mov	 ebp, edx
  00174	c1 e1 08	 shl	 ecx, 8
  00177	c1 ed 18	 shr	 ebp, 24			; 00000018H
  0017a	0b e9		 or	 ebp, ecx
  0017c	c1 eb 18	 shr	 ebx, 24			; 00000018H
  0017f	89 68 04	 mov	 DWORD PTR [eax+4], ebp
  00182	0f b7 0c 5d 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_le[ebx*2]
  0018a	c1 e2 08	 shl	 edx, 8
  0018d	33 ca		 xor	 ecx, edx
  0018f	d1 ff		 sar	 edi, 1
  00191	89 08		 mov	 DWORD PTR [eax], ecx
  00193	85 ff		 test	 edi, edi
  00195	7f 89		 jg	 SHORT $LL38@compile_8k

; 498  :             for(j = 8; j > 0; j >>= 1)

  00197	8b 6c 24 14	 mov	 ebp, DWORD PTR _i$[esp+28]
$LN7@compile_8k:

; 502  :             }
; 503  : 
; 504  :         for(j = 2; j < 16; j += j)

  0019b	8b d5		 mov	 edx, ebp
  0019d	c1 e2 08	 shl	 edx, 8
  001a0	8b dd		 mov	 ebx, ebp
  001a2	8d 44 32 10	 lea	 eax, DWORD PTR [edx+esi+16]
  001a6	c1 e3 04	 shl	 ebx, 4
  001a9	bf 02 00 00 00	 mov	 edi, 2
  001ae	89 44 24 18	 mov	 DWORD PTR tv325[esp+28], eax
  001b2	89 5c 24 10	 mov	 DWORD PTR tv288[esp+28], ebx
$LL41@compile_8k:

; 505  :         {
; 506  :             mode(32t) *pj = ctx->gf_t8k[i][j];

  001b6	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]
  001b9	c1 e1 04	 shl	 ecx, 4

; 507  :             mode(32t) *pk = ctx->gf_t8k[i][1];
; 508  :             mode(32t) *pl = ctx->gf_t8k[i][j + 1];
; 509  : 
; 510  :             for(k = 1; k < j; ++k)

  001bc	83 ff 01	 cmp	 edi, 1
  001bf	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  001c2	8b 4c 24 18	 mov	 ecx, DWORD PTR tv325[esp+28]
  001c6	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  001c9	7e 47		 jle	 SHORT $LN5@compile_8k

; 505  :         {
; 506  :             mode(32t) *pj = ctx->gf_t8k[i][j];

  001cb	8d 5f ff	 lea	 ebx, DWORD PTR [edi-1]
  001ce	8b ff		 npad	 2
$LL3@compile_8k:

; 511  :             {
; 512  :                 *pl++ = pj[0] ^ *pk++;

  001d0	8b 29		 mov	 ebp, DWORD PTR [ecx]
  001d2	33 2a		 xor	 ebp, DWORD PTR [edx]
  001d4	83 c1 04	 add	 ecx, 4
  001d7	89 28		 mov	 DWORD PTR [eax], ebp

; 513  :                 *pl++ = pj[1] ^ *pk++;

  001d9	8b 29		 mov	 ebp, DWORD PTR [ecx]
  001db	33 6a 04	 xor	 ebp, DWORD PTR [edx+4]
  001de	83 c0 04	 add	 eax, 4
  001e1	89 28		 mov	 DWORD PTR [eax], ebp

; 514  :                 *pl++ = pj[2] ^ *pk++;

  001e3	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  001e6	33 6a 08	 xor	 ebp, DWORD PTR [edx+8]
  001e9	83 c1 04	 add	 ecx, 4
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 28		 mov	 DWORD PTR [eax], ebp

; 515  :                 *pl++ = pj[3] ^ *pk++;

  001f1	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  001f4	33 6a 0c	 xor	 ebp, DWORD PTR [edx+12]
  001f7	83 c1 04	 add	 ecx, 4
  001fa	83 c0 04	 add	 eax, 4
  001fd	89 28		 mov	 DWORD PTR [eax], ebp
  001ff	83 c0 04	 add	 eax, 4
  00202	83 c1 04	 add	 ecx, 4
  00205	83 eb 01	 sub	 ebx, 1
  00208	75 c6		 jne	 SHORT $LL3@compile_8k
  0020a	8b 6c 24 14	 mov	 ebp, DWORD PTR _i$[esp+28]
  0020e	8b 5c 24 10	 mov	 ebx, DWORD PTR tv288[esp+28]
$LN5@compile_8k:
  00212	03 ff		 add	 edi, edi
  00214	83 ff 10	 cmp	 edi, 16			; 00000010H
  00217	7c 9d		 jl	 SHORT $LL41@compile_8k
  00219	45		 inc	 ebp
  0021a	83 fd 20	 cmp	 ebp, 32			; 00000020H
  0021d	89 6c 24 14	 mov	 DWORD PTR _i$[esp+28], ebp
  00221	0f 8c fa fd ff
	ff		 jl	 $LL39@compile_8k
  00227	5f		 pop	 edi
  00228	5e		 pop	 esi
  00229	5d		 pop	 ebp
  0022a	5b		 pop	 ebx

; 516  :             }
; 517  :         }
; 518  :     }
; 519  : }

  0022b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022e	c3		 ret	 0
_compile_8k_table ENDP
_TEXT	ENDS
PUBLIC	_compile_4k_table64
; Function compile flags: /Ogtpy
;	COMDAT _compile_4k_table64
_TEXT	SEGMENT
tv288 = -12						; size = 4
_i$ = -8						; size = 4
tv313 = -4						; size = 4
tv284 = -4						; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_compile_4k_table64 PROC				; COMDAT

; 523  : {   int i, j, k;

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 524  : 
; 525  :     memset(ctx->gf_t4k, 0, sizeof(ctx->gf_t4k));

  00006	8b 74 24 20	 mov	 esi, DWORD PTR _ctx$[esp+20]
  0000a	57		 push	 edi
  0000b	68 00 10 00 00	 push	 4096			; 00001000H
  00010	6a 00		 push	 0
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memset
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  :     for(i = 0; i < 2 * CBLK_LEN8; ++i)

  0001b	33 ed		 xor	 ebp, ebp
  0001d	89 6c 24 14	 mov	 DWORD PTR _i$[esp+28], ebp
$LL39@compile_4k:

; 527  :     {
; 528  :         if(i == 0)

  00021	85 ed		 test	 ebp, ebp
  00023	0f 85 93 00 00
	00		 jne	 $LN18@compile_4k

; 529  :         {
; 530  :             memcpy(ctx->gf_t4k[1][8], a, CBLK_LEN8);

  00029	8b 44 24 20	 mov	 eax, DWORD PTR _a$[esp+24]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 8e 80 01 00
	00		 mov	 DWORD PTR [esi+384], ecx
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 96 84 01 00
	00		 mov	 DWORD PTR [esi+388], edx

; 531  :             for(j = 4; j > 0; j >>= 1)

  0003e	bf 04 00 00 00	 mov	 edi, 4
$LL17@compile_4k:

; 532  :             {
; 533  :                 memcpy(ctx->gf_t4k[1][j], ctx->gf_t4k[1][j + j], CBLK_LEN8);

  00043	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00046	c1 e0 04	 shl	 eax, 4
  00049	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0004c	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0004f	c1 e0 05	 shl	 eax, 5
  00052	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  00055	89 11		 mov	 DWORD PTR [ecx], edx
  00057	8b 44 30 04	 mov	 eax, DWORD PTR [eax+esi+4]

; 534  :                 mul_x64(ctx->gf_t4k[1][j]);

  0005b	51		 push	 ecx
  0005c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005f	e8 00 00 00 00	 call	 _mul_x64
  00064	d1 ff		 sar	 edi, 1
  00066	83 c4 04	 add	 esp, 4
  00069	85 ff		 test	 edi, edi
  0006b	7f d6		 jg	 SHORT $LL17@compile_4k

; 535  :             }
; 536  :             memcpy(ctx->gf_t4k[0][8], ctx->gf_t4k[1][1], CBLK_LEN8);

  0006d	8b 8e 10 01 00
	00		 mov	 ecx, DWORD PTR [esi+272]
  00073	8b 96 14 01 00
	00		 mov	 edx, DWORD PTR [esi+276]
  00079	8d 86 80 00 00
	00		 lea	 eax, DWORD PTR [esi+128]

; 537  :             mul_x64(ctx->gf_t4k[0][8]);

  0007f	50		 push	 eax
  00080	89 08		 mov	 DWORD PTR [eax], ecx
  00082	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00085	e8 00 00 00 00	 call	 _mul_x64
  0008a	83 c4 04	 add	 esp, 4

; 538  :             for(j = 4; j > 0; j >>= 1)

  0008d	bf 04 00 00 00	 mov	 edi, 4
$LL14@compile_4k:

; 539  :             {
; 540  :                 memcpy(ctx->gf_t4k[0][j], ctx->gf_t4k[0][j + j], CBLK_LEN8);

  00092	8b c7		 mov	 eax, edi
  00094	c1 e0 04	 shl	 eax, 4
  00097	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0009a	8b c7		 mov	 eax, edi
  0009c	c1 e0 05	 shl	 eax, 5
  0009f	8b 14 30	 mov	 edx, DWORD PTR [eax+esi]
  000a2	89 11		 mov	 DWORD PTR [ecx], edx
  000a4	8b 44 30 04	 mov	 eax, DWORD PTR [eax+esi+4]

; 541  :                 mul_x64(ctx->gf_t4k[0][j]);

  000a8	51		 push	 ecx
  000a9	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000ac	e8 00 00 00 00	 call	 _mul_x64
  000b1	d1 ff		 sar	 edi, 1
  000b3	83 c4 04	 add	 esp, 4
  000b6	85 ff		 test	 edi, edi
  000b8	7f d8		 jg	 SHORT $LL14@compile_4k

; 542  :             }
; 543  :         }
; 544  :         else if(i > 1)

  000ba	eb 6f		 jmp	 SHORT $LN7@compile_4k
$LN18@compile_4k:
  000bc	83 fd 01	 cmp	 ebp, 1
  000bf	7e 6a		 jle	 SHORT $LN7@compile_4k

; 545  :             for(j = 8; j > 0; j >>= 1)

  000c1	8d 4d fe	 lea	 ecx, DWORD PTR [ebp-2]
  000c4	c1 e1 04	 shl	 ecx, 4
  000c7	8b c5		 mov	 eax, ebp
  000c9	c1 e0 04	 shl	 eax, 4
  000cc	bf 08 00 00 00	 mov	 edi, 8
  000d1	89 4c 24 18	 mov	 DWORD PTR tv284[esp+28], ecx
  000d5	89 44 24 10	 mov	 DWORD PTR tv288[esp+28], eax
  000d9	eb 0d		 jmp	 SHORT $LN9@compile_4k
  000db	eb 03 8d 49 00	 npad	 5
$LL38@compile_4k:
  000e0	8b 44 24 10	 mov	 eax, DWORD PTR tv288[esp+28]
  000e4	8b 4c 24 18	 mov	 ecx, DWORD PTR tv284[esp+28]
$LN9@compile_4k:

; 546  :             {
; 547  :                 memcpy(ctx->gf_t4k[i][j], ctx->gf_t4k[i - 2][j], CBLK_LEN8);

  000e8	03 cf		 add	 ecx, edi
  000ea	c1 e1 04	 shl	 ecx, 4
  000ed	8b 14 31	 mov	 edx, DWORD PTR [ecx+esi]
  000f0	8b 4c 31 04	 mov	 ecx, DWORD PTR [ecx+esi+4]
  000f4	03 c7		 add	 eax, edi
  000f6	c1 e0 04	 shl	 eax, 4
  000f9	03 c6		 add	 eax, esi
  000fb	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 548  :                 mul_x8_64(ctx->gf_t4k[i][j]);

  000fe	8b d9		 mov	 ebx, ecx
  00100	8b ea		 mov	 ebp, edx
  00102	c1 e1 08	 shl	 ecx, 8
  00105	c1 ed 18	 shr	 ebp, 24			; 00000018H
  00108	0b e9		 or	 ebp, ecx
  0010a	89 10		 mov	 DWORD PTR [eax], edx
  0010c	c1 eb 18	 shr	 ebx, 24			; 00000018H
  0010f	89 68 04	 mov	 DWORD PTR [eax+4], ebp
  00112	0f b7 0c 5d 00
	00 00 00	 movzx	 ecx, WORD PTR _gft_le64[ebx*2]
  0011a	c1 e2 08	 shl	 edx, 8
  0011d	33 ca		 xor	 ecx, edx
  0011f	d1 ff		 sar	 edi, 1
  00121	89 08		 mov	 DWORD PTR [eax], ecx
  00123	85 ff		 test	 edi, edi
  00125	7f b9		 jg	 SHORT $LL38@compile_4k

; 545  :             for(j = 8; j > 0; j >>= 1)

  00127	8b 6c 24 14	 mov	 ebp, DWORD PTR _i$[esp+28]
$LN7@compile_4k:

; 549  :             }
; 550  : 
; 551  :         for(j = 2; j < 16; j += j)

  0012b	8b d5		 mov	 edx, ebp
  0012d	c1 e2 08	 shl	 edx, 8
  00130	8b dd		 mov	 ebx, ebp
  00132	8d 44 32 10	 lea	 eax, DWORD PTR [edx+esi+16]
  00136	c1 e3 04	 shl	 ebx, 4
  00139	bf 02 00 00 00	 mov	 edi, 2
  0013e	89 44 24 18	 mov	 DWORD PTR tv313[esp+28], eax
  00142	89 5c 24 10	 mov	 DWORD PTR tv288[esp+28], ebx
$LL41@compile_4k:

; 552  :         {
; 553  :             mode(32t) *pj = ctx->gf_t4k[i][j];

  00146	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]
  00149	c1 e1 04	 shl	 ecx, 4

; 554  :             mode(32t) *pk = ctx->gf_t4k[i][1];
; 555  :             mode(32t) *pl = ctx->gf_t4k[i][j + 1];
; 556  : 
; 557  :             for(k = 1; k < j; ++k)

  0014c	83 ff 01	 cmp	 edi, 1
  0014f	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00152	8b 4c 24 18	 mov	 ecx, DWORD PTR tv313[esp+28]
  00156	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  00159	7e 47		 jle	 SHORT $LN5@compile_4k

; 552  :         {
; 553  :             mode(32t) *pj = ctx->gf_t4k[i][j];

  0015b	8d 5f ff	 lea	 ebx, DWORD PTR [edi-1]
  0015e	8b ff		 npad	 2
$LL3@compile_4k:

; 558  :             {
; 559  :                 *pl++ = pj[0] ^ *pk++;

  00160	8b 29		 mov	 ebp, DWORD PTR [ecx]
  00162	33 2a		 xor	 ebp, DWORD PTR [edx]
  00164	83 c1 04	 add	 ecx, 4
  00167	89 28		 mov	 DWORD PTR [eax], ebp

; 560  :                 *pl++ = pj[1] ^ *pk++;

  00169	8b 29		 mov	 ebp, DWORD PTR [ecx]
  0016b	33 6a 04	 xor	 ebp, DWORD PTR [edx+4]
  0016e	83 c0 04	 add	 eax, 4
  00171	89 28		 mov	 DWORD PTR [eax], ebp

; 561  :                 *pl++ = pj[2] ^ *pk++;

  00173	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  00176	33 6a 08	 xor	 ebp, DWORD PTR [edx+8]
  00179	83 c1 04	 add	 ecx, 4
  0017c	83 c0 04	 add	 eax, 4
  0017f	89 28		 mov	 DWORD PTR [eax], ebp

; 562  :                 *pl++ = pj[3] ^ *pk++;

  00181	8b 69 04	 mov	 ebp, DWORD PTR [ecx+4]
  00184	33 6a 0c	 xor	 ebp, DWORD PTR [edx+12]
  00187	83 c1 04	 add	 ecx, 4
  0018a	83 c0 04	 add	 eax, 4
  0018d	89 28		 mov	 DWORD PTR [eax], ebp
  0018f	83 c0 04	 add	 eax, 4
  00192	83 c1 04	 add	 ecx, 4
  00195	83 eb 01	 sub	 ebx, 1
  00198	75 c6		 jne	 SHORT $LL3@compile_4k
  0019a	8b 6c 24 14	 mov	 ebp, DWORD PTR _i$[esp+28]
  0019e	8b 5c 24 10	 mov	 ebx, DWORD PTR tv288[esp+28]
$LN5@compile_4k:
  001a2	03 ff		 add	 edi, edi
  001a4	83 ff 10	 cmp	 edi, 16			; 00000010H
  001a7	7c 9d		 jl	 SHORT $LL41@compile_4k
  001a9	45		 inc	 ebp
  001aa	83 fd 10	 cmp	 ebp, 16			; 00000010H
  001ad	89 6c 24 14	 mov	 DWORD PTR _i$[esp+28], ebp
  001b1	0f 8c 6a fe ff
	ff		 jl	 $LL39@compile_4k
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5d		 pop	 ebp
  001ba	5b		 pop	 ebx

; 563  :             }
; 564  :         }
; 565  :     }
; 566  : }

  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001be	c3		 ret	 0
_compile_4k_table64 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _IsBitSet128
_TEXT	SEGMENT
_a$ = 8							; size = 4
_IsBitSet128 PROC					; COMDAT
; _bit$ = edx

; 570  : 	return a[(127 - bit) / 8] & (0x80 >> ((127 - bit) % 8));

  00000	83 c9 ff	 or	 ecx, -1
  00003	2b ca		 sub	 ecx, edx
  00005	83 e1 07	 and	 ecx, 7
  00008	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0000d	d3 f8		 sar	 eax, cl
  0000f	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00014	2b ca		 sub	 ecx, edx
  00016	8b 54 24 04	 mov	 edx, DWORD PTR _a$[esp-4]
  0001a	c1 e9 03	 shr	 ecx, 3
  0001d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [ecx+edx]
  00021	23 c1		 and	 eax, ecx

; 571  : }

  00023	c3		 ret	 0
_IsBitSet128 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _IsBitSet64
_TEXT	SEGMENT
_a$ = 8							; size = 4
_IsBitSet64 PROC					; COMDAT
; _bit$ = edx

; 575  : 	return a[(63 - bit) / 8] & (0x80 >> ((63 - bit) % 8));

  00000	83 c9 ff	 or	 ecx, -1
  00003	2b ca		 sub	 ecx, edx
  00005	83 e1 07	 and	 ecx, 7
  00008	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0000d	d3 f8		 sar	 eax, cl
  0000f	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00014	2b ca		 sub	 ecx, edx
  00016	8b 54 24 04	 mov	 edx, DWORD PTR _a$[esp-4]
  0001a	c1 e9 03	 shr	 ecx, 3
  0001d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [ecx+edx]
  00021	23 c1		 and	 eax, ecx

; 576  : }

  00023	c3		 ret	 0
_IsBitSet64 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _SetBit128
_TEXT	SEGMENT
_SetBit128 PROC						; COMDAT
; _bit$ = edx
; _a$ = ecx

; 580  : 	a[(127 - bit) / 8] |= 0x80 >> ((127 - bit) % 8);

  00000	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00005	2b c2		 sub	 eax, edx
  00007	c1 e8 03	 shr	 eax, 3
  0000a	03 c1		 add	 eax, ecx
  0000c	83 c9 ff	 or	 ecx, -1
  0000f	2b ca		 sub	 ecx, edx
  00011	83 e1 07	 and	 ecx, 7
  00014	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00019	d3 fa		 sar	 edx, cl
  0001b	08 10		 or	 BYTE PTR [eax], dl

; 581  : }

  0001d	c3		 ret	 0
_SetBit128 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _SetBit64
_TEXT	SEGMENT
_SetBit64 PROC						; COMDAT
; _bit$ = edx
; _a$ = ecx

; 585  : 	a[(63 - bit) / 8] |= 0x80 >> ((63 - bit) % 8);

  00000	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00005	2b c2		 sub	 eax, edx
  00007	c1 e8 03	 shr	 eax, 3
  0000a	03 c1		 add	 eax, ecx
  0000c	83 c9 ff	 or	 ecx, -1
  0000f	2b ca		 sub	 ecx, edx
  00011	83 e1 07	 and	 ecx, 7
  00014	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00019	d3 fa		 sar	 edx, cl
  0001b	08 10		 or	 BYTE PTR [eax], dl

; 586  : }

  0001d	c3		 ret	 0
_SetBit64 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MirrorBits128
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _MirrorBits128
_TEXT	SEGMENT
_t$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_MirrorBits128 PROC					; COMDAT

; 589  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
  0000e	55		 push	 ebp

; 590  : 	unsigned __int8 t[128 / 8];
; 591  : 	int i;
; 592  : 	memset (t,0,16);

  0000f	33 c0		 xor	 eax, eax
  00011	56		 push	 esi
  00012	8b 74 24 20	 mov	 esi, DWORD PTR _a$[esp+24]
  00016	57		 push	 edi
  00017	89 44 24 0c	 mov	 DWORD PTR _t$[esp+32], eax
  0001b	89 44 24 10	 mov	 DWORD PTR _t$[esp+36], eax
  0001f	89 44 24 14	 mov	 DWORD PTR _t$[esp+40], eax
  00023	89 44 24 18	 mov	 DWORD PTR _t$[esp+44], eax

; 593  : 	for (i = 0; i < 128; i++)

  00027	33 ed		 xor	 ebp, ebp

; 594  : 	{
; 595  : 		if (IsBitSet128(i, a))

  00029	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
  0002e	8b ff		 npad	 2
$LL9@MirrorBits:
  00030	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00033	83 e1 07	 and	 ecx, 7
  00036	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0003b	2b c5		 sub	 eax, ebp
  0003d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00042	d3 fa		 sar	 edx, cl
  00044	8b c8		 mov	 ecx, eax
  00046	c1 e9 03	 shr	 ecx, 3
  00049	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  0004c	84 d1		 test	 dl, cl
  0004e	74 21		 je	 SHORT $LN8@MirrorBits

; 596  : 			SetBit128 (127 - i, t);

  00050	b9 ff ff ff ff	 mov	 ecx, -1
  00055	2b c8		 sub	 ecx, eax
  00057	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0005c	2b d0		 sub	 edx, eax
  0005e	83 e1 07	 and	 ecx, 7
  00061	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00066	c1 ea 03	 shr	 edx, 3
  00069	d3 f8		 sar	 eax, cl
  0006b	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+32]
  0006f	08 02		 or	 BYTE PTR [edx], al
$LN8@MirrorBits:
  00071	8b cf		 mov	 ecx, edi
  00073	83 e1 07	 and	 ecx, 7
  00076	b8 7e 00 00 00	 mov	 eax, 126		; 0000007eH
  0007b	2b c5		 sub	 eax, ebp
  0007d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00082	d3 fa		 sar	 edx, cl
  00084	8b c8		 mov	 ecx, eax
  00086	c1 e9 03	 shr	 ecx, 3
  00089	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  0008c	84 d1		 test	 dl, cl
  0008e	74 21		 je	 SHORT $LN28@MirrorBits
  00090	b9 ff ff ff ff	 mov	 ecx, -1
  00095	2b c8		 sub	 ecx, eax
  00097	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0009c	2b d0		 sub	 edx, eax
  0009e	83 e1 07	 and	 ecx, 7
  000a1	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  000a6	c1 ea 03	 shr	 edx, 3
  000a9	d3 f8		 sar	 eax, cl
  000ab	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+32]
  000af	08 02		 or	 BYTE PTR [edx], al
$LN28@MirrorBits:
  000b1	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  000b4	83 e1 07	 and	 ecx, 7
  000b7	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000bc	2b c5		 sub	 eax, ebp
  000be	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  000c3	d3 fa		 sar	 edx, cl
  000c5	8b c8		 mov	 ecx, eax
  000c7	c1 e9 03	 shr	 ecx, 3
  000ca	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  000cd	84 d1		 test	 dl, cl
  000cf	74 21		 je	 SHORT $LN29@MirrorBits
  000d1	b9 ff ff ff ff	 mov	 ecx, -1
  000d6	2b c8		 sub	 ecx, eax
  000d8	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  000dd	2b d0		 sub	 edx, eax
  000df	83 e1 07	 and	 ecx, 7
  000e2	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  000e7	c1 ea 03	 shr	 edx, 3
  000ea	d3 f8		 sar	 eax, cl
  000ec	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+32]
  000f0	08 02		 or	 BYTE PTR [edx], al
$LN29@MirrorBits:
  000f2	8d 4f fe	 lea	 ecx, DWORD PTR [edi-2]
  000f5	83 e1 07	 and	 ecx, 7
  000f8	b8 7c 00 00 00	 mov	 eax, 124		; 0000007cH
  000fd	2b c5		 sub	 eax, ebp
  000ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00104	d3 fa		 sar	 edx, cl
  00106	8b c8		 mov	 ecx, eax
  00108	c1 e9 03	 shr	 ecx, 3
  0010b	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  0010e	84 d1		 test	 dl, cl
  00110	74 21		 je	 SHORT $LN30@MirrorBits
  00112	b9 ff ff ff ff	 mov	 ecx, -1
  00117	2b c8		 sub	 ecx, eax
  00119	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0011e	2b d0		 sub	 edx, eax
  00120	83 e1 07	 and	 ecx, 7
  00123	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00128	c1 ea 03	 shr	 edx, 3
  0012b	d3 f8		 sar	 eax, cl
  0012d	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+32]
  00131	08 02		 or	 BYTE PTR [edx], al
$LN30@MirrorBits:
  00133	83 ef 04	 sub	 edi, 4
  00136	83 c5 04	 add	 ebp, 4
  00139	81 ff 7e ff ff
	ff		 cmp	 edi, -130		; ffffff7eH
  0013f	0f 8f eb fe ff
	ff		 jg	 $LL9@MirrorBits

; 597  : 	}
; 598  : 	memcpy (a, t, sizeof (t));

  00145	8b 4c 24 0c	 mov	 ecx, DWORD PTR _t$[esp+32]
  00149	8b 54 24 10	 mov	 edx, DWORD PTR _t$[esp+36]
  0014d	8b 44 24 14	 mov	 eax, DWORD PTR _t$[esp+40]
  00151	89 0e		 mov	 DWORD PTR [esi], ecx
  00153	8b 4c 24 18	 mov	 ecx, DWORD PTR _t$[esp+44]
  00157	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0015a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0015d	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 599  : 	burn (t,sizeof (t));

  00160	8d 54 24 0c	 lea	 edx, DWORD PTR _t$[esp+32]
  00164	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00169	8b f1		 mov	 esi, ecx
  0016b	8b c2		 mov	 eax, edx
  0016d	8d 49 00	 npad	 3
$LL17@MirrorBits:
  00170	c6 00 00	 mov	 BYTE PTR [eax], 0
  00173	40		 inc	 eax
  00174	83 ee 01	 sub	 esi, 1
  00177	75 f7		 jne	 SHORT $LL17@MirrorBits
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	5d		 pop	 ebp
  0017c	8d 64 24 00	 npad	 4
$LL2@MirrorBits:
  00180	49		 dec	 ecx
  00181	c6 02 00	 mov	 BYTE PTR [edx], 0
  00184	42		 inc	 edx
  00185	85 c9		 test	 ecx, ecx
  00187	75 f7		 jne	 SHORT $LL2@MirrorBits

; 600  : }

  00189	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  0018d	33 cc		 xor	 ecx, esp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	83 c4 14	 add	 esp, 20			; 00000014H
  00197	c3		 ret	 0
_MirrorBits128 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_MirrorBits64
; Function compile flags: /Ogtpy
;	COMDAT _MirrorBits64
_TEXT	SEGMENT
_t$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_MirrorBits64 PROC					; COMDAT

; 603  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 08	 mov	 DWORD PTR __$ArrayPad$[esp+12], eax
  0000e	55		 push	 ebp
  0000f	8b 6c 24 14	 mov	 ebp, DWORD PTR _a$[esp+12]
  00013	56		 push	 esi

; 604  : 	unsigned __int8 t[64 / 8];
; 605  : 	int i;
; 606  : 	memset (t,0,8);

  00014	33 c0		 xor	 eax, eax
  00016	57		 push	 edi
  00017	89 44 24 0c	 mov	 DWORD PTR _t$[esp+24], eax
  0001b	89 44 24 10	 mov	 DWORD PTR _t$[esp+28], eax

; 607  : 	for (i = 0; i < 64; i++)

  0001f	33 ff		 xor	 edi, edi

; 608  : 	{
; 609  : 		if (IsBitSet64(i, a))

  00021	be fe ff ff ff	 mov	 esi, -2			; fffffffeH
  00026	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL9@MirrorBits@2:
  00030	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00033	83 e1 07	 and	 ecx, 7
  00036	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0003b	2b c7		 sub	 eax, edi
  0003d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00042	d3 fa		 sar	 edx, cl
  00044	8b c8		 mov	 ecx, eax
  00046	c1 e9 03	 shr	 ecx, 3
  00049	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  0004c	84 d1		 test	 dl, cl
  0004e	74 21		 je	 SHORT $LN8@MirrorBits@2

; 610  : 			SetBit64 (63 - i, t);

  00050	b9 ff ff ff ff	 mov	 ecx, -1
  00055	2b c8		 sub	 ecx, eax
  00057	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0005c	2b d0		 sub	 edx, eax
  0005e	83 e1 07	 and	 ecx, 7
  00061	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00066	c1 ea 03	 shr	 edx, 3
  00069	d3 f8		 sar	 eax, cl
  0006b	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+24]
  0006f	08 02		 or	 BYTE PTR [edx], al
$LN8@MirrorBits@2:
  00071	8b ce		 mov	 ecx, esi
  00073	83 e1 07	 and	 ecx, 7
  00076	b8 3e 00 00 00	 mov	 eax, 62			; 0000003eH
  0007b	2b c7		 sub	 eax, edi
  0007d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00082	d3 fa		 sar	 edx, cl
  00084	8b c8		 mov	 ecx, eax
  00086	c1 e9 03	 shr	 ecx, 3
  00089	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  0008c	84 d1		 test	 dl, cl
  0008e	74 21		 je	 SHORT $LN28@MirrorBits@2
  00090	b9 ff ff ff ff	 mov	 ecx, -1
  00095	2b c8		 sub	 ecx, eax
  00097	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0009c	2b d0		 sub	 edx, eax
  0009e	83 e1 07	 and	 ecx, 7
  000a1	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  000a6	c1 ea 03	 shr	 edx, 3
  000a9	d3 f8		 sar	 eax, cl
  000ab	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+24]
  000af	08 02		 or	 BYTE PTR [edx], al
$LN28@MirrorBits@2:
  000b1	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  000b4	83 e1 07	 and	 ecx, 7
  000b7	b8 3d 00 00 00	 mov	 eax, 61			; 0000003dH
  000bc	2b c7		 sub	 eax, edi
  000be	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  000c3	d3 fa		 sar	 edx, cl
  000c5	8b c8		 mov	 ecx, eax
  000c7	c1 e9 03	 shr	 ecx, 3
  000ca	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  000cd	84 d1		 test	 dl, cl
  000cf	74 21		 je	 SHORT $LN29@MirrorBits@2
  000d1	b9 ff ff ff ff	 mov	 ecx, -1
  000d6	2b c8		 sub	 ecx, eax
  000d8	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  000dd	2b d0		 sub	 edx, eax
  000df	83 e1 07	 and	 ecx, 7
  000e2	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  000e7	c1 ea 03	 shr	 edx, 3
  000ea	d3 f8		 sar	 eax, cl
  000ec	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+24]
  000f0	08 02		 or	 BYTE PTR [edx], al
$LN29@MirrorBits@2:
  000f2	8d 4e fe	 lea	 ecx, DWORD PTR [esi-2]
  000f5	83 e1 07	 and	 ecx, 7
  000f8	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  000fd	2b c7		 sub	 eax, edi
  000ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00104	d3 fa		 sar	 edx, cl
  00106	8b c8		 mov	 ecx, eax
  00108	c1 e9 03	 shr	 ecx, 3
  0010b	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  0010e	84 d1		 test	 dl, cl
  00110	74 21		 je	 SHORT $LN30@MirrorBits@2
  00112	b9 ff ff ff ff	 mov	 ecx, -1
  00117	2b c8		 sub	 ecx, eax
  00119	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0011e	2b d0		 sub	 edx, eax
  00120	83 e1 07	 and	 ecx, 7
  00123	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00128	c1 ea 03	 shr	 edx, 3
  0012b	d3 f8		 sar	 eax, cl
  0012d	8d 54 14 0c	 lea	 edx, DWORD PTR _t$[esp+edx+24]
  00131	08 02		 or	 BYTE PTR [edx], al
$LN30@MirrorBits@2:
  00133	83 ee 04	 sub	 esi, 4
  00136	83 c7 04	 add	 edi, 4
  00139	83 fe be	 cmp	 esi, -66		; ffffffbeH
  0013c	0f 8f ee fe ff
	ff		 jg	 $LL9@MirrorBits@2

; 611  : 	}
; 612  : 	memcpy (a, t, sizeof (t));

  00142	8b 4c 24 0c	 mov	 ecx, DWORD PTR _t$[esp+24]
  00146	8b 54 24 10	 mov	 edx, DWORD PTR _t$[esp+28]
  0014a	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  0014d	89 55 04	 mov	 DWORD PTR [ebp+4], edx

; 613  : 	burn (t,sizeof (t));

  00150	8d 54 24 0c	 lea	 edx, DWORD PTR _t$[esp+24]
  00154	b9 08 00 00 00	 mov	 ecx, 8
  00159	8b f1		 mov	 esi, ecx
  0015b	8b c2		 mov	 eax, edx
  0015d	8d 49 00	 npad	 3
$LL17@MirrorBits@2:
  00160	c6 00 00	 mov	 BYTE PTR [eax], 0
  00163	40		 inc	 eax
  00164	83 ee 01	 sub	 esi, 1
  00167	75 f7		 jne	 SHORT $LL17@MirrorBits@2
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5d		 pop	 ebp
  0016c	8d 64 24 00	 npad	 4
$LL2@MirrorBits@2:
  00170	49		 dec	 ecx
  00171	c6 02 00	 mov	 BYTE PTR [edx], 0
  00174	42		 inc	 edx
  00175	85 c9		 test	 ecx, ecx
  00177	75 f7		 jne	 SHORT $LL2@MirrorBits@2

; 614  : }

  00179	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  0017d	33 cc		 xor	 ecx, esp
  0017f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	c3		 ret	 0
_MirrorBits64 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_Gf128Tab64Init
EXTRN	_free:PROC
EXTRN	_malloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Gf128Tab64Init
_TEXT	SEGMENT
tv382 = -28						; size = 4
_ctx8k$ = -24						; size = 4
_am$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf128Tab64Init PROC					; COMDAT

; 619  : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+28], eax
  0000e	55		 push	 ebp
  0000f	8b 6c 24 28	 mov	 ebp, DWORD PTR _ctx$[esp+28]
  00013	56		 push	 esi
  00014	8b 74 24 28	 mov	 esi, DWORD PTR _a$[esp+32]
  00018	57		 push	 edi

; 620  : 	GfCtx8k *ctx8k;
; 621  : 	unsigned __int8 am[16];
; 622  : 	int i, j;
; 623  : 
; 624  : 	ctx8k = (GfCtx8k *) TCalloc (sizeof (GfCtx8k));

  00019	68 00 20 00 00	 push	 8192			; 00002000H
  0001e	e8 00 00 00 00	 call	 _malloc
  00023	8b f8		 mov	 edi, eax
  00025	83 c4 04	 add	 esp, 4
  00028	89 7c 24 10	 mov	 DWORD PTR _ctx8k$[esp+40], edi

; 625  : 	if (!ctx8k)

  0002c	85 ff		 test	 edi, edi
  0002e	75 12		 jne	 SHORT $LN17@Gf128Tab64
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp

; 651  : 	return TRUE;
; 652  : }

  00033	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  00037	33 cc		 xor	 ecx, esp
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00041	c3		 ret	 0
$LN17@Gf128Tab64:

; 626  : 		return FALSE;
; 627  : 
; 628  : 	memcpy (am, a, 16);

  00042	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00045	8b 06		 mov	 eax, DWORD PTR [esi]
  00047	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0004a	89 4c 24 18	 mov	 DWORD PTR _am$[esp+44], ecx
  0004e	89 44 24 14	 mov	 DWORD PTR _am$[esp+40], eax
  00052	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 629  : 	MirrorBits128 (am);

  00055	8d 4c 24 14	 lea	 ecx, DWORD PTR _am$[esp+40]
  00059	53		 push	 ebx
  0005a	51		 push	 ecx
  0005b	89 54 24 24	 mov	 DWORD PTR _am$[esp+56], edx
  0005f	89 44 24 28	 mov	 DWORD PTR _am$[esp+60], eax
  00063	e8 00 00 00 00	 call	 _MirrorBits128

; 630  :     compile_8k_table (am, ctx8k);

  00068	8d 54 24 1c	 lea	 edx, DWORD PTR _am$[esp+48]
  0006c	57		 push	 edi
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _compile_8k_table
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	33 db		 xor	 ebx, ebx
  00078	81 c7 00 0f 00
	00		 add	 edi, 3840		; 00000f00H
  0007e	89 7c 24 10	 mov	 DWORD PTR tv382[esp+44], edi
$LL50@Gf128Tab64:

; 631  : 
; 632  : 	/* Convert 8k LSB-first table to 4k MSB-first */
; 633  : 	for (i = 16; i < 32; i++) 
; 634  : 	{
; 635  : 		for (j = 0; j < 16; j++) 

  00082	8b 7c 24 10	 mov	 edi, DWORD PTR tv382[esp+44]
  00086	33 f6		 xor	 esi, esi
$LL13@Gf128Tab64:

; 636  : 		{
; 637  : 			int jm = 0;
; 638  : 			jm |= (j & 0x1) << 3;
; 639  : 			jm |= (j & 0x2) << 1;
; 640  : 			jm |= (j & 0x4) >> 1;
; 641  : 			jm |= (j & 0x8) >> 3;

  00088	8b c6		 mov	 eax, esi
  0008a	c1 f8 02	 sar	 eax, 2
  0008d	83 e0 02	 and	 eax, 2
  00090	8b ce		 mov	 ecx, esi
  00092	83 e1 04	 and	 ecx, 4
  00095	0b c1		 or	 eax, ecx
  00097	8b d6		 mov	 edx, esi
  00099	83 e2 01	 and	 edx, 1
  0009c	03 d2		 add	 edx, edx
  0009e	03 d2		 add	 edx, edx
  000a0	8b ce		 mov	 ecx, esi
  000a2	83 e1 02	 and	 ecx, 2
  000a5	0b d1		 or	 edx, ecx

; 642  : 
; 643  : 			memcpy (&ctx->gf_t128[i-16][jm], (unsigned char *)&ctx8k->gf_t8k[31-i][j], 16);

  000a7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a9	03 d2		 add	 edx, edx
  000ab	d1 f8		 sar	 eax, 1
  000ad	0b c2		 or	 eax, edx
  000af	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  000b2	c1 e2 04	 shl	 edx, 4
  000b5	8d 04 2a	 lea	 eax, DWORD PTR [edx+ebp]
  000b8	89 08		 mov	 DWORD PTR [eax], ecx
  000ba	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000bd	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000c0	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000c3	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000c6	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]

; 644  : 			MirrorBits128 ((unsigned char *)&ctx->gf_t128[i-16][jm]);

  000c9	50		 push	 eax
  000ca	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000cd	e8 00 00 00 00	 call	 _MirrorBits128
  000d2	46		 inc	 esi
  000d3	83 c4 04	 add	 esp, 4
  000d6	83 c7 10	 add	 edi, 16			; 00000010H
  000d9	83 fe 10	 cmp	 esi, 16			; 00000010H
  000dc	7c aa		 jl	 SHORT $LL13@Gf128Tab64
  000de	81 6c 24 10 00
	01 00 00	 sub	 DWORD PTR tv382[esp+44], 256 ; 00000100H
  000e6	83 c3 10	 add	 ebx, 16			; 00000010H
  000e9	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000ef	7c 91		 jl	 SHORT $LL50@Gf128Tab64

; 645  : 		}
; 646  : 	}
; 647  : 
; 648  : 	burn (ctx8k ,sizeof (*ctx8k));

  000f1	8b 7c 24 14	 mov	 edi, DWORD PTR _ctx8k$[esp+44]
  000f5	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000fa	8b d7		 mov	 edx, edi
  000fc	8b f1		 mov	 esi, ecx
  000fe	8b c7		 mov	 eax, edi
  00100	5b		 pop	 ebx
$LL21@Gf128Tab64:
  00101	c6 00 00	 mov	 BYTE PTR [eax], 0
  00104	40		 inc	 eax
  00105	83 ee 01	 sub	 esi, 1
  00108	75 f7		 jne	 SHORT $LL21@Gf128Tab64
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL7@Gf128Tab64:
  00110	49		 dec	 ecx
  00111	c6 02 00	 mov	 BYTE PTR [edx], 0
  00114	42		 inc	 edx
  00115	85 c9		 test	 ecx, ecx
  00117	75 f7		 jne	 SHORT $LL7@Gf128Tab64

; 649  : 	burn (am, sizeof (am));

  00119	8d 54 24 14	 lea	 edx, DWORD PTR _am$[esp+40]
  0011d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00122	8b f1		 mov	 esi, ecx
  00124	8b c2		 mov	 eax, edx
$LL25@Gf128Tab64:
  00126	c6 00 00	 mov	 BYTE PTR [eax], 0
  00129	40		 inc	 eax
  0012a	83 ee 01	 sub	 esi, 1
  0012d	75 f7		 jne	 SHORT $LL25@Gf128Tab64
  0012f	90		 npad	 1
$LL2@Gf128Tab64:
  00130	49		 dec	 ecx
  00131	c6 02 00	 mov	 BYTE PTR [edx], 0
  00134	42		 inc	 edx
  00135	85 c9		 test	 ecx, ecx
  00137	75 f7		 jne	 SHORT $LL2@Gf128Tab64

; 650  : 	TCfree (ctx8k);

  00139	57		 push	 edi
  0013a	e8 00 00 00 00	 call	 _free

; 651  : 	return TRUE;
; 652  : }

  0013f	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  00143	83 c4 04	 add	 esp, 4
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5d		 pop	 ebp
  00149	33 cc		 xor	 ecx, esp
  0014b	b8 01 00 00 00	 mov	 eax, 1
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	83 c4 1c	 add	 esp, 28			; 0000001cH
  00158	c3		 ret	 0
_Gf128Tab64Init ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_Gf64TabInit
; Function compile flags: /Ogtpy
;	COMDAT _Gf64TabInit
_TEXT	SEGMENT
tv382 = -20						; size = 4
_ctx4k$ = -16						; size = 4
_am$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ctx$ = 12						; size = 4
_Gf64TabInit PROC					; COMDAT

; 655  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
  0000e	55		 push	 ebp
  0000f	8b 6c 24 20	 mov	 ebp, DWORD PTR _ctx$[esp+20]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7c 24 24	 mov	 edi, DWORD PTR _a$[esp+28]

; 656  : 	/* Deprecated/legacy */
; 657  : 
; 658  : 	GfCtx4k64 *ctx4k;
; 659  : 	unsigned __int8 am[8];
; 660  : 	int i, j;
; 661  : 
; 662  : 	ctx4k = (GfCtx4k64 *) TCalloc (sizeof (GfCtx4k64));

  00019	68 00 10 00 00	 push	 4096			; 00001000H
  0001e	e8 00 00 00 00	 call	 _malloc
  00023	8b f0		 mov	 esi, eax
  00025	83 c4 04	 add	 esp, 4
  00028	89 74 24 10	 mov	 DWORD PTR _ctx4k$[esp+32], esi

; 663  : 	if (!ctx4k)

  0002c	85 f6		 test	 esi, esi
  0002e	75 12		 jne	 SHORT $LN17@Gf64TabIni
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp

; 689  : 	return TRUE;
; 690  : }

  00033	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  00037	33 cc		 xor	 ecx, esp
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	83 c4 14	 add	 esp, 20			; 00000014H
  00041	c3		 ret	 0
$LN17@Gf64TabIni:

; 664  : 		return FALSE;
; 665  : 
; 666  : 	memcpy (am, a, 8);

  00042	8b 07		 mov	 eax, DWORD PTR [edi]
  00044	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 667  : 	MirrorBits64 (am);

  00047	8d 54 24 14	 lea	 edx, DWORD PTR _am$[esp+32]
  0004b	53		 push	 ebx
  0004c	52		 push	 edx
  0004d	89 44 24 1c	 mov	 DWORD PTR _am$[esp+40], eax
  00051	89 4c 24 20	 mov	 DWORD PTR _am$[esp+44], ecx
  00055	e8 00 00 00 00	 call	 _MirrorBits64

; 668  :     compile_4k_table64 (am, ctx4k);

  0005a	8d 44 24 1c	 lea	 eax, DWORD PTR _am$[esp+40]
  0005e	56		 push	 esi
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _compile_4k_table64
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	81 c6 00 0f 00
	00		 add	 esi, 3840		; 00000f00H
  0006e	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  00073	89 74 24 10	 mov	 DWORD PTR tv382[esp+36], esi
$LL50@Gf64TabIni:

; 669  : 
; 670  : 	/* Convert LSB-first table to MSB-first */
; 671  : 	for (i = 0; i < 16; i++) 
; 672  : 	{
; 673  : 		for (j = 0; j < 16; j++) 

  00077	8b 7c 24 10	 mov	 edi, DWORD PTR tv382[esp+36]
  0007b	33 f6		 xor	 esi, esi
  0007d	8d 49 00	 npad	 3
$LL13@Gf64TabIni:

; 674  : 		{
; 675  : 			int jm = 0;
; 676  : 			jm |= (j & 0x1) << 3;
; 677  : 			jm |= (j & 0x2) << 1;
; 678  : 			jm |= (j & 0x4) >> 1;
; 679  : 			jm |= (j & 0x8) >> 3;

  00080	8b c6		 mov	 eax, esi
  00082	c1 f8 02	 sar	 eax, 2
  00085	83 e0 02	 and	 eax, 2
  00088	8b ce		 mov	 ecx, esi
  0008a	83 e1 04	 and	 ecx, 4
  0008d	0b c1		 or	 eax, ecx
  0008f	8b d6		 mov	 edx, esi
  00091	83 e2 01	 and	 edx, 1
  00094	03 d2		 add	 edx, edx
  00096	03 d2		 add	 edx, edx
  00098	8b ce		 mov	 ecx, esi
  0009a	83 e1 02	 and	 ecx, 2
  0009d	0b d1		 or	 edx, ecx

; 680  : 
; 681  : 			memcpy (&ctx->gf_t64[i][jm], (unsigned char *)&ctx4k->gf_t4k[15-i][j], 8);

  0009f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a1	03 d2		 add	 edx, edx
  000a3	d1 f8		 sar	 eax, 1
  000a5	0b c2		 or	 eax, edx
  000a7	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  000aa	8d 44 d5 00	 lea	 eax, DWORD PTR [ebp+edx*8]
  000ae	89 08		 mov	 DWORD PTR [eax], ecx
  000b0	8b 57 04	 mov	 edx, DWORD PTR [edi+4]

; 682  : 			MirrorBits64 ((unsigned char *)&ctx->gf_t64[i][jm]);

  000b3	50		 push	 eax
  000b4	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000b7	e8 00 00 00 00	 call	 _MirrorBits64
  000bc	46		 inc	 esi
  000bd	83 c4 04	 add	 esp, 4
  000c0	83 c7 10	 add	 edi, 16			; 00000010H
  000c3	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c6	7c b8		 jl	 SHORT $LL13@Gf64TabIni
  000c8	81 6c 24 10 00
	01 00 00	 sub	 DWORD PTR tv382[esp+36], 256 ; 00000100H
  000d0	83 c3 10	 add	 ebx, 16			; 00000010H
  000d3	81 fb 00 03 00
	00		 cmp	 ebx, 768		; 00000300H
  000d9	7c 9c		 jl	 SHORT $LL50@Gf64TabIni

; 683  : 		}
; 684  : 	}
; 685  : 
; 686  : 	burn (ctx4k,sizeof (*ctx4k));

  000db	8b 7c 24 14	 mov	 edi, DWORD PTR _ctx4k$[esp+36]
  000df	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000e4	8b d7		 mov	 edx, edi
  000e6	8b f1		 mov	 esi, ecx
  000e8	8b c7		 mov	 eax, edi
  000ea	5b		 pop	 ebx
  000eb	eb 03 8d 49 00	 npad	 5
$LL21@Gf64TabIni:
  000f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000f3	40		 inc	 eax
  000f4	83 ee 01	 sub	 esi, 1
  000f7	75 f7		 jne	 SHORT $LL21@Gf64TabIni
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL7@Gf64TabIni:
  00100	49		 dec	 ecx
  00101	c6 02 00	 mov	 BYTE PTR [edx], 0
  00104	42		 inc	 edx
  00105	85 c9		 test	 ecx, ecx
  00107	75 f7		 jne	 SHORT $LL7@Gf64TabIni

; 687  : 	burn (am, sizeof (am));

  00109	8d 54 24 14	 lea	 edx, DWORD PTR _am$[esp+32]
  0010d	b9 08 00 00 00	 mov	 ecx, 8
  00112	8b f1		 mov	 esi, ecx
  00114	8b c2		 mov	 eax, edx
$LL25@Gf64TabIni:
  00116	c6 00 00	 mov	 BYTE PTR [eax], 0
  00119	40		 inc	 eax
  0011a	83 ee 01	 sub	 esi, 1
  0011d	75 f7		 jne	 SHORT $LL25@Gf64TabIni
  0011f	90		 npad	 1
$LL2@Gf64TabIni:
  00120	49		 dec	 ecx
  00121	c6 02 00	 mov	 BYTE PTR [edx], 0
  00124	42		 inc	 edx
  00125	85 c9		 test	 ecx, ecx
  00127	75 f7		 jne	 SHORT $LL2@Gf64TabIni

; 688  : 	TCfree (ctx4k);

  00129	57		 push	 edi
  0012a	e8 00 00 00 00	 call	 _free

; 689  : 	return TRUE;
; 690  : }

  0012f	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  00133	83 c4 04	 add	 esp, 4
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5d		 pop	 ebp
  00139	33 cc		 xor	 ecx, esp
  0013b	b8 01 00 00 00	 mov	 eax, 1
  00140	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00145	83 c4 14	 add	 esp, 20			; 00000014H
  00148	c3		 ret	 0
_Gf64TabInit ENDP
_TEXT	ENDS
PUBLIC	_Gf128MulBy64Tab
; Function compile flags: /Ogtpy
;	COMDAT _Gf128MulBy64Tab
_TEXT	SEGMENT
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf128MulBy64Tab PROC					; COMDAT

; 698  : {  

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 699  : 	unsigned __int32 r[CBLK_LEN >> 2];
; 700  : 
; 701  : 	move_block_aligned(r, ctx->gf_t128[7*2][a[7] & 15]);

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _a$[esp+4]
  00006	0f b6 5d 07	 movzx	 ebx, BYTE PTR [ebp+7]
  0000a	56		 push	 esi
  0000b	8b f3		 mov	 esi, ebx
  0000d	83 e6 0f	 and	 esi, 15			; 0000000fH
  00010	81 c6 e0 00 00
	00		 add	 esi, 224		; 000000e0H

; 702  :     xor_block_aligned(r,  ctx->gf_t128[7*2+1][a[7] >> 4]);

  00016	c1 eb 04	 shr	 ebx, 4
  00019	c1 e6 04	 shl	 esi, 4
  0001c	57		 push	 edi
  0001d	8b 7c 24 1c	 mov	 edi, DWORD PTR _ctx$[esp+12]
  00021	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  00024	8b 4c 3e 04	 mov	 ecx, DWORD PTR [esi+edi+4]
  00028	8b 54 3e 08	 mov	 edx, DWORD PTR [esi+edi+8]
  0002c	03 f7		 add	 esi, edi
  0002e	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  00031	81 c3 f0 00 00
	00		 add	 ebx, 240		; 000000f0H
  00037	c1 e3 04	 shl	 ebx, 4
  0003a	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  0003d	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  00041	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  00045	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  00049	03 df		 add	 ebx, edi

; 703  : 
; 704  : 	if (*(unsigned __int16 *)a)

  0004b	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  00050	74 7a		 je	 SHORT $LN15@Gf128MulBy

; 705  : 	{
; 706  : 		xor_8kt64(0);

  00052	0f b6 6d 00	 movzx	 ebp, BYTE PTR [ebp]
  00056	8b dd		 mov	 ebx, ebp
  00058	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0005b	c1 ed 04	 shr	 ebp, 4
  0005e	c1 e3 04	 shl	 ebx, 4
  00061	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  00064	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  00068	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  0006c	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  00070	03 df		 add	 ebx, edi

; 707  : 		xor_8kt64(1);

  00072	8b 5c 24 14	 mov	 ebx, DWORD PTR _a$[esp+12]
  00076	83 c5 10	 add	 ebp, 16			; 00000010H
  00079	c1 e5 04	 shl	 ebp, 4
  0007c	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00080	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00084	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00088	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0008c	03 ef		 add	 ebp, edi
  0008e	0f b6 6b 01	 movzx	 ebp, BYTE PTR [ebx+1]
  00092	8b dd		 mov	 ebx, ebp
  00094	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00097	c1 ed 04	 shr	 ebp, 4
  0009a	83 c3 20	 add	 ebx, 32			; 00000020H
  0009d	83 c5 30	 add	 ebp, 48			; 00000030H
  000a0	c1 e3 04	 shl	 ebx, 4
  000a3	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  000a6	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  000aa	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  000ae	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  000b2	03 df		 add	 ebx, edi
  000b4	c1 e5 04	 shl	 ebp, 4
  000b7	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  000bb	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  000bf	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  000c3	03 ef		 add	 ebp, edi
  000c5	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]
  000c8	8b 6c 24 14	 mov	 ebp, DWORD PTR _a$[esp+12]
$LN15@Gf128MulBy:

; 708  : 	}
; 709  : 	if (a[2])

  000cc	80 7d 02 00	 cmp	 BYTE PTR [ebp+2], 0
  000d0	74 3e		 je	 SHORT $LN19@Gf128MulBy

; 710  : 	{
; 711  : 		xor_8kt64(2);

  000d2	0f b6 6d 02	 movzx	 ebp, BYTE PTR [ebp+2]
  000d6	8b dd		 mov	 ebx, ebp
  000d8	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000db	c1 ed 04	 shr	 ebp, 4
  000de	83 c3 40	 add	 ebx, 64			; 00000040H
  000e1	83 c5 50	 add	 ebp, 80			; 00000050H
  000e4	c1 e3 04	 shl	 ebx, 4
  000e7	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  000ea	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  000ee	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  000f2	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  000f6	03 df		 add	 ebx, edi
  000f8	c1 e5 04	 shl	 ebp, 4
  000fb	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  000ff	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00103	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00107	03 ef		 add	 ebp, edi
  00109	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]
  0010c	8b 6c 24 14	 mov	 ebp, DWORD PTR _a$[esp+12]
$LN19@Gf128MulBy:

; 712  : 	}
; 713  : 	xor_8kt64(3);

  00110	0f b6 6d 03	 movzx	 ebp, BYTE PTR [ebp+3]
  00114	8b dd		 mov	 ebx, ebp
  00116	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00119	83 c3 60	 add	 ebx, 96			; 00000060H
  0011c	c1 e3 04	 shl	 ebx, 4
  0011f	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  00122	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  00126	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  0012a	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  0012e	03 df		 add	 ebx, edi

; 714  :     xor_8kt64(4);

  00130	8b 5c 24 14	 mov	 ebx, DWORD PTR _a$[esp+12]
  00134	c1 ed 04	 shr	 ebp, 4
  00137	83 c5 70	 add	 ebp, 112		; 00000070H
  0013a	c1 e5 04	 shl	 ebp, 4
  0013d	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00141	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00145	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00149	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0014d	03 ef		 add	 ebp, edi
  0014f	0f b6 6b 04	 movzx	 ebp, BYTE PTR [ebx+4]
  00153	8b dd		 mov	 ebx, ebp
  00155	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00158	83 eb 80	 sub	 ebx, -128		; ffffff80H
  0015b	c1 ed 04	 shr	 ebp, 4
  0015e	c1 e3 04	 shl	 ebx, 4
  00161	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  00164	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  00168	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  0016c	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  00170	03 df		 add	 ebx, edi

; 715  : 	xor_8kt64(5);

  00172	8b 5c 24 14	 mov	 ebx, DWORD PTR _a$[esp+12]
  00176	81 c5 90 00 00
	00		 add	 ebp, 144		; 00000090H
  0017c	c1 e5 04	 shl	 ebp, 4
  0017f	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00183	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  00187	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  0018b	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  0018f	03 ef		 add	 ebp, edi
  00191	0f b6 6b 05	 movzx	 ebp, BYTE PTR [ebx+5]
  00195	8b dd		 mov	 ebx, ebp
  00197	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0019a	81 c3 a0 00 00
	00		 add	 ebx, 160		; 000000a0H
  001a0	c1 ed 04	 shr	 ebp, 4
  001a3	c1 e3 04	 shl	 ebx, 4
  001a6	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  001a9	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  001ad	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  001b1	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  001b5	03 df		 add	 ebx, edi

; 716  : 	xor_8kt64(6);

  001b7	8b 5c 24 14	 mov	 ebx, DWORD PTR _a$[esp+12]
  001bb	81 c5 b0 00 00
	00		 add	 ebp, 176		; 000000b0H
  001c1	c1 e5 04	 shl	 ebp, 4
  001c4	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  001c8	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  001cc	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  001d0	33 74 3d 0c	 xor	 esi, DWORD PTR [ebp+edi+12]
  001d4	03 ef		 add	 ebp, edi
  001d6	0f b6 6b 06	 movzx	 ebp, BYTE PTR [ebx+6]
  001da	8b dd		 mov	 ebx, ebp
  001dc	83 e3 0f	 and	 ebx, 15			; 0000000fH
  001df	81 c3 c0 00 00
	00		 add	 ebx, 192		; 000000c0H
  001e5	c1 ed 04	 shr	 ebp, 4
  001e8	c1 e3 04	 shl	 ebx, 4
  001eb	33 04 3b	 xor	 eax, DWORD PTR [ebx+edi]
  001ee	33 4c 3b 04	 xor	 ecx, DWORD PTR [ebx+edi+4]
  001f2	33 54 3b 08	 xor	 edx, DWORD PTR [ebx+edi+8]
  001f6	33 74 3b 0c	 xor	 esi, DWORD PTR [ebx+edi+12]
  001fa	03 df		 add	 ebx, edi
  001fc	81 c5 d0 00 00
	00		 add	 ebp, 208		; 000000d0H
  00202	c1 e5 04	 shl	 ebp, 4
  00205	33 44 3d 00	 xor	 eax, DWORD PTR [ebp+edi]
  00209	33 4c 3d 04	 xor	 ecx, DWORD PTR [ebp+edi+4]
  0020d	33 54 3d 08	 xor	 edx, DWORD PTR [ebp+edi+8]
  00211	03 ef		 add	 ebp, edi
  00213	33 75 0c	 xor	 esi, DWORD PTR [ebp+12]

; 717  : 
; 718  :     move_block_aligned(p, r);

  00216	8b 7c 24 18	 mov	 edi, DWORD PTR _p$[esp+12]
  0021a	89 07		 mov	 DWORD PTR [edi], eax
  0021c	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0021f	89 57 08	 mov	 DWORD PTR [edi+8], edx
  00222	89 77 0c	 mov	 DWORD PTR [edi+12], esi
  00225	5f		 pop	 edi
  00226	5e		 pop	 esi
  00227	5d		 pop	 ebp
  00228	5b		 pop	 ebx

; 719  : }

  00229	c3		 ret	 0
_Gf128MulBy64Tab ENDP
_TEXT	ENDS
PUBLIC	_Gf64MulTab
; Function compile flags: /Ogtpy
;	COMDAT _Gf64MulTab
_TEXT	SEGMENT
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_ctx$ = 16						; size = 4
_Gf64MulTab PROC					; COMDAT

; 728  : 	/* Deprecated/legacy */
; 729  : 
; 730  : 	unsigned __int32 r[CBLK_LEN8 >> 2];
; 731  : 
; 732  : 	move_block_aligned64(r, ctx->gf_t64[7*2][a[7] & 15]);

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _ctx$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR _a$[esp+4]
  0000a	57		 push	 edi
  0000b	0f b6 7e 07	 movzx	 edi, BYTE PTR [esi+7]
  0000f	8b c7		 mov	 eax, edi
  00011	83 e0 0f	 and	 eax, 15			; 0000000fH
  00014	8d 8c c2 00 17
	00 00		 lea	 ecx, DWORD PTR [edx+eax*8+5888]
  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 733  :     xor_block_aligned64(r,  ctx->gf_t64[7*2+1][a[7] >> 4]);

  00020	c1 ef 04	 shr	 edi, 4
  00023	33 84 fa 80 17
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+6016]
  0002a	33 8c fa 84 17
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+6020]

; 734  : 
; 735  : 	if (*(unsigned __int16 *)a)

  00031	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  00035	8d bc fa 80 17
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+6016]
  0003c	74 6b		 je	 SHORT $LN15@Gf64MulTab

; 736  : 	{
; 737  : 		xor_8k64(0);

  0003e	0f b6 3e	 movzx	 edi, BYTE PTR [esi]
  00041	8b df		 mov	 ebx, edi
  00043	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00046	33 84 da 00 10
	00 00		 xor	 eax, DWORD PTR [edx+ebx*8+4096]
  0004d	33 8c da 04 10
	00 00		 xor	 ecx, DWORD PTR [edx+ebx*8+4100]
  00054	8d 9c da 00 10
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4096]
  0005b	c1 ef 04	 shr	 edi, 4
  0005e	33 84 fa 80 10
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+4224]
  00065	33 8c fa 84 10
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+4228]
  0006c	8d bc fa 80 10
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4224]

; 738  : 		xor_8k64(1);

  00073	0f b6 7e 01	 movzx	 edi, BYTE PTR [esi+1]
  00077	8b df		 mov	 ebx, edi
  00079	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0007c	33 84 da 00 11
	00 00		 xor	 eax, DWORD PTR [edx+ebx*8+4352]
  00083	33 8c da 04 11
	00 00		 xor	 ecx, DWORD PTR [edx+ebx*8+4356]
  0008a	8d 9c da 00 11
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4352]
  00091	c1 ef 04	 shr	 edi, 4
  00094	33 84 fa 80 11
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+4480]
  0009b	33 8c fa 84 11
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+4484]
  000a2	8d bc fa 80 11
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4480]
$LN15@Gf64MulTab:

; 739  : 	}
; 740  : 	if (a[2])

  000a9	80 7e 02 00	 cmp	 BYTE PTR [esi+2], 0
  000ad	74 36		 je	 SHORT $LN19@Gf64MulTab

; 741  : 	{
; 742  : 		xor_8k64(2);

  000af	0f b6 7e 02	 movzx	 edi, BYTE PTR [esi+2]
  000b3	8b df		 mov	 ebx, edi
  000b5	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000b8	33 84 da 00 12
	00 00		 xor	 eax, DWORD PTR [edx+ebx*8+4608]
  000bf	33 8c da 04 12
	00 00		 xor	 ecx, DWORD PTR [edx+ebx*8+4612]
  000c6	8d 9c da 00 12
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4608]
  000cd	c1 ef 04	 shr	 edi, 4
  000d0	33 84 fa 80 12
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+4736]
  000d7	33 8c fa 84 12
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+4740]
  000de	8d bc fa 80 12
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4736]
$LN19@Gf64MulTab:

; 743  : 	}
; 744  : 	xor_8k64(3);

  000e5	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  000e9	8b df		 mov	 ebx, edi
  000eb	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000ee	33 84 da 00 13
	00 00		 xor	 eax, DWORD PTR [edx+ebx*8+4864]
  000f5	33 8c da 04 13
	00 00		 xor	 ecx, DWORD PTR [edx+ebx*8+4868]
  000fc	8d 9c da 00 13
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+4864]
  00103	c1 ef 04	 shr	 edi, 4
  00106	33 84 fa 80 13
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+4992]
  0010d	33 8c fa 84 13
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+4996]
  00114	8d bc fa 80 13
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+4992]

; 745  :     xor_8k64(4);

  0011b	0f b6 7e 04	 movzx	 edi, BYTE PTR [esi+4]
  0011f	8b df		 mov	 ebx, edi
  00121	83 e3 0f	 and	 ebx, 15			; 0000000fH
  00124	33 84 da 00 14
	00 00		 xor	 eax, DWORD PTR [edx+ebx*8+5120]
  0012b	33 8c da 04 14
	00 00		 xor	 ecx, DWORD PTR [edx+ebx*8+5124]
  00132	8d 9c da 00 14
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+5120]
  00139	c1 ef 04	 shr	 edi, 4
  0013c	33 84 fa 80 14
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+5248]
  00143	33 8c fa 84 14
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+5252]
  0014a	8d bc fa 80 14
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+5248]

; 746  : 	xor_8k64(5);

  00151	0f b6 7e 05	 movzx	 edi, BYTE PTR [esi+5]

; 747  : 	xor_8k64(6);

  00155	0f b6 76 06	 movzx	 esi, BYTE PTR [esi+6]
  00159	8b df		 mov	 ebx, edi
  0015b	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0015e	33 84 da 00 15
	00 00		 xor	 eax, DWORD PTR [edx+ebx*8+5376]
  00165	33 8c da 04 15
	00 00		 xor	 ecx, DWORD PTR [edx+ebx*8+5380]
  0016c	8d 9c da 00 15
	00 00		 lea	 ebx, DWORD PTR [edx+ebx*8+5376]
  00173	c1 ef 04	 shr	 edi, 4
  00176	33 84 fa 80 15
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+5504]
  0017d	33 8c fa 84 15
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+5508]
  00184	8d bc fa 80 15
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+5504]
  0018b	8b fe		 mov	 edi, esi
  0018d	83 e7 0f	 and	 edi, 15			; 0000000fH
  00190	33 84 fa 00 16
	00 00		 xor	 eax, DWORD PTR [edx+edi*8+5632]
  00197	33 8c fa 04 16
	00 00		 xor	 ecx, DWORD PTR [edx+edi*8+5636]
  0019e	8d bc fa 00 16
	00 00		 lea	 edi, DWORD PTR [edx+edi*8+5632]
  001a5	c1 ee 04	 shr	 esi, 4
  001a8	33 84 f2 80 16
	00 00		 xor	 eax, DWORD PTR [edx+esi*8+5760]
  001af	33 8c f2 84 16
	00 00		 xor	 ecx, DWORD PTR [edx+esi*8+5764]
  001b6	8d 94 f2 80 16
	00 00		 lea	 edx, DWORD PTR [edx+esi*8+5760]

; 748  : 
; 749  :     move_block_aligned64(p, r);

  001bd	8b 54 24 14	 mov	 edx, DWORD PTR _p$[esp+8]
  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	89 02		 mov	 DWORD PTR [edx], eax
  001c5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001c8	5b		 pop	 ebx

; 750  : }

  001c9	c3		 ret	 0
_Gf64MulTab ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _xor128
_TEXT	SEGMENT
_xor128	PROC						; COMDAT
; _a$ = eax
; _b$ = ecx

; 757  : 	*a++ ^= *b++;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	31 10		 xor	 DWORD PTR [eax], edx
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	31 50 04	 xor	 DWORD PTR [eax+4], edx

; 758  : 	*a ^= *b;

  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	31 50 08	 xor	 DWORD PTR [eax+8], edx
  00010	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00013	31 48 0c	 xor	 DWORD PTR [eax+12], ecx
  00016	83 c0 08	 add	 eax, 8

; 759  : }

  00019	c3		 ret	 0
_xor128	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _shl128
_TEXT	SEGMENT
_shl128	PROC						; COMDAT
; _a$ = eax

; 762  : {

  00000	56		 push	 esi

; 763  : 	int i, x = 0, xx;

  00001	33 d2		 xor	 edx, edx
  00003	57		 push	 edi
  00004	83 c0 0e	 add	 eax, 14			; 0000000eH
  00007	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL3@shl128:

; 764  : 	for (i = 15; i >= 0; i--)
; 765  : 	{
; 766  : 		xx = (a[i] & 0x80) >> 7;

  00010	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00013	0f b6 f1	 movzx	 esi, cl

; 767  : 		a[i] = (char) ((a[i] << 1) | x);

  00016	02 c9		 add	 cl, cl
  00018	0a ca		 or	 cl, dl
  0001a	88 48 01	 mov	 BYTE PTR [eax+1], cl
  0001d	8a 08		 mov	 cl, BYTE PTR [eax]
  0001f	c1 ee 07	 shr	 esi, 7

; 768  : 		x = xx;

  00022	8b d6		 mov	 edx, esi
  00024	0f b6 f1	 movzx	 esi, cl
  00027	02 c9		 add	 cl, cl
  00029	0a ca		 or	 cl, dl
  0002b	88 08		 mov	 BYTE PTR [eax], cl
  0002d	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  00030	c1 ee 07	 shr	 esi, 7
  00033	8b d6		 mov	 edx, esi
  00035	0f b6 f1	 movzx	 esi, cl
  00038	02 c9		 add	 cl, cl
  0003a	0a ca		 or	 cl, dl
  0003c	c1 ee 07	 shr	 esi, 7
  0003f	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  00042	8a 48 fe	 mov	 cl, BYTE PTR [eax-2]
  00045	8b d6		 mov	 edx, esi
  00047	0f b6 f1	 movzx	 esi, cl
  0004a	02 c9		 add	 cl, cl
  0004c	0a ca		 or	 cl, dl
  0004e	c1 ee 07	 shr	 esi, 7
  00051	88 48 fe	 mov	 BYTE PTR [eax-2], cl
  00054	83 e8 04	 sub	 eax, 4
  00057	83 ef 01	 sub	 edi, 1
  0005a	8b d6		 mov	 edx, esi
  0005c	75 b2		 jne	 SHORT $LL3@shl128
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 769  : 	}
; 770  : }

  00060	c3		 ret	 0
_shl128	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT _GfMul128Basic
_TEXT	SEGMENT
_la$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_GfMul128Basic PROC					; COMDAT
; _b$ = ebx
; _p$ = esi

; 773  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 10	 mov	 DWORD PTR __$ArrayPad$[esp+20], eax
  0000e	8b 44 24 18	 mov	 eax, DWORD PTR _a$[esp+16]

; 774  : 	int i;
; 775  : 	unsigned __int8 la[16];
; 776  : 	memcpy (la, a, 16);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00017	89 0c 24	 mov	 DWORD PTR _la$[esp+20], ecx
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	89 54 24 04	 mov	 DWORD PTR _la$[esp+24], edx
  00021	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 777  : 	memset (p, 0, 16);

  00024	33 c0		 xor	 eax, eax
  00026	89 06		 mov	 DWORD PTR [esi], eax
  00028	55		 push	 ebp
  00029	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002c	57		 push	 edi
  0002d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 778  : 
; 779  : 	for (i = 0; i < 128; i++)

  00030	33 ed		 xor	 ebp, ebp
  00032	89 4c 24 10	 mov	 DWORD PTR _la$[esp+36], ecx
  00036	89 54 24 14	 mov	 DWORD PTR _la$[esp+40], edx
  0003a	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 780  : 	{
; 781  : 		if (IsBitSet128 (i, b))

  0003d	83 cf ff	 or	 edi, -1
$LL15@GfMul128Ba:
  00040	8b cf		 mov	 ecx, edi
  00042	83 e1 07	 and	 ecx, 7
  00045	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0004a	d3 f8		 sar	 eax, cl
  0004c	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00051	2b cd		 sub	 ecx, ebp
  00053	c1 e9 03	 shr	 ecx, 3
  00056	8a 14 19	 mov	 dl, BYTE PTR [ecx+ebx]
  00059	84 c2		 test	 al, dl
  0005b	74 1b		 je	 SHORT $LN11@GfMul128Ba

; 782  : 			xor128 ((uint64 *)p, (uint64 *)la);

  0005d	8b 44 24 08	 mov	 eax, DWORD PTR _la$[esp+28]
  00061	31 06		 xor	 DWORD PTR [esi], eax
  00063	8b 4c 24 0c	 mov	 ecx, DWORD PTR _la$[esp+32]
  00067	31 4e 04	 xor	 DWORD PTR [esi+4], ecx
  0006a	8b 54 24 10	 mov	 edx, DWORD PTR _la$[esp+36]
  0006e	8b 44 24 14	 mov	 eax, DWORD PTR _la$[esp+40]
  00072	31 56 08	 xor	 DWORD PTR [esi+8], edx
  00075	31 46 0c	 xor	 DWORD PTR [esi+12], eax
$LN11@GfMul128Ba:

; 783  : 
; 784  : 		if (la[0] & 0x80)

  00078	f6 44 24 08 80	 test	 BYTE PTR _la$[esp+28], 128 ; 00000080H

; 785  : 		{
; 786  : 			shl128 (la);

  0007d	8d 44 24 08	 lea	 eax, DWORD PTR _la$[esp+28]
  00081	74 0c		 je	 SHORT $LN2@GfMul128Ba
  00083	e8 00 00 00 00	 call	 _shl128

; 787  : 			la[15] ^= 0x87;

  00088	80 74 24 17 87	 xor	 BYTE PTR _la$[esp+43], 135 ; 00000087H

; 788  : 		}
; 789  : 		else

  0008d	eb 05		 jmp	 SHORT $LN5@GfMul128Ba
$LN2@GfMul128Ba:

; 790  : 		{
; 791  : 			shl128 (la);

  0008f	e8 00 00 00 00	 call	 _shl128
$LN5@GfMul128Ba:

; 778  : 
; 779  : 	for (i = 0; i < 128; i++)

  00094	4f		 dec	 edi
  00095	45		 inc	 ebp
  00096	81 ff 7f ff ff
	ff		 cmp	 edi, -129		; ffffff7fH
  0009c	7f a2		 jg	 SHORT $LL15@GfMul128Ba

; 792  : 		}
; 793  : 	}
; 794  : }

  0009e	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  000a2	5f		 pop	 edi
  000a3	5d		 pop	 ebp
  000a4	33 cc		 xor	 ecx, esp
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	83 c4 14	 add	 esp, 20			; 00000014H
  000ae	c3		 ret	 0
_GfMul128Basic ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _xor64
_TEXT	SEGMENT
_xor64	PROC						; COMDAT
; _a$ = eax
; _b$ = ecx

; 798  : 	*a ^= *b;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	31 10		 xor	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	31 48 04	 xor	 DWORD PTR [eax+4], ecx

; 799  : }

  0000a	c3		 ret	 0
_xor64	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _shl64
_TEXT	SEGMENT
_shl64	PROC						; COMDAT
; _a$ = eax

; 803  : 	int i, x = 0, xx;
; 804  : 	for (i = 7; i >= 0; i--)
; 805  : 	{
; 806  : 		xx = (a[i] & 0x80) >> 7;

  00000	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  00003	0f b6 d1	 movzx	 edx, cl

; 807  : 		a[i] = (char) ((a[i] << 1) | x);

  00006	02 c9		 add	 cl, cl
  00008	88 48 07	 mov	 BYTE PTR [eax+7], cl
  0000b	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	0f b6 f1	 movzx	 esi, cl
  00013	02 c9		 add	 cl, cl
  00015	c1 ea 07	 shr	 edx, 7
  00018	0a ca		 or	 cl, dl
  0001a	88 48 06	 mov	 BYTE PTR [eax+6], cl
  0001d	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00020	c1 ee 07	 shr	 esi, 7

; 808  : 		x = xx;

  00023	8b d6		 mov	 edx, esi
  00025	0f b6 f1	 movzx	 esi, cl
  00028	02 c9		 add	 cl, cl
  0002a	0a ca		 or	 cl, dl
  0002c	88 48 05	 mov	 BYTE PTR [eax+5], cl
  0002f	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00032	c1 ee 07	 shr	 esi, 7
  00035	8b d6		 mov	 edx, esi
  00037	0f b6 f1	 movzx	 esi, cl
  0003a	02 c9		 add	 cl, cl
  0003c	0a ca		 or	 cl, dl
  0003e	88 48 04	 mov	 BYTE PTR [eax+4], cl
  00041	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00044	c1 ee 07	 shr	 esi, 7
  00047	8b d6		 mov	 edx, esi
  00049	0f b6 f1	 movzx	 esi, cl
  0004c	02 c9		 add	 cl, cl
  0004e	0a ca		 or	 cl, dl
  00050	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00053	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00056	c1 ee 07	 shr	 esi, 7
  00059	8b d6		 mov	 edx, esi
  0005b	0f b6 f1	 movzx	 esi, cl
  0005e	02 c9		 add	 cl, cl
  00060	0a ca		 or	 cl, dl
  00062	88 48 02	 mov	 BYTE PTR [eax+2], cl
  00065	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00068	0f b6 d1	 movzx	 edx, cl
  0006b	c1 ee 07	 shr	 esi, 7
  0006e	02 c9		 add	 cl, cl
  00070	8b de		 mov	 ebx, esi
  00072	0a cb		 or	 cl, bl
  00074	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00077	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0007a	c1 ea 07	 shr	 edx, 7
  0007d	02 c9		 add	 cl, cl
  0007f	0a ca		 or	 cl, dl
  00081	5e		 pop	 esi
  00082	88 08		 mov	 BYTE PTR [eax], cl
  00084	5b		 pop	 ebx

; 809  : 	}
; 810  : }

  00085	c3		 ret	 0
_shl64	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT _GfMul64Basic
_TEXT	SEGMENT
_la$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_GfMul64Basic PROC					; COMDAT
; _p$ = esi

; 813  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax
  00014	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]

; 814  : 	/* Deprecated/legacy */
; 815  : 
; 816  : 	int i;
; 817  : 	unsigned __int8 la[8];
; 818  : 	memcpy (la, a, 8);

  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 819  : 	memset (p, 0, 8);

  0001c	33 c0		 xor	 eax, eax
  0001e	53		 push	 ebx
  0001f	57		 push	 edi
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 820  : 
; 821  : 	for (i = 0; i < 64; i++)

  00022	33 db		 xor	 ebx, ebx
  00024	89 4c 24 0c	 mov	 DWORD PTR _la$[esp+24], ecx
  00028	89 54 24 10	 mov	 DWORD PTR _la$[esp+28], edx
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 822  : 	{
; 823  : 		if (IsBitSet64 (i, b))

  0002f	83 cf ff	 or	 edi, -1
$LN6@GfMul64Bas:
  00032	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00035	8b cf		 mov	 ecx, edi
  00037	83 e1 07	 and	 ecx, 7
  0003a	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0003f	d3 f8		 sar	 eax, cl
  00041	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00046	2b cb		 sub	 ecx, ebx
  00048	c1 e9 03	 shr	 ecx, 3
  0004b	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  0004e	84 c1		 test	 al, cl
  00050	74 0d		 je	 SHORT $LN11@GfMul64Bas

; 824  : 			xor64 ((uint64 *)p, (uint64 *)la);

  00052	8b 54 24 0c	 mov	 edx, DWORD PTR _la$[esp+24]
  00056	8b 44 24 10	 mov	 eax, DWORD PTR _la$[esp+28]
  0005a	31 16		 xor	 DWORD PTR [esi], edx
  0005c	31 46 04	 xor	 DWORD PTR [esi+4], eax
$LN11@GfMul64Bas:

; 825  : 
; 826  : 		if (la[0] & 0x80)

  0005f	f6 44 24 0c 80	 test	 BYTE PTR _la$[esp+24], 128 ; 00000080H

; 827  : 		{
; 828  : 			shl64 (la);

  00064	8d 44 24 0c	 lea	 eax, DWORD PTR _la$[esp+24]
  00068	74 0c		 je	 SHORT $LN2@GfMul64Bas
  0006a	e8 00 00 00 00	 call	 _shl64

; 829  : 			la[7] ^= 0x1b;

  0006f	80 74 24 13 1b	 xor	 BYTE PTR _la$[esp+31], 27 ; 0000001bH

; 830  : 		}
; 831  : 		else

  00074	eb 05		 jmp	 SHORT $LN5@GfMul64Bas
$LN2@GfMul64Bas:

; 832  : 		{
; 833  : 			shl64 (la);

  00076	e8 00 00 00 00	 call	 _shl64
$LN5@GfMul64Bas:

; 820  : 
; 821  : 	for (i = 0; i < 64; i++)

  0007b	4f		 dec	 edi
  0007c	43		 inc	 ebx
  0007d	83 ff bf	 cmp	 edi, -65		; ffffffbfH
  00080	7f b0		 jg	 SHORT $LN6@GfMul64Bas

; 834  : 		}
; 835  : 	}
; 836  : }

  00082	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  00086	5f		 pop	 edi
  00087	5b		 pop	 ebx
  00088	33 cc		 xor	 ecx, esp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_GfMul64Basic ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_GfMulSelfTest
; Function compile flags: /Ogtpy
;	COMDAT _GfMulSelfTest
_TEXT	SEGMENT
_i$ = -72						; size = 4
_a$ = -68						; size = 16
_b$ = -52						; size = 16
_p1$ = -36						; size = 16
_p2$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_GfMulSelfTest PROC					; COMDAT

; 840  : {

  00000	83 ec 48	 sub	 esp, 72			; 00000048H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 44	 mov	 DWORD PTR __$ArrayPad$[esp+72], eax
  0000e	55		 push	 ebp
  0000f	57		 push	 edi

; 841  : 	BOOL result = TRUE;
; 842  : 	unsigned __int8 a[16];
; 843  : 	unsigned __int8 b[16];
; 844  : 	unsigned __int8 p1[16];
; 845  : 	unsigned __int8 p2[16];
; 846  : 	GfCtx *gfCtx = (GfCtx *) TCalloc (sizeof (GfCtx));

  00010	68 00 18 00 00	 push	 6144			; 00001800H
  00015	bd 01 00 00 00	 mov	 ebp, 1
  0001a	e8 00 00 00 00	 call	 _malloc
  0001f	8b f8		 mov	 edi, eax
  00021	83 c4 04	 add	 esp, 4

; 847  : 	int i, j;
; 848  : 
; 849  : 	if (!gfCtx)

  00024	85 ff		 test	 edi, edi
  00026	75 11		 jne	 SHORT $LN15@GfMulSelfT
  00028	5f		 pop	 edi
  00029	5d		 pop	 ebp

; 889  : 	return result;
; 890  : }

  0002a	8b 4c 24 44	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  0002e	33 cc		 xor	 ecx, esp
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	83 c4 48	 add	 esp, 72			; 00000048H
  00038	c3		 ret	 0
$LN15@GfMulSelfT:
  00039	53		 push	 ebx
  0003a	56		 push	 esi

; 850  : 		return FALSE;
; 851  : 
; 852  : 	/* GF(2^64) - deprecated/legacy */
; 853  : 	for (i = 0; i < 0x100; i++)

  0003b	33 db		 xor	 ebx, ebx
  0003d	8d 49 00	 npad	 3
$LL14@GfMulSelfT:

; 854  : 	{
; 855  : 		for (j = 0; j < 8; j++)
; 856  : 		{
; 857  : 			a[j] = (unsigned __int8) i;
; 858  : 			b[j] = a[j] ^ 0xff;

  00040	8a c3		 mov	 al, bl
  00042	f6 d0		 not	 al
  00044	0f b6 c0	 movzx	 eax, al
  00047	8a d3		 mov	 dl, bl
  00049	69 c0 01 01 01
	01		 imul	 eax, 16843009		; 01010101H
  0004f	0f b6 d2	 movzx	 edx, dl
  00052	69 d2 01 01 01
	01		 imul	 edx, 16843009		; 01010101H
  00058	89 44 24 24	 mov	 DWORD PTR _b$[esp+88], eax
  0005c	89 44 24 28	 mov	 DWORD PTR _b$[esp+92], eax
  00060	8b c2		 mov	 eax, edx

; 859  : 		}
; 860  : 
; 861  : 		GfMul64Basic (a, b, p1);

  00062	8d 4c 24 24	 lea	 ecx, DWORD PTR _b$[esp+88]
  00066	51		 push	 ecx
  00067	8d 54 24 18	 lea	 edx, DWORD PTR _a$[esp+92]
  0006b	52		 push	 edx
  0006c	8d 74 24 3c	 lea	 esi, DWORD PTR _p1$[esp+96]
  00070	89 44 24 1c	 mov	 DWORD PTR _a$[esp+96], eax
  00074	89 44 24 20	 mov	 DWORD PTR _a$[esp+100], eax
  00078	e8 00 00 00 00	 call	 _GfMul64Basic

; 862  : 	
; 863  : 		Gf64TabInit (a, gfCtx);

  0007d	8d 44 24 1c	 lea	 eax, DWORD PTR _a$[esp+96]
  00081	57		 push	 edi
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _Gf64TabInit

; 864  : 		Gf64MulTab (b, p2, gfCtx);

  00088	57		 push	 edi
  00089	8d 4c 24 58	 lea	 ecx, DWORD PTR _p2$[esp+108]
  0008d	51		 push	 ecx
  0008e	8d 54 24 3c	 lea	 edx, DWORD PTR _b$[esp+112]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _Gf64MulTab
  00098	83 c4 1c	 add	 esp, 28			; 0000001cH

; 865  : 
; 866  : 		if (memcmp (p1, p2, 8) != 0)

  0009b	b8 08 00 00 00	 mov	 eax, 8
  000a0	33 c9		 xor	 ecx, ecx
$LL21@GfMulSelfT:
  000a2	8b 54 0c 34	 mov	 edx, DWORD PTR _p1$[esp+ecx+88]
  000a6	3b 54 0c 44	 cmp	 edx, DWORD PTR _p2$[esp+ecx+88]
  000aa	75 0d		 jne	 SHORT $LN23@GfMulSelfT
  000ac	83 e8 04	 sub	 eax, 4
  000af	83 c1 04	 add	 ecx, 4
  000b2	83 f8 04	 cmp	 eax, 4
  000b5	73 eb		 jae	 SHORT $LL21@GfMulSelfT
  000b7	eb 02		 jmp	 SHORT $LN13@GfMulSelfT
$LN23@GfMulSelfT:

; 867  : 			result = FALSE;

  000b9	33 ed		 xor	 ebp, ebp
$LN13@GfMulSelfT:

; 850  : 		return FALSE;
; 851  : 
; 852  : 	/* GF(2^64) - deprecated/legacy */
; 853  : 	for (i = 0; i < 0x100; i++)

  000bb	43		 inc	 ebx
  000bc	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000c2	0f 8c 78 ff ff
	ff		 jl	 $LL14@GfMulSelfT

; 868  : 	}
; 869  : 
; 870  : 	/* GF(2^128) */
; 871  : 	for (i = 0; i < 0x100; i++)

  000c8	33 d2		 xor	 edx, edx
  000ca	89 54 24 10	 mov	 DWORD PTR _i$[esp+88], edx
  000ce	eb 04		 jmp	 SHORT $LN7@GfMulSelfT
$LL44@GfMulSelfT:
  000d0	8b 54 24 10	 mov	 edx, DWORD PTR _i$[esp+88]
$LN7@GfMulSelfT:

; 872  : 	{
; 873  : 		for (j = 0; j < 16; j++)
; 874  : 		{
; 875  : 			a[j] = (unsigned __int8) i;

  000d4	8a ca		 mov	 cl, dl
  000d6	0f b6 c9	 movzx	 ecx, cl
  000d9	33 c0		 xor	 eax, eax
  000db	69 c9 01 01 01
	01		 imul	 ecx, 16843009		; 01010101H
  000e1	89 4c 24 14	 mov	 DWORD PTR _a$[esp+88], ecx
  000e5	89 4c 24 18	 mov	 DWORD PTR _a$[esp+92], ecx
  000e9	89 4c 24 1c	 mov	 DWORD PTR _a$[esp+96], ecx
  000ed	89 4c 24 20	 mov	 DWORD PTR _a$[esp+100], ecx
$LL4@GfMulSelfT:

; 876  : 			b[j] = j < 8 ? 0 : a[j] ^ 0xff;

  000f1	83 f8 08	 cmp	 eax, 8
  000f4	7d 04		 jge	 SHORT $LN18@GfMulSelfT
  000f6	33 c9		 xor	 ecx, ecx
  000f8	eb 07		 jmp	 SHORT $LN19@GfMulSelfT
$LN18@GfMulSelfT:
  000fa	8a ca		 mov	 cl, dl
  000fc	f6 d1		 not	 cl
  000fe	0f b6 c9	 movzx	 ecx, cl
$LN19@GfMulSelfT:
  00101	88 4c 04 24	 mov	 BYTE PTR _b$[esp+eax+88], cl
  00105	40		 inc	 eax
  00106	83 f8 10	 cmp	 eax, 16			; 00000010H
  00109	7c e6		 jl	 SHORT $LL4@GfMulSelfT

; 877  : 		}
; 878  : 
; 879  : 		GfMul128Basic (a, b, p1);

  0010b	8d 54 24 14	 lea	 edx, DWORD PTR _a$[esp+88]
  0010f	52		 push	 edx
  00110	8d 74 24 38	 lea	 esi, DWORD PTR _p1$[esp+92]
  00114	8d 5c 24 28	 lea	 ebx, DWORD PTR _b$[esp+92]
  00118	e8 00 00 00 00	 call	 _GfMul128Basic

; 880  : 	
; 881  : 		Gf128Tab64Init (a, gfCtx);

  0011d	8d 44 24 18	 lea	 eax, DWORD PTR _a$[esp+92]
  00121	57		 push	 edi
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _Gf128Tab64Init

; 882  : 		Gf128MulBy64Tab (b + 8, p2, gfCtx);

  00128	57		 push	 edi
  00129	8d 4c 24 54	 lea	 ecx, DWORD PTR _p2$[esp+104]
  0012d	51		 push	 ecx
  0012e	8d 54 24 40	 lea	 edx, DWORD PTR _b$[esp+116]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 _Gf128MulBy64Tab
  00138	83 c4 18	 add	 esp, 24			; 00000018H

; 883  : 
; 884  : 		if (memcmp (p1, p2, 16) != 0)

  0013b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00140	33 c9		 xor	 ecx, ecx
$LL25@GfMulSelfT:
  00142	8b 54 0c 34	 mov	 edx, DWORD PTR _p1$[esp+ecx+88]
  00146	3b 54 0c 44	 cmp	 edx, DWORD PTR _p2$[esp+ecx+88]
  0014a	75 0d		 jne	 SHORT $LN27@GfMulSelfT
  0014c	83 e8 04	 sub	 eax, 4
  0014f	83 c1 04	 add	 ecx, 4
  00152	83 f8 04	 cmp	 eax, 4
  00155	73 eb		 jae	 SHORT $LL25@GfMulSelfT
  00157	eb 02		 jmp	 SHORT $LN6@GfMulSelfT
$LN27@GfMulSelfT:

; 885  : 			result = FALSE;

  00159	33 ed		 xor	 ebp, ebp
$LN6@GfMulSelfT:

; 868  : 	}
; 869  : 
; 870  : 	/* GF(2^128) */
; 871  : 	for (i = 0; i < 0x100; i++)

  0015b	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+88]
  0015f	40		 inc	 eax
  00160	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00165	89 44 24 10	 mov	 DWORD PTR _i$[esp+88], eax
  00169	0f 8c 61 ff ff
	ff		 jl	 $LL44@GfMulSelfT

; 886  : 	}
; 887  : 
; 888  : 	TCfree (gfCtx);

  0016f	57		 push	 edi
  00170	e8 00 00 00 00	 call	 _free

; 889  : 	return result;
; 890  : }

  00175	8b 4c 24 58	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+92]
  00179	83 c4 04	 add	 esp, 4
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	5f		 pop	 edi
  0017f	8b c5		 mov	 eax, ebp
  00181	5d		 pop	 ebp
  00182	33 cc		 xor	 ecx, esp
  00184	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00189	83 c4 48	 add	 esp, 72			; 00000048H
  0018c	c3		 ret	 0
_GfMulSelfTest ENDP
_TEXT	ENDS
END
