; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\public\desktop\projects\ciphershed\src\driver\dumpfilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_BootDriveFilterExtension DD 01H DUP (?)
_WriteFilterBuffer DD 01H DUP (?)
_BSS	ENDS
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
; File c:\users\public\desktop\projects\ciphershed\src\driver\dumpfilter.c
;	COMDAT _DumpFilterStart@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterStart@4 PROC					; COMDAT

; 142  : 	Dump ("DumpFilterStart type=%d\n", filterExtension->DumpType);
; 143  : 
; 144  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00005	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  0000c	75 09		 jne	 SHORT $LN4@DumpFilter
  0000e	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  00015	74 19		 je	 SHORT $LN1@DumpFilter
$LN4@DumpFilter:

; 145  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  00017	68 43 54 00 00	 push	 21571			; 00005443H
  0001c	6a 00		 push	 0
  0001e	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  00023	68 91 00 00 00	 push	 145			; 00000091H
  00028	6a 29		 push	 41			; 00000029H
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN6@DumpFilter:
$LN1@DumpFilter:

; 146  : 
; 147  : 	return BootDriveFilterExtension->DriveMounted ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  00030	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [eax+496]
  00036	f7 d8		 neg	 eax
  00038	1b c0		 sbb	 eax, eax
  0003a	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0003f	05 01 00 00 c0	 add	 eax, -1073741823	; c0000001H

; 148  : }

  00044	c2 04 00	 ret	 4
$LN5@DumpFilter:
_DumpFilterStart@4 ENDP
_TEXT	ENDS
EXTRN	__imp__MmBuildMdlForNonPagedPool@4:PROC
EXTRN	_EncryptDataUnitsCurrentThread@20:PROC
EXTRN	_GetIntersection@36:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	_memcpy:PROC
_BSS	SEGMENT
_WriteFilterBufferSize DD 01H DUP (?)
	ALIGN	8

_DumpPartitionOffset DQ 01H DUP (?)
; Function compile flags: /Ogsp
_BSS	ENDS
;	COMDAT _DumpFilterWrite@12
_TEXT	SEGMENT
_offset$ = -24						; size = 8
_intersectStart$ = -16					; size = 8
_dataUnit$27876 = -8					; size = 8
_filterExtension$ = 8					; size = 4
_intersectLength$ = 12					; size = 4
_diskWriteOffset$ = 12					; size = 4
_dataLength$ = 16					; size = 4
_writeMdl$ = 16						; size = 4
_DumpFilterWrite@12 PROC				; COMDAT

; 152  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 18	 sub	 esp, 24			; 00000018H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 153  : 	ULONG dataLength = MmGetMdlByteCount (writeMdl);

  0000a	8b 75 10	 mov	 esi, DWORD PTR _writeMdl$[ebp]
  0000d	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00010	57		 push	 edi

; 154  : 	uint64 offset = DumpPartitionOffset.QuadPart + diskWriteOffset->QuadPart;

  00011	8b 7d 0c	 mov	 edi, DWORD PTR _diskWriteOffset$[ebp]
  00014	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00016	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR _DumpPartitionOffset
  0001c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001f	13 05 04 00 00
	00		 adc	 eax, DWORD PTR _DumpPartitionOffset+4
  00025	89 55 10	 mov	 DWORD PTR _dataLength$[ebp], edx
  00028	89 45 ec	 mov	 DWORD PTR _offset$[ebp+4], eax

; 155  : 	uint64 intersectStart;
; 156  : 	uint32 intersectLength;
; 157  : 	PVOID writeBuffer;
; 158  : 	CSHORT origMdlFlags;
; 159  : 
; 160  : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00030	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  00037	75 09		 jne	 SHORT $LN15@DumpFilter@2
  00039	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  00040	74 19		 je	 SHORT $LN10@DumpFilter@2
$LN15@DumpFilter@2:

; 161  : 		TC_BUG_CHECK (STATUS_CRC_ERROR);

  00042	68 43 54 00 00	 push	 21571			; 00005443H
  00047	6a 00		 push	 0
  00049	68 3f 00 00 c0	 push	 -1073741761		; c000003fH
  0004e	68 a1 00 00 00	 push	 161			; 000000a1H
$LN17@DumpFilter@2:
  00053	6a 29		 push	 41			; 00000029H
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN18@DumpFilter@2:
$LN10@DumpFilter@2:

; 162  : 
; 163  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaEndUpdatePending)	// Hibernation should always abort the setup thread

  0005b	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  00061	85 c0		 test	 eax, eax
  00063	74 13		 je	 SHORT $LN9@DumpFilter@2

; 164  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00065	68 43 54 00 00	 push	 21571			; 00005443H
  0006a	6a 00		 push	 0
  0006c	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  00071	68 a4 00 00 00	 push	 164			; 000000a4H
  00076	eb db		 jmp	 SHORT $LN17@DumpFilter@2
$LN9@DumpFilter@2:

; 165  : 
; 166  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaStart == -1 || BootDriveFilterExtension->Queue.EncryptedAreaEnd == -1)

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0007d	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00083	23 88 94 00 00
	00		 and	 ecx, DWORD PTR [eax+148]
  00089	83 f9 ff	 cmp	 ecx, -1
  0008c	0f 84 bc 01 00
	00		 je	 $LN7@DumpFilter@2
  00092	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [eax+152]
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _BootDriveFilterExtension
  0009e	23 81 9c 00 00
	00		 and	 eax, DWORD PTR [ecx+156]
  000a4	83 f8 ff	 cmp	 eax, -1
  000a7	0f 84 a1 01 00
	00		 je	 $LN7@DumpFilter@2

; 167  : 		return STATUS_SUCCESS;
; 168  : 
; 169  : 	if (dataLength > WriteFilterBufferSize)

  000ad	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _WriteFilterBufferSize
  000b3	76 13		 jbe	 SHORT $LN6@DumpFilter@2

; 170  : 		TC_BUG_CHECK (STATUS_BUFFER_OVERFLOW);	// Bug check is required as returning an error does not prevent data from being written to disk

  000b5	68 43 54 00 00	 push	 21571			; 00005443H
  000ba	6a 00		 push	 0
  000bc	68 05 00 00 80	 push	 -2147483643		; 80000005H
  000c1	68 aa 00 00 00	 push	 170			; 000000aaH
  000c6	eb 8b		 jmp	 SHORT $LN17@DumpFilter@2
$LN6@DumpFilter@2:

; 171  : 
; 172  : 	if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000c8	b9 ff 01 00 00	 mov	 ecx, 511		; 000001ffH
  000cd	85 d1		 test	 edx, ecx
  000cf	74 16		 je	 SHORT $LN5@DumpFilter@2

; 173  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000d1	68 43 54 00 00	 push	 21571			; 00005443H
  000d6	6a 00		 push	 0
  000d8	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000dd	68 ad 00 00 00	 push	 173			; 000000adH
  000e2	e9 6c ff ff ff	 jmp	 $LN17@DumpFilter@2
$LN5@DumpFilter@2:

; 174  : 
; 175  : 	if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000e7	8b c3		 mov	 eax, ebx
  000e9	23 c1		 and	 eax, ecx
  000eb	33 c9		 xor	 ecx, ecx
  000ed	0b c1		 or	 eax, ecx
  000ef	74 15		 je	 SHORT $LN4@DumpFilter@2

; 176  : 		TC_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000f1	68 43 54 00 00	 push	 21571			; 00005443H
  000f6	51		 push	 ecx
  000f7	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000fc	68 b0 00 00 00	 push	 176			; 000000b0H
  00101	e9 4d ff ff ff	 jmp	 $LN17@DumpFilter@2
$LN4@DumpFilter@2:

; 177  : 
; 178  : 	writeBuffer = MmGetSystemAddressForMdlSafe (writeMdl, HighPagePriority);

  00106	f6 46 06 05	 test	 BYTE PTR [esi+6], 5
  0010a	74 05		 je	 SHORT $LN13@DumpFilter@2
  0010c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0010f	eb 13		 jmp	 SHORT $LN14@DumpFilter@2
$LN13@DumpFilter@2:
  00111	6a 20		 push	 32			; 00000020H
  00113	33 c0		 xor	 eax, eax
  00115	50		 push	 eax
  00116	50		 push	 eax
  00117	6a 01		 push	 1
  00119	50		 push	 eax
  0011a	56		 push	 esi
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
  00121	8b 55 10	 mov	 edx, DWORD PTR _dataLength$[ebp]
$LN14@DumpFilter@2:

; 179  : 	if (!writeBuffer)

  00124	85 c0		 test	 eax, eax
  00126	75 15		 jne	 SHORT $LN3@DumpFilter@2

; 180  : 		TC_BUG_CHECK (STATUS_INSUFFICIENT_RESOURCES);

  00128	68 43 54 00 00	 push	 21571			; 00005443H
  0012d	50		 push	 eax
  0012e	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  00133	68 b4 00 00 00	 push	 180			; 000000b4H
  00138	e9 16 ff ff ff	 jmp	 $LN17@DumpFilter@2
$LN3@DumpFilter@2:

; 181  : 
; 182  : 	memcpy (WriteFilterBuffer, writeBuffer, dataLength);

  0013d	52		 push	 edx
  0013e	50		 push	 eax
  0013f	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteFilterBuffer
  00145	e8 00 00 00 00	 call	 _memcpy
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 
; 184  : 	GetIntersection (offset,
; 185  : 		dataLength,
; 186  : 		BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 187  : 		BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 188  : 		&intersectStart,
; 189  : 		&intersectLength);

  0014d	8d 45 0c	 lea	 eax, DWORD PTR _intersectLength$[ebp]
  00150	50		 push	 eax
  00151	8d 45 f0	 lea	 eax, DWORD PTR _intersectStart$[ebp]
  00154	50		 push	 eax
  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  0015a	ff b0 9c 00 00
	00		 push	 DWORD PTR [eax+156]
  00160	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00165	ff b0 98 00 00
	00		 push	 DWORD PTR [eax+152]
  0016b	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00170	ff b0 94 00 00
	00		 push	 DWORD PTR [eax+148]
  00176	ff b0 90 00 00
	00		 push	 DWORD PTR [eax+144]
  0017c	ff 75 10	 push	 DWORD PTR _dataLength$[ebp]
  0017f	ff 75 ec	 push	 DWORD PTR _offset$[ebp+4]
  00182	53		 push	 ebx
  00183	e8 00 00 00 00	 call	 _GetIntersection@36

; 190  : 
; 191  : 	if (intersectLength > 0)

  00188	8b 55 0c	 mov	 edx, DWORD PTR _intersectLength$[ebp]
  0018b	85 d2		 test	 edx, edx
  0018d	76 66		 jbe	 SHORT $LN2@DumpFilter@2

; 192  : 	{
; 193  : 		UINT64_STRUCT dataUnit;
; 194  : 		dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  0018f	8b 4d f4	 mov	 ecx, DWORD PTR _intersectStart$[ebp+4]
  00192	8b 45 f0	 mov	 eax, DWORD PTR _intersectStart$[ebp]
  00195	0f ac c8 09	 shrd	 eax, ecx, 9
  00199	89 45 f8	 mov	 DWORD PTR _dataUnit$27876[ebp], eax

; 195  : 
; 196  : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  001a1	c1 e9 09	 shr	 ecx, 9
  001a4	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001ab	89 4d fc	 mov	 DWORD PTR _dataUnit$27876[ebp+4], ecx
  001ae	74 28		 je	 SHORT $LN1@DumpFilter@2

; 197  : 		{
; 198  : 			diskWriteOffset->QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  001b0	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  001b6	01 17		 add	 DWORD PTR [edi], edx
  001b8	8b 90 ac 00 00
	00		 mov	 edx, DWORD PTR [eax+172]
  001be	11 57 04	 adc	 DWORD PTR [edi+4], edx

; 199  : 			dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  001c1	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  001c7	01 55 f8	 add	 DWORD PTR _dataUnit$27876[ebp], edx
  001ca	8b 90 b4 00 00
	00		 mov	 edx, DWORD PTR [eax+180]
  001d0	13 ca		 adc	 ecx, edx
  001d2	8b 55 0c	 mov	 edx, DWORD PTR _intersectLength$[ebp]
  001d5	89 4d fc	 mov	 DWORD PTR _dataUnit$27876[ebp+4], ecx
$LN1@DumpFilter@2:

; 200  : 		}
; 201  : 
; 202  : 		EncryptDataUnitsCurrentThread (WriteFilterBuffer + (intersectStart - offset),
; 203  : 			&dataUnit,
; 204  : 			intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 205  : 			BootDriveFilterExtension->Queue.CryptoInfo);

  001d8	ff 70 70	 push	 DWORD PTR [eax+112]
  001db	c1 ea 09	 shr	 edx, 9
  001de	6a 00		 push	 0
  001e0	52		 push	 edx
  001e1	8d 45 f8	 lea	 eax, DWORD PTR _dataUnit$27876[ebp]
  001e4	50		 push	 eax
  001e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  001ea	2b c3		 sub	 eax, ebx
  001ec	03 45 f0	 add	 eax, DWORD PTR _intersectStart$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread@20
$LN2@DumpFilter@2:

; 206  : 	}
; 207  : 
; 208  : 	origMdlFlags = writeMdl->MdlFlags;
; 209  : 
; 210  : 	MmInitializeMdl (writeMdl, WriteFilterBuffer, dataLength);

  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _WriteFilterBuffer
  001fa	8b 5d 10	 mov	 ebx, DWORD PTR _dataLength$[ebp]
  001fd	0f b7 7e 06	 movzx	 edi, WORD PTR [esi+6]
  00201	83 26 00	 and	 DWORD PTR [esi], 0
  00204	8b c8		 mov	 ecx, eax
  00206	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0020b	23 da		 and	 ebx, edx
  0020d	23 ca		 and	 ecx, edx
  0020f	8d 94 0b ff 0f
	00 00		 lea	 edx, DWORD PTR [ebx+ecx+4095]
  00216	8b 5d 10	 mov	 ebx, DWORD PTR _dataLength$[ebp]
  00219	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0021c	c1 eb 0c	 shr	 ebx, 12			; 0000000cH
  0021f	03 d3		 add	 edx, ebx
  00221	8d 14 95 1c 00
	00 00		 lea	 edx, DWORD PTR [edx*4+28]
  00228	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  0022d	66 89 56 04	 mov	 WORD PTR [esi+4], dx
  00231	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00234	8b 45 10	 mov	 eax, DWORD PTR _dataLength$[ebp]
  00237	33 d2		 xor	 edx, edx

; 211  : 	MmBuildMdlForNonPagedPool (writeMdl);

  00239	56		 push	 esi
  0023a	66 89 56 06	 mov	 WORD PTR [esi+6], dx
  0023e	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00241	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 212  : 
; 213  : 	// Instead of using MmGetSystemAddressForMdlSafe(), some buggy custom storage drivers may directly test MDL_MAPPED_TO_SYSTEM_VA flag,
; 214  : 	// disregarding the fact that other MDL flags may be set by the system or a dump filter (e.g. MDL_SOURCE_IS_NONPAGED_POOL flag only).
; 215  : 	// Therefore, to work around this issue, the original flags will be restored even if they do not match the new MDL.
; 216  : 	// MS BitLocker also uses this hack/workaround (it should be safe to use until the MDL structure is changed).
; 217  : 
; 218  : 	writeMdl->MdlFlags = origMdlFlags;

  0024a	66 89 7e 06	 mov	 WORD PTR [esi+6], di
$LN7@DumpFilter@2:
  0024e	5f		 pop	 edi
  0024f	5e		 pop	 esi
  00250	33 c0		 xor	 eax, eax
  00252	5b		 pop	 ebx

; 219  : 
; 220  : 	return STATUS_SUCCESS;
; 221  : }

  00253	c9		 leave
  00254	c2 0c 00	 ret	 12			; 0000000cH
$LN16@DumpFilter@2:
_DumpFilterWrite@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _DumpFilterFinish@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterFinish@4 PROC				; COMDAT

; 226  : 	Dump ("DumpFilterFinish type=%d\n", filterExtension->DumpType);
; 227  : 
; 228  : 	return STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 229  : }

  00002	c2 04 00	 ret	 4
_DumpFilterFinish@4 ENDP
_TEXT	ENDS
EXTRN	__imp__MmFreeContiguousMemory@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _DumpFilterUnload@4
_TEXT	SEGMENT
_filterExtension$ = 8					; size = 4
_DumpFilterUnload@4 PROC				; COMDAT

; 233  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 234  : 	Dump ("DumpFilterUnload type=%d\n", filterExtension->DumpType);
; 235  : 
; 236  : 	if (WriteFilterBuffer)

  00003	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _WriteFilterBuffer
  00009	85 f6		 test	 esi, esi
  0000b	74 1f		 je	 SHORT $LN1@DumpFilter@3

; 237  : 	{
; 238  : 		memset (WriteFilterBuffer, 0, WriteFilterBufferSize);

  0000d	ff 35 00 00 00
	00		 push	 DWORD PTR _WriteFilterBufferSize
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 239  : 		MmFreeContiguousMemory (WriteFilterBuffer);

  0001e	56		 push	 esi
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmFreeContiguousMemory@4

; 240  : 		WriteFilterBuffer = NULL;

  00025	83 25 00 00 00
	00 00		 and	 DWORD PTR _WriteFilterBuffer, 0
$LN1@DumpFilter@3:

; 241  : 	}
; 242  : 
; 243  : 	return STATUS_SUCCESS;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 244  : }

  0002f	c2 04 00	 ret	 4
_DumpFilterUnload@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_DumpFilterEntry@8
EXTRN	__imp__MmAllocateContiguousMemory@12:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	_AutoTestAlgorithms@0:PROC
EXTRN	_EnableHwEncryption@4:PROC
EXTRN	_TCDeviceIoControl@24:PROC
;	COMDAT ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'T', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _DumpFilterEntry@8
_TEXT	SEGMENT
_partitionInfo$ = -52					; size = 32
_storageDeviceNumber$ = -20				; size = 12
_dumpConfig$ = -8					; size = 8
_filterExtension$ = 8					; size = 4
_version$ = 12						; size = 4
_filterInitData$ = 12					; size = 4
_DumpFilterEntry@8 PROC					; COMDAT

; 21   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 34	 sub	 esp, 52			; 00000034H
  00008	53		 push	 ebx
  00009	56		 push	 esi

; 22   : 	GetSystemDriveDumpConfigRequest dumpConfig;
; 23   : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 24   : 	STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 25   : 	PARTITION_INFORMATION partitionInfo;
; 26   : 	LONG version;
; 27   : 	NTSTATUS status;
; 28   : 
; 29   : 	Dump ("DumpFilterEntry type=%d\n", filterExtension->DumpType);
; 30   : 
; 31   : 	filterInitData->MajorVersion = DUMP_FILTER_MAJOR_VERSION;

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _filterInitData$[ebp]
  0000d	57		 push	 edi
  0000e	33 c0		 xor	 eax, eax
  00010	40		 inc	 eax

; 32   : 	filterInitData->MinorVersion = DUMP_FILTER_MINOR_VERSION;
; 33   : 	filterInitData->Flags |= DUMP_FILTER_CRITICAL;

  00011	09 46 20	 or	 DWORD PTR [esi+32], eax

; 34   : 
; 35   : 	// Check driver version of the main device
; 36   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version));

  00014	6a 04		 push	 4
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	8d 45 0c	 lea	 eax, DWORD PTR _version$[ebp]
  0001b	50		 push	 eax
  0001c	33 db		 xor	 ebx, ebx
  0001e	53		 push	 ebx
  0001f	53		 push	 ebx
  00020	68 04 20 22 00	 push	 2236420			; 00222004H
  00025	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_1CE@IPABBIFA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAT?$AAr?$AAu?$AAe?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  0002a	57		 push	 edi
  0002b	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002e	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 37   : 	if (!NT_SUCCESS (status))

  00033	3b c3		 cmp	 eax, ebx
  00035	0f 8c 47 01 00
	00		 jl	 $err$27795

; 38   : 		goto err;
; 39   : 
; 40   : 	if (version != VERSION_NUM)

  0003b	81 7d 0c 30 07
	00 00		 cmp	 DWORD PTR _version$[ebp], 1840 ; 00000730H
  00042	74 0a		 je	 SHORT $LN13@DumpFilter@4
$LN21@DumpFilter@4:

; 41   : 	{
; 42   : 		status = STATUS_INVALID_PARAMETER;

  00044	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH

; 43   : 		goto err;

  00049	e9 34 01 00 00	 jmp	 $err$27795
$LN13@DumpFilter@4:

; 44   : 	}
; 45   : 
; 46   : 	// Get dump configuration from the main device
; 47   : 	status = TCDeviceIoControl (NT_ROOT_PREFIX, TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG, NULL, 0, &dumpConfig, sizeof (dumpConfig));

  0004e	6a 08		 push	 8
  00050	8d 45 f8	 lea	 eax, DWORD PTR _dumpConfig$[ebp]
  00053	50		 push	 eax
  00054	53		 push	 ebx
  00055	53		 push	 ebx
  00056	68 98 20 22 00	 push	 2236568			; 00222098H
  0005b	57		 push	 edi
  0005c	e8 00 00 00 00	 call	 _TCDeviceIoControl@24

; 48   : 	if (!NT_SUCCESS (status))

  00061	3b c3		 cmp	 eax, ebx
  00063	0f 8c 19 01 00
	00		 jl	 $err$27795

; 49   : 		goto err;
; 50   : 
; 51   : 	BootDriveFilterExtension = dumpConfig.BootDriveFilterExtension;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _dumpConfig$[ebp]

; 52   : 
; 53   : 	if (BootDriveFilterExtension->MagicNumber != TC_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0006c	81 78 10 54 58
	45 42		 cmp	 DWORD PTR [eax+16], 1111840852 ; 42455854H
  00073	a3 00 00 00 00	 mov	 DWORD PTR _BootDriveFilterExtension, eax
  00078	75 09		 jne	 SHORT $LN17@DumpFilter@4
  0007a	81 78 14 45 55
	52 54		 cmp	 DWORD PTR [eax+20], 1414681925 ; 54525545H
  00081	74 0a		 je	 SHORT $LN11@DumpFilter@4
$LN17@DumpFilter@4:

; 54   : 	{
; 55   : 		status = STATUS_CRC_ERROR;

  00083	b8 3f 00 00 c0	 mov	 eax, -1073741761	; c000003fH

; 56   : 		goto err;

  00088	e9 f5 00 00 00	 jmp	 $err$27795
$LN11@DumpFilter@4:

; 57   : 	}
; 58   : 
; 59   : 	// KeSaveFloatingPointState() may generate a bug check during crash dump
; 60   : #if !defined (_WIN64)
; 61   : 	if (filterExtension->DumpType == DumpTypeCrashdump)

  0008d	8b 7d 08	 mov	 edi, DWORD PTR _filterExtension$[ebp]
  00090	83 3f 01	 cmp	 DWORD PTR [edi], 1
  00093	75 03		 jne	 SHORT $LN20@DumpFilter@4

; 62   : 		dumpConfig.HwEncryptionEnabled = FALSE;

  00095	89 5d fc	 mov	 DWORD PTR _dumpConfig$[ebp+4], ebx
$LN20@DumpFilter@4:

; 63   : #endif
; 64   : 
; 65   : 	EnableHwEncryption (dumpConfig.HwEncryptionEnabled);

  00098	ff 75 fc	 push	 DWORD PTR _dumpConfig$[ebp+4]
  0009b	e8 00 00 00 00	 call	 _EnableHwEncryption@4

; 66   : 
; 67   : 	if (!AutoTestAlgorithms())

  000a0	e8 00 00 00 00	 call	 _AutoTestAlgorithms@0
  000a5	85 c0		 test	 eax, eax

; 68   : 	{
; 69   : 		status = STATUS_INVALID_PARAMETER;
; 70   : 		goto err;

  000a7	74 9b		 je	 SHORT $LN21@DumpFilter@4

; 71   : 	}
; 72   : 
; 73   : 	// Check dump volume is located on the system drive
; 74   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000a9	6a 0c		 push	 12			; 0000000cH
  000ab	8d 45 ec	 lea	 eax, DWORD PTR _storageDeviceNumber$[ebp]
  000ae	50		 push	 eax
  000af	53		 push	 ebx
  000b0	53		 push	 ebx
  000b1	68 80 10 2d 00	 push	 2953344			; 002d1080H
  000b6	ff 77 04	 push	 DWORD PTR [edi+4]
  000b9	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 75   : 	if (!NT_SUCCESS (status))

  000be	3b c3		 cmp	 eax, ebx
  000c0	0f 8c bc 00 00
	00		 jl	 $err$27795

; 76   : 		goto err;
; 77   : 
; 78   : 	if (!BootDriveFilterExtension->SystemStorageDeviceNumberValid)

  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  000cb	39 58 28	 cmp	 DWORD PTR [eax+40], ebx

; 79   : 	{
; 80   : 		status = STATUS_INVALID_PARAMETER;
; 81   : 		goto err;

  000ce	0f 84 70 ff ff
	ff		 je	 $LN21@DumpFilter@4

; 82   : 	}
; 83   : 
; 84   : 	if (storageDeviceNumber.DeviceNumber != BootDriveFilterExtension->SystemStorageDeviceNumber)

  000d4	8b 4d f0	 mov	 ecx, DWORD PTR _storageDeviceNumber$[ebp+4]
  000d7	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]

; 85   : 	{
; 86   : 		status = STATUS_ACCESS_DENIED;
; 87   : 		goto err;

  000da	0f 85 9d 00 00
	00		 jne	 $LN3@DumpFilter@4

; 88   : 	}
; 89   : 
; 90   : 	// Check dump volume is located within the scope of system encryption
; 91   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &partitionInfo, sizeof (partitionInfo));

  000e0	6a 20		 push	 32			; 00000020H
  000e2	8d 45 cc	 lea	 eax, DWORD PTR _partitionInfo$[ebp]
  000e5	50		 push	 eax
  000e6	53		 push	 ebx
  000e7	53		 push	 ebx
  000e8	68 04 40 07 00	 push	 475140			; 00074004H
  000ed	ff 77 04	 push	 DWORD PTR [edi+4]
  000f0	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24

; 92   : 	if (!NT_SUCCESS (status))

  000f5	3b c3		 cmp	 eax, ebx
  000f7	0f 8c 85 00 00
	00		 jl	 $err$27795

; 93   : 		goto err;
; 94   : 
; 95   : 	DumpPartitionOffset = partitionInfo.StartingOffset;

  000fd	8b 4d d0	 mov	 ecx, DWORD PTR _partitionInfo$[ebp+4]

; 96   : 
; 97   : 	if (DumpPartitionOffset.QuadPart < BootDriveFilterExtension->ConfiguredEncryptedAreaStart
; 98   : 		|| DumpPartitionOffset.QuadPart > BootDriveFilterExtension->ConfiguredEncryptedAreaEnd)

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR _BootDriveFilterExtension
  00105	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00108	8b 55 cc	 mov	 edx, DWORD PTR _partitionInfo$[ebp]
  0010b	89 15 00 00 00
	00		 mov	 DWORD PTR _DumpPartitionOffset, edx
  00111	89 0d 04 00 00
	00		 mov	 DWORD PTR _DumpPartitionOffset+4, ecx
  00117	7c 64		 jl	 SHORT $LN3@DumpFilter@4
  00119	7f 05		 jg	 SHORT $LN18@DumpFilter@4
  0011b	3b 50 30	 cmp	 edx, DWORD PTR [eax+48]
  0011e	72 5d		 jb	 SHORT $LN3@DumpFilter@4
$LN18@DumpFilter@4:
  00120	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  00123	7f 58		 jg	 SHORT $LN3@DumpFilter@4
  00125	7c 05		 jl	 SHORT $LN19@DumpFilter@4
  00127	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  0012a	77 51		 ja	 SHORT $LN3@DumpFilter@4
$LN19@DumpFilter@4:

; 101  : 		goto err;
; 102  : 	}
; 103  : 
; 104  : 	// Allocate buffer for encryption
; 105  : 	if (filterInitData->MaxPagesPerWrite == 0)

  0012c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0012f	3b c3		 cmp	 eax, ebx

; 106  : 	{
; 107  : 		status = STATUS_INVALID_PARAMETER;
; 108  : 		goto err;

  00131	0f 84 0d ff ff
	ff		 je	 $LN21@DumpFilter@4

; 109  : 	}
; 110  : 
; 111  : 	WriteFilterBufferSize = filterInitData->MaxPagesPerWrite * PAGE_SIZE;
; 112  : 
; 113  : #ifdef _WIN64
; 114  : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFLL;
; 115  : #else
; 116  : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFLL;

  00137	33 d2		 xor	 edx, edx

; 117  : #endif
; 118  : 
; 119  : 	WriteFilterBuffer = MmAllocateContiguousMemory (WriteFilterBufferSize, highestAcceptableWriteBufferAddr);

  00139	52		 push	 edx
  0013a	83 c9 ff	 or	 ecx, -1
  0013d	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00140	51		 push	 ecx
  00141	50		 push	 eax
  00142	a3 00 00 00 00	 mov	 DWORD PTR _WriteFilterBufferSize, eax
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmAllocateContiguousMemory@12
  0014d	a3 00 00 00 00	 mov	 DWORD PTR _WriteFilterBuffer, eax

; 120  : 	if (!WriteFilterBuffer)

  00152	3b c3		 cmp	 eax, ebx
  00154	75 07		 jne	 SHORT $LN1@DumpFilter@4

; 121  : 	{
; 122  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  00156	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH

; 123  : 		goto err;

  0015b	eb 25		 jmp	 SHORT $err$27795
$LN1@DumpFilter@4:

; 124  : 	}
; 125  : 
; 126  : 	filterInitData->DumpStart = DumpFilterStart;

  0015d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET _DumpFilterStart@4

; 127  : 	filterInitData->DumpWrite = DumpFilterWrite;

  00164	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET _DumpFilterWrite@12

; 128  : 	filterInitData->DumpFinish = DumpFilterFinish;

  0016b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET _DumpFilterFinish@4

; 129  : 	filterInitData->DumpUnload = DumpFilterUnload;

  00172	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], OFFSET _DumpFilterUnload@4

; 130  : 
; 131  : 	Dump ("Dump filter loaded type=%d\n", filterExtension->DumpType);
; 132  : 	return STATUS_SUCCESS;

  00179	33 c0		 xor	 eax, eax
  0017b	eb 05		 jmp	 SHORT $err$27795
$LN3@DumpFilter@4:

; 99   : 	{
; 100  : 		status = STATUS_ACCESS_DENIED;

  0017d	b8 22 00 00 c0	 mov	 eax, -1073741790	; c0000022H
$err$27795:
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx

; 133  : 
; 134  : err:
; 135  : 	Dump ("DumpFilterEntry error %x\n", status);
; 136  : 	return status;
; 137  : }

  00185	c9		 leave
  00186	c2 08 00	 ret	 8
_DumpFilterEntry@8 ENDP
_TEXT	ENDS
END
